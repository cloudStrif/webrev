<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.awt;
  26 
  27 import java.io.PrintStream;
  28 import java.io.PrintWriter;
  29 import java.util.Vector;
  30 import java.util.Locale;
  31 import java.util.EventListener;
  32 import java.util.Iterator;
  33 import java.util.HashSet;
  34 import java.util.Map;
  35 import java.util.Set;
  36 import java.util.Collections;
  37 import java.awt.peer.ComponentPeer;
  38 import java.awt.peer.ContainerPeer;
  39 import java.awt.peer.LightweightPeer;
  40 import java.awt.image.BufferStrategy;
  41 import java.awt.image.ImageObserver;
  42 import java.awt.image.ImageProducer;
  43 import java.awt.image.ColorModel;
  44 import java.awt.image.VolatileImage;
  45 import java.awt.event.*;
  46 import java.io.Serializable;
  47 import java.io.ObjectOutputStream;
  48 import java.io.ObjectInputStream;
  49 import java.io.IOException;
  50 import java.beans.PropertyChangeListener;
  51 import java.beans.PropertyChangeSupport;
  52 import java.beans.Transient;
  53 import java.awt.event.InputMethodListener;
  54 import java.awt.event.InputMethodEvent;
  55 import java.awt.im.InputContext;
  56 import java.awt.im.InputMethodRequests;
  57 import java.awt.dnd.DropTarget;
  58 import java.lang.reflect.InvocationTargetException;
  59 import java.lang.reflect.Method;
  60 import java.security.AccessController;
  61 import java.security.PrivilegedAction;
  62 import java.security.AccessControlContext;
  63 import javax.accessibility.*;
  64 import java.applet.Applet;
  65 
  66 import sun.security.action.GetPropertyAction;
  67 import sun.awt.AppContext;
  68 import sun.awt.AWTAccessor;
  69 import sun.awt.ConstrainableGraphics;
  70 import sun.awt.SubRegionShowable;
  71 import sun.awt.SunToolkit;
  72 import sun.awt.WindowClosingListener;
  73 import sun.awt.CausedFocusEvent;
  74 import sun.awt.EmbeddedFrame;
  75 import sun.awt.dnd.SunDropTargetEvent;
  76 import sun.awt.im.CompositionArea;
  77 import sun.font.FontManager;
  78 import sun.font.FontManagerFactory;
  79 import sun.font.SunFontManager;
  80 import sun.java2d.SunGraphics2D;
  81 import sun.java2d.pipe.Region;
  82 import sun.awt.image.VSyncedBSManager;
  83 import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
  84 import static sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.*;
  85 import sun.awt.RequestFocusController;
  86 import sun.java2d.SunGraphicsEnvironment;
  87 import sun.util.logging.PlatformLogger;
  88 
  89 /**
  90  * A &lt;em&gt;component&lt;/em&gt; is an object having a graphical representation
  91  * that can be displayed on the screen and that can interact with the
  92  * user. Examples of components are the buttons, checkboxes, and scrollbars
  93  * of a typical graphical user interface. &lt;p&gt;
  94  * The &lt;code&gt;Component&lt;/code&gt; class is the abstract superclass of
  95  * the nonmenu-related Abstract Window Toolkit components. Class
  96  * &lt;code&gt;Component&lt;/code&gt; can also be extended directly to create a
  97  * lightweight component. A lightweight component is a component that is
  98  * not associated with a native window. On the contrary, a heavyweight
  99  * component is associated with a native window. The {@link #isLightweight()}
 100  * method may be used to distinguish between the two kinds of the components.
 101  * &lt;p&gt;
 102  * Lightweight and heavyweight components may be mixed in a single component
 103  * hierarchy. However, for correct operating of such a mixed hierarchy of
 104  * components, the whole hierarchy must be valid. When the hierarchy gets
 105  * invalidated, like after changing the bounds of components, or
 106  * adding/removing components to/from containers, the whole hierarchy must be
 107  * validated afterwards by means of the {@link Container#validate()} method
 108  * invoked on the top-most invalid container of the hierarchy.
 109  *
 110  * &lt;h3&gt;Serialization&lt;/h3&gt;
 111  * It is important to note that only AWT listeners which conform
 112  * to the &lt;code&gt;Serializable&lt;/code&gt; protocol will be saved when
 113  * the object is stored.  If an AWT object has listeners that
 114  * aren't marked serializable, they will be dropped at
 115  * &lt;code&gt;writeObject&lt;/code&gt; time.  Developers will need, as always,
 116  * to consider the implications of making an object serializable.
 117  * One situation to watch out for is this:
 118  * &lt;pre&gt;
 119  *    import java.awt.*;
 120  *    import java.awt.event.*;
 121  *    import java.io.Serializable;
 122  *
 123  *    class MyApp implements ActionListener, Serializable
 124  *    {
 125  *        BigObjectThatShouldNotBeSerializedWithAButton bigOne;
 126  *        Button aButton = new Button();
 127  *
 128  *        MyApp()
 129  *        {
 130  *            // Oops, now aButton has a listener with a reference
 131  *            // to bigOne!
 132  *            aButton.addActionListener(this);
 133  *        }
 134  *
 135  *        public void actionPerformed(ActionEvent e)
 136  *        {
 137  *            System.out.println("Hello There");
 138  *        }
 139  *    }
 140  * &lt;/pre&gt;
 141  * In this example, serializing &lt;code&gt;aButton&lt;/code&gt; by itself
 142  * will cause &lt;code&gt;MyApp&lt;/code&gt; and everything it refers to
 143  * to be serialized as well.  The problem is that the listener
 144  * is serializable by coincidence, not by design.  To separate
 145  * the decisions about &lt;code&gt;MyApp&lt;/code&gt; and the
 146  * &lt;code&gt;ActionListener&lt;/code&gt; being serializable one can use a
 147  * nested class, as in the following example:
 148  * &lt;pre&gt;
 149  *    import java.awt.*;
 150  *    import java.awt.event.*;
 151  *    import java.io.Serializable;
 152  *
 153  *    class MyApp implements java.io.Serializable
 154  *    {
 155  *         BigObjectThatShouldNotBeSerializedWithAButton bigOne;
 156  *         Button aButton = new Button();
 157  *
 158  *         static class MyActionListener implements ActionListener
 159  *         {
 160  *             public void actionPerformed(ActionEvent e)
 161  *             {
 162  *                 System.out.println("Hello There");
 163  *             }
 164  *         }
 165  *
 166  *         MyApp()
 167  *         {
 168  *             aButton.addActionListener(new MyActionListener());
 169  *         }
 170  *    }
 171  * &lt;/pre&gt;
 172  * &lt;p&gt;
 173  * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
 174  * by AWT and Swing, including information on how to write the most
 175  * efficient painting code, see
 176  * &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
 177  * &lt;p&gt;
 178  * For details on the focus subsystem, see
 179  * &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html"&gt;
 180  * How to Use the Focus Subsystem&lt;/a&gt;,
 181  * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
 182  * &lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
 183  * for more information.
 184  *
 185  * @author      Arthur van Hoff
 186  * @author      Sami Shaio
 187  */
 188 public abstract class Component implements ImageObserver, MenuContainer,
 189                                            Serializable
 190 {
 191 
 192     private static final PlatformLogger log = PlatformLogger.getLogger("java.awt.Component");
 193     private static final PlatformLogger eventLog = PlatformLogger.getLogger("java.awt.event.Component");
 194     private static final PlatformLogger focusLog = PlatformLogger.getLogger("java.awt.focus.Component");
 195     private static final PlatformLogger mixingLog = PlatformLogger.getLogger("java.awt.mixing.Component");
 196 
 197     /**
 198      * The peer of the component. The peer implements the component's
 199      * behavior. The peer is set when the &lt;code&gt;Component&lt;/code&gt; is
 200      * added to a container that also is a peer.
 201      * @see #addNotify
 202      * @see #removeNotify
 203      */
 204     transient ComponentPeer peer;
 205 
 206     /**
 207      * The parent of the object. It may be &lt;code&gt;null&lt;/code&gt;
 208      * for top-level components.
 209      * @see #getParent
 210      */
 211     transient Container parent;
 212 
 213     /**
 214      * The &lt;code&gt;AppContext&lt;/code&gt; of the component. Applets/Plugin may
 215      * change the AppContext.
 216      */
 217     transient AppContext appContext;
 218 
 219     /**
 220      * The x position of the component in the parent's coordinate system.
 221      *
 222      * @serial
 223      * @see #getLocation
 224      */
 225     int x;
 226 
 227     /**
 228      * The y position of the component in the parent's coordinate system.
 229      *
 230      * @serial
 231      * @see #getLocation
 232      */
 233     int y;
 234 
 235     /**
 236      * The width of the component.
 237      *
 238      * @serial
 239      * @see #getSize
 240      */
 241     int width;
 242 
 243     /**
 244      * The height of the component.
 245      *
 246      * @serial
 247      * @see #getSize
 248      */
 249     int height;
 250 
 251     /**
 252      * The foreground color for this component.
 253      * &lt;code&gt;foreground&lt;/code&gt; can be &lt;code&gt;null&lt;/code&gt;.
 254      *
 255      * @serial
 256      * @see #getForeground
 257      * @see #setForeground
 258      */
 259     Color       foreground;
 260 
 261     /**
 262      * The background color for this component.
 263      * &lt;code&gt;background&lt;/code&gt; can be &lt;code&gt;null&lt;/code&gt;.
 264      *
 265      * @serial
 266      * @see #getBackground
 267      * @see #setBackground
 268      */
 269     Color       background;
 270 
 271     /**
 272      * The font used by this component.
 273      * The &lt;code&gt;font&lt;/code&gt; can be &lt;code&gt;null&lt;/code&gt;.
 274      *
 275      * @serial
 276      * @see #getFont
 277      * @see #setFont
 278      */
 279     volatile Font font;
 280 
 281     /**
 282      * The font which the peer is currently using.
 283      * (&lt;code&gt;null&lt;/code&gt; if no peer exists.)
 284      */
 285     Font        peerFont;
 286 
 287     /**
 288      * The cursor displayed when pointer is over this component.
 289      * This value can be &lt;code&gt;null&lt;/code&gt;.
 290      *
 291      * @serial
 292      * @see #getCursor
 293      * @see #setCursor
 294      */
 295     Cursor      cursor;
 296 
 297     /**
 298      * The locale for the component.
 299      *
 300      * @serial
 301      * @see #getLocale
 302      * @see #setLocale
 303      */
 304     Locale      locale;
 305 
 306     /**
 307      * A reference to a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object
 308      * used to describe the characteristics of a graphics
 309      * destination.
 310      * This value can be &lt;code&gt;null&lt;/code&gt;.
 311      *
 312      * @since 1.3
 313      * @serial
 314      * @see GraphicsConfiguration
 315      * @see #getGraphicsConfiguration
 316      */
 317     private transient GraphicsConfiguration graphicsConfig = null;
 318 
 319     /**
 320      * A reference to a &lt;code&gt;BufferStrategy&lt;/code&gt; object
 321      * used to manipulate the buffers on this component.
 322      *
 323      * @since 1.4
 324      * @see java.awt.image.BufferStrategy
 325      * @see #getBufferStrategy()
 326      */
 327     transient BufferStrategy bufferStrategy = null;
 328 
 329     /**
 330      * True when the object should ignore all repaint events.
 331      *
 332      * @since 1.4
 333      * @serial
 334      * @see #setIgnoreRepaint
 335      * @see #getIgnoreRepaint
 336      */
 337     boolean ignoreRepaint = false;
 338 
 339     /**
 340      * True when the object is visible. An object that is not
 341      * visible is not drawn on the screen.
 342      *
 343      * @serial
 344      * @see #isVisible
 345      * @see #setVisible
 346      */
 347     boolean visible = true;
 348 
 349     /**
 350      * True when the object is enabled. An object that is not
 351      * enabled does not interact with the user.
 352      *
 353      * @serial
 354      * @see #isEnabled
 355      * @see #setEnabled
 356      */
 357     boolean enabled = true;
 358 
 359     /**
 360      * True when the object is valid. An invalid object needs to
 361      * be layed out. This flag is set to false when the object
 362      * size is changed.
 363      *
 364      * @serial
 365      * @see #isValid
 366      * @see #validate
 367      * @see #invalidate
 368      */
 369     private volatile boolean valid = false;
 370 
 371     /**
 372      * The &lt;code&gt;DropTarget&lt;/code&gt; associated with this component.
 373      *
 374      * @since 1.2
 375      * @serial
 376      * @see #setDropTarget
 377      * @see #getDropTarget
 378      */
 379     DropTarget dropTarget;
 380 
 381     /**
 382      * @serial
 383      * @see #add
 384      */
 385     Vector&lt;PopupMenu&gt; popups;
 386 
 387     /**
 388      * A component's name.
 389      * This field can be &lt;code&gt;null&lt;/code&gt;.
 390      *
 391      * @serial
 392      * @see #getName
 393      * @see #setName(String)
 394      */
 395     private String name;
 396 
 397     /**
 398      * A bool to determine whether the name has
 399      * been set explicitly. &lt;code&gt;nameExplicitlySet&lt;/code&gt; will
 400      * be false if the name has not been set and
 401      * true if it has.
 402      *
 403      * @serial
 404      * @see #getName
 405      * @see #setName(String)
 406      */
 407     private boolean nameExplicitlySet = false;
 408 
 409     /**
 410      * Indicates whether this Component can be focused.
 411      *
 412      * @serial
 413      * @see #setFocusable
 414      * @see #isFocusable
 415      * @since 1.4
 416      */
 417     private boolean focusable = true;
 418 
 419     private static final int FOCUS_TRAVERSABLE_UNKNOWN = 0;
 420     private static final int FOCUS_TRAVERSABLE_DEFAULT = 1;
 421     private static final int FOCUS_TRAVERSABLE_SET = 2;
 422 
 423     /**
 424      * Tracks whether this Component is relying on default focus travesability.
 425      *
 426      * @serial
 427      * @since 1.4
 428      */
 429     private int isFocusTraversableOverridden = FOCUS_TRAVERSABLE_UNKNOWN;
 430 
 431     /**
 432      * The focus traversal keys. These keys will generate focus traversal
 433      * behavior for Components for which focus traversal keys are enabled. If a
 434      * value of null is specified for a traversal key, this Component inherits
 435      * that traversal key from its parent. If all ancestors of this Component
 436      * have null specified for that traversal key, then the current
 437      * KeyboardFocusManager's default traversal key is used.
 438      *
 439      * @serial
 440      * @see #setFocusTraversalKeys
 441      * @see #getFocusTraversalKeys
 442      * @since 1.4
 443      */
 444     Set&lt;AWTKeyStroke&gt;[] focusTraversalKeys;
 445 
 446     private static final String[] focusTraversalKeyPropertyNames = {
 447         "forwardFocusTraversalKeys",
 448         "backwardFocusTraversalKeys",
 449         "upCycleFocusTraversalKeys",
 450         "downCycleFocusTraversalKeys"
 451     };
 452 
 453     /**
 454      * Indicates whether focus traversal keys are enabled for this Component.
 455      * Components for which focus traversal keys are disabled receive key
 456      * events for focus traversal keys. Components for which focus traversal
 457      * keys are enabled do not see these events; instead, the events are
 458      * automatically converted to traversal operations.
 459      *
 460      * @serial
 461      * @see #setFocusTraversalKeysEnabled
 462      * @see #getFocusTraversalKeysEnabled
 463      * @since 1.4
 464      */
 465     private boolean focusTraversalKeysEnabled = true;
 466 
 467     /**
 468      * The locking object for AWT component-tree and layout operations.
 469      *
 470      * @see #getTreeLock
 471      */
 472     static final Object LOCK = new AWTTreeLock();
 473     static class AWTTreeLock {}
 474 
 475     /*
 476      * The component's AccessControlContext.
 477      */
 478     private transient volatile AccessControlContext acc =
 479         AccessController.getContext();
 480 
 481     /**
 482      * Minimum size.
 483      * (This field perhaps should have been transient).
 484      *
 485      * @serial
 486      */
 487     Dimension minSize;
 488 
 489     /**
 490      * Whether or not setMinimumSize has been invoked with a non-null value.
 491      */
 492     boolean minSizeSet;
 493 
 494     /**
 495      * Preferred size.
 496      * (This field perhaps should have been transient).
 497      *
 498      * @serial
 499      */
 500     Dimension prefSize;
 501 
 502     /**
 503      * Whether or not setPreferredSize has been invoked with a non-null value.
 504      */
 505     boolean prefSizeSet;
 506 
 507     /**
 508      * Maximum size
 509      *
 510      * @serial
 511      */
 512     Dimension maxSize;
 513 
 514     /**
 515      * Whether or not setMaximumSize has been invoked with a non-null value.
 516      */
 517     boolean maxSizeSet;
 518 
 519     /**
 520      * The orientation for this component.
 521      * @see #getComponentOrientation
 522      * @see #setComponentOrientation
 523      */
 524     transient ComponentOrientation componentOrientation
 525     = ComponentOrientation.UNKNOWN;
 526 
 527     /**
 528      * &lt;code&gt;newEventsOnly&lt;/code&gt; will be true if the event is
 529      * one of the event types enabled for the component.
 530      * It will then allow for normal processing to
 531      * continue.  If it is false the event is passed
 532      * to the component's parent and up the ancestor
 533      * tree until the event has been consumed.
 534      *
 535      * @serial
 536      * @see #dispatchEvent
 537      */
 538     boolean newEventsOnly = false;
 539     transient ComponentListener componentListener;
 540     transient FocusListener focusListener;
 541     transient HierarchyListener hierarchyListener;
 542     transient HierarchyBoundsListener hierarchyBoundsListener;
 543     transient KeyListener keyListener;
 544     transient MouseListener mouseListener;
 545     transient MouseMotionListener mouseMotionListener;
 546     transient MouseWheelListener mouseWheelListener;
 547     transient InputMethodListener inputMethodListener;
 548 
 549     transient RuntimeException windowClosingException = null;
 550 
 551     /** Internal, constants for serialization */
 552     final static String actionListenerK = "actionL";
 553     final static String adjustmentListenerK = "adjustmentL";
 554     final static String componentListenerK = "componentL";
 555     final static String containerListenerK = "containerL";
 556     final static String focusListenerK = "focusL";
 557     final static String itemListenerK = "itemL";
 558     final static String keyListenerK = "keyL";
 559     final static String mouseListenerK = "mouseL";
 560     final static String mouseMotionListenerK = "mouseMotionL";
 561     final static String mouseWheelListenerK = "mouseWheelL";
 562     final static String textListenerK = "textL";
 563     final static String ownedWindowK = "ownedL";
 564     final static String windowListenerK = "windowL";
 565     final static String inputMethodListenerK = "inputMethodL";
 566     final static String hierarchyListenerK = "hierarchyL";
 567     final static String hierarchyBoundsListenerK = "hierarchyBoundsL";
 568     final static String windowStateListenerK = "windowStateL";
 569     final static String windowFocusListenerK = "windowFocusL";
 570 
 571     /**
 572      * The &lt;code&gt;eventMask&lt;/code&gt; is ONLY set by subclasses via
 573      * &lt;code&gt;enableEvents&lt;/code&gt;.
 574      * The mask should NOT be set when listeners are registered
 575      * so that we can distinguish the difference between when
 576      * listeners request events and subclasses request them.
 577      * One bit is used to indicate whether input methods are
 578      * enabled; this bit is set by &lt;code&gt;enableInputMethods&lt;/code&gt; and is
 579      * on by default.
 580      *
 581      * @serial
 582      * @see #enableInputMethods
 583      * @see AWTEvent
 584      */
 585     long eventMask = AWTEvent.INPUT_METHODS_ENABLED_MASK;
 586 
 587     /**
 588      * Static properties for incremental drawing.
 589      * @see #imageUpdate
 590      */
 591     static boolean isInc;
 592     static int incRate;
 593     static {
 594         /* ensure that the necessary native libraries are loaded */
 595         Toolkit.loadLibraries();
 596         /* initialize JNI field and method ids */
 597         if (!GraphicsEnvironment.isHeadless()) {
 598             initIDs();
 599         }
 600 
 601         String s = java.security.AccessController.doPrivileged(
 602                                                                new GetPropertyAction("awt.image.incrementaldraw"));
 603         isInc = (s == null || s.equals("true"));
 604 
 605         s = java.security.AccessController.doPrivileged(
 606                                                         new GetPropertyAction("awt.image.redrawrate"));
 607         incRate = (s != null) ? Integer.parseInt(s) : 100;
 608     }
 609 
 610     /**
 611      * Ease-of-use constant for &lt;code&gt;getAlignmentY()&lt;/code&gt;.
 612      * Specifies an alignment to the top of the component.
 613      * @see     #getAlignmentY
 614      */
 615     public static final float TOP_ALIGNMENT = 0.0f;
 616 
 617     /**
 618      * Ease-of-use constant for &lt;code&gt;getAlignmentY&lt;/code&gt; and
 619      * &lt;code&gt;getAlignmentX&lt;/code&gt;. Specifies an alignment to
 620      * the center of the component
 621      * @see     #getAlignmentX
 622      * @see     #getAlignmentY
 623      */
 624     public static final float CENTER_ALIGNMENT = 0.5f;
 625 
 626     /**
 627      * Ease-of-use constant for &lt;code&gt;getAlignmentY&lt;/code&gt;.
 628      * Specifies an alignment to the bottom of the component.
 629      * @see     #getAlignmentY
 630      */
 631     public static final float BOTTOM_ALIGNMENT = 1.0f;
 632 
 633     /**
 634      * Ease-of-use constant for &lt;code&gt;getAlignmentX&lt;/code&gt;.
 635      * Specifies an alignment to the left side of the component.
 636      * @see     #getAlignmentX
 637      */
 638     public static final float LEFT_ALIGNMENT = 0.0f;
 639 
 640     /**
 641      * Ease-of-use constant for &lt;code&gt;getAlignmentX&lt;/code&gt;.
 642      * Specifies an alignment to the right side of the component.
 643      * @see     #getAlignmentX
 644      */
 645     public static final float RIGHT_ALIGNMENT = 1.0f;
 646 
 647     /*
 648      * JDK 1.1 serialVersionUID
 649      */
 650     private static final long serialVersionUID = -7644114512714619750L;
 651 
 652     /**
 653      * If any &lt;code&gt;PropertyChangeListeners&lt;/code&gt; have been registered,
 654      * the &lt;code&gt;changeSupport&lt;/code&gt; field describes them.
 655      *
 656      * @serial
 657      * @since 1.2
 658      * @see #addPropertyChangeListener
 659      * @see #removePropertyChangeListener
 660      * @see #firePropertyChange
 661      */
 662     private PropertyChangeSupport changeSupport;
 663 
 664     /*
 665      * In some cases using "this" as an object to synchronize by
 666      * can lead to a deadlock if client code also uses synchronization
 667      * by a component object. For every such situation revealed we should
 668      * consider possibility of replacing "this" with the package private
 669      * objectLock object introduced below. So far there're 3 issues known:
 670      * - CR 6708322 (the getName/setName methods);
 671      * - CR 6608764 (the PropertyChangeListener machinery);
 672      * - CR 7108598 (the Container.paint/KeyboardFocusManager.clearMostRecentFocusOwner methods).
 673      *
 674      * Note: this field is considered final, though readObject() prohibits
 675      * initializing final fields.
 676      */
 677     private transient Object objectLock = new Object();
 678     Object getObjectLock() {
 679         return objectLock;
 680     }
 681 
 682     /*
 683      * Returns the acc this component was constructed with.
 684      */
 685     final AccessControlContext getAccessControlContext() {
 686         if (acc == null) {
 687             throw new SecurityException("Component is missing AccessControlContext");
 688         }
 689         return acc;
 690     }
 691 
 692     boolean isPacked = false;
 693 
 694     /**
 695      * Pseudoparameter for direct Geometry API (setLocation, setBounds setSize
 696      * to signal setBounds what's changing. Should be used under TreeLock.
 697      * This is only needed due to the inability to change the cross-calling
 698      * order of public and deprecated methods.
 699      */
 700     private int boundsOp = ComponentPeer.DEFAULT_OPERATION;
 701 
 702     /**
 703      * Enumeration of the common ways the baseline of a component can
 704      * change as the size changes.  The baseline resize behavior is
 705      * primarily for layout managers that need to know how the
 706      * position of the baseline changes as the component size changes.
 707      * In general the baseline resize behavior will be valid for sizes
 708      * greater than or equal to the minimum size (the actual minimum
 709      * size; not a developer specified minimum size).  For sizes
 710      * smaller than the minimum size the baseline may change in a way
 711      * other than the baseline resize behavior indicates.  Similarly,
 712      * as the size approaches &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; and/or
 713      * &lt;code&gt;Short.MAX_VALUE&lt;/code&gt; the baseline may change in a way
 714      * other than the baseline resize behavior indicates.
 715      *
 716      * @see #getBaselineResizeBehavior
 717      * @see #getBaseline(int,int)
 718      * @since 1.6
 719      */
 720     public enum BaselineResizeBehavior {
 721         /**
 722          * Indicates the baseline remains fixed relative to the
 723          * y-origin.  That is, &lt;code&gt;getBaseline&lt;/code&gt; returns
 724          * the same value regardless of the height or width.  For example, a
 725          * &lt;code&gt;JLabel&lt;/code&gt; containing non-empty text with a
 726          * vertical alignment of &lt;code&gt;TOP&lt;/code&gt; should have a
 727          * baseline type of &lt;code&gt;CONSTANT_ASCENT&lt;/code&gt;.
 728          */
 729         CONSTANT_ASCENT,
 730 
 731         /**
 732          * Indicates the baseline remains fixed relative to the height
 733          * and does not change as the width is varied.  That is, for
 734          * any height H the difference between H and
 735          * &lt;code&gt;getBaseline(w, H)&lt;/code&gt; is the same.  For example, a
 736          * &lt;code&gt;JLabel&lt;/code&gt; containing non-empty text with a
 737          * vertical alignment of &lt;code&gt;BOTTOM&lt;/code&gt; should have a
 738          * baseline type of &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt;.
 739          */
 740         CONSTANT_DESCENT,
 741 
 742         /**
 743          * Indicates the baseline remains a fixed distance from
 744          * the center of the component.  That is, for any height H the
 745          * difference between &lt;code&gt;getBaseline(w, H)&lt;/code&gt; and
 746          * &lt;code&gt;H / 2&lt;/code&gt; is the same (plus or minus one depending upon
 747          * rounding error).
 748          * &lt;p&gt;
 749          * Because of possible rounding errors it is recommended
 750          * you ask for the baseline with two consecutive heights and use
 751          * the return value to determine if you need to pad calculations
 752          * by 1.  The following shows how to calculate the baseline for
 753          * any height:
 754          * &lt;pre&gt;
 755          *   Dimension preferredSize = component.getPreferredSize();
 756          *   int baseline = getBaseline(preferredSize.width,
 757          *                              preferredSize.height);
 758          *   int nextBaseline = getBaseline(preferredSize.width,
 759          *                                  preferredSize.height + 1);
 760          *   // Amount to add to height when calculating where baseline
 761          *   // lands for a particular height:
 762          *   int padding = 0;
 763          *   // Where the baseline is relative to the mid point
 764          *   int baselineOffset = baseline - height / 2;
 765          *   if (preferredSize.height % 2 == 0 &amp;amp;&amp;amp;
 766          *       baseline != nextBaseline) {
 767          *       padding = 1;
 768          *   }
 769          *   else if (preferredSize.height % 2 == 1 &amp;amp;&amp;amp;
 770          *            baseline == nextBaseline) {
 771          *       baselineOffset--;
 772          *       padding = 1;
 773          *   }
 774          *   // The following calculates where the baseline lands for
 775          *   // the height z:
 776          *   int calculatedBaseline = (z + padding) / 2 + baselineOffset;
 777          * &lt;/pre&gt;
 778          */
 779         CENTER_OFFSET,
 780 
 781         /**
 782          * Indicates the baseline resize behavior can not be expressed using
 783          * any of the other constants.  This may also indicate the baseline
 784          * varies with the width of the component.  This is also returned
 785          * by components that do not have a baseline.
 786          */
 787         OTHER
 788     }
 789 
 790     /*
 791      * The shape set with the applyCompoundShape() method. It uncludes the result
 792      * of the HW/LW mixing related shape computation. It may also include
 793      * the user-specified shape of the component.
 794      * The 'null' value means the component has normal shape (or has no shape at all)
 795      * and applyCompoundShape() will skip the following shape identical to normal.
 796      */
 797     private transient Region compoundShape = null;
 798 
 799     /*
 800      * Represents the shape of this lightweight component to be cut out from
 801      * heavyweight components should they intersect. Possible values:
 802      *    1. null - consider the shape rectangular
 803      *    2. EMPTY_REGION - nothing gets cut out (children still get cut out)
 804      *    3. non-empty - this shape gets cut out.
 805      */
 806     private transient Region mixingCutoutRegion = null;
 807 
 808     /*
 809      * Indicates whether addNotify() is complete
 810      * (i.e. the peer is created).
 811      */
 812     private transient boolean isAddNotifyComplete = false;
 813 
 814     /**
 815      * Should only be used in subclass getBounds to check that part of bounds
 816      * is actualy changing
 817      */
 818     int getBoundsOp() {
 819         assert Thread.holdsLock(getTreeLock());
 820         return boundsOp;
 821     }
 822 
 823     void setBoundsOp(int op) {
 824         assert Thread.holdsLock(getTreeLock());
 825         if (op == ComponentPeer.RESET_OPERATION) {
 826             boundsOp = ComponentPeer.DEFAULT_OPERATION;
 827         } else
 828             if (boundsOp == ComponentPeer.DEFAULT_OPERATION) {
 829                 boundsOp = op;
 830             }
 831     }
 832 
 833     // Whether this Component has had the background erase flag
 834     // specified via SunToolkit.disableBackgroundErase(). This is
 835     // needed in order to make this function work on X11 platforms,
 836     // where currently there is no chance to interpose on the creation
 837     // of the peer and therefore the call to XSetBackground.
 838     transient boolean backgroundEraseDisabled;
 839 
 840     static {
 841         AWTAccessor.setComponentAccessor(new AWTAccessor.ComponentAccessor() {
 842             public void setBackgroundEraseDisabled(Component comp, boolean disabled) {
 843                 comp.backgroundEraseDisabled = disabled;
 844             }
 845             public boolean getBackgroundEraseDisabled(Component comp) {
 846                 return comp.backgroundEraseDisabled;
 847             }
 848             public Rectangle getBounds(Component comp) {
 849                 return new Rectangle(comp.x, comp.y, comp.width, comp.height);
 850             }
 851             public void setMixingCutoutShape(Component comp, Shape shape) {
 852                 Region region = shape == null ?  null :
 853                     Region.getInstance(shape, null);
 854 
 855                 synchronized (comp.getTreeLock()) {
 856                     boolean needShowing = false;
 857                     boolean needHiding = false;
 858 
 859                     if (!comp.isNonOpaqueForMixing()) {
 860                         needHiding = true;
 861                     }
 862 
 863                     comp.mixingCutoutRegion = region;
 864 
 865                     if (!comp.isNonOpaqueForMixing()) {
 866                         needShowing = true;
 867                     }
 868 
 869                     if (comp.isMixingNeeded()) {
 870                         if (needHiding) {
 871                             comp.mixOnHiding(comp.isLightweight());
 872                         }
 873                         if (needShowing) {
 874                             comp.mixOnShowing();
 875                         }
 876                     }
 877                 }
 878             }
 879 
 880             public void setGraphicsConfiguration(Component comp,
 881                     GraphicsConfiguration gc)
 882             {
 883                 comp.setGraphicsConfiguration(gc);
 884             }
 885             public boolean requestFocus(Component comp, CausedFocusEvent.Cause cause) {
 886                 return comp.requestFocus(cause);
 887             }
 888             public boolean canBeFocusOwner(Component comp) {
 889                 return comp.canBeFocusOwner();
 890             }
 891 
 892             public boolean isVisible(Component comp) {
 893                 return comp.isVisible_NoClientCode();
 894             }
 895             public void setRequestFocusController
 896                 (RequestFocusController requestController)
 897             {
 898                  Component.setRequestFocusController(requestController);
 899             }
 900             public AppContext getAppContext(Component comp) {
 901                  return comp.appContext;
 902             }
 903             public void setAppContext(Component comp, AppContext appContext) {
 904                  comp.appContext = appContext;
 905             }
 906             public Container getParent(Component comp) {
 907                 return comp.getParent_NoClientCode();
 908             }
 909             public void setParent(Component comp, Container parent) {
 910                 comp.parent = parent;
 911             }
 912             public void setSize(Component comp, int width, int height) {
 913                 comp.width = width;
 914                 comp.height = height;
 915             }
 916             public Point getLocation(Component comp) {
 917                 return comp.location_NoClientCode();
 918             }
 919             public void setLocation(Component comp, int x, int y) {
 920                 comp.x = x;
 921                 comp.y = y;
 922             }
 923             public boolean isEnabled(Component comp) {
 924                 return comp.isEnabledImpl();
 925             }
 926             public boolean isDisplayable(Component comp) {
 927                 return comp.peer != null;
 928             }
 929             public Cursor getCursor(Component comp) {
 930                 return comp.getCursor_NoClientCode();
 931             }
 932             public ComponentPeer getPeer(Component comp) {
 933                 return comp.peer;
 934             }
 935             public void setPeer(Component comp, ComponentPeer peer) {
 936                 comp.peer = peer;
 937             }
 938             public boolean isLightweight(Component comp) {
 939                 return (comp.peer instanceof LightweightPeer);
 940             }
 941             public boolean getIgnoreRepaint(Component comp) {
 942                 return comp.ignoreRepaint;
 943             }
 944             public int getWidth(Component comp) {
 945                 return comp.width;
 946             }
 947             public int getHeight(Component comp) {
 948                 return comp.height;
 949             }
 950             public int getX(Component comp) {
 951                 return comp.x;
 952             }
 953             public int getY(Component comp) {
 954                 return comp.y;
 955             }
 956             public Color getForeground(Component comp) {
 957                 return comp.foreground;
 958             }
 959             public Color getBackground(Component comp) {
 960                 return comp.background;
 961             }
 962             public void setBackground(Component comp, Color background) {
 963                 comp.background = background;
 964             }
 965             public Font getFont(Component comp) {
 966                 return comp.getFont_NoClientCode();
 967             }
 968             public void processEvent(Component comp, AWTEvent e) {
 969                 comp.processEvent(e);
 970             }
 971 
 972             public AccessControlContext getAccessControlContext(Component comp) {
 973                 return comp.getAccessControlContext();
 974             }
 975 
 976             public void revalidateSynchronously(Component comp) {
 977                 comp.revalidateSynchronously();
 978             }
 979         });
 980     }
 981 
 982     /**
 983      * Constructs a new component. Class &lt;code&gt;Component&lt;/code&gt; can be
 984      * extended directly to create a lightweight component that does not
 985      * utilize an opaque native window. A lightweight component must be
 986      * hosted by a native container somewhere higher up in the component
 987      * tree (for example, by a &lt;code&gt;Frame&lt;/code&gt; object).
 988      */
 989     protected Component() {
 990         appContext = AppContext.getAppContext();
 991     }
 992 
 993     @SuppressWarnings({"rawtypes", "unchecked"})
 994     void initializeFocusTraversalKeys() {
 995         focusTraversalKeys = new Set[3];
 996     }
 997 
 998     /**
 999      * Constructs a name for this component.  Called by &lt;code&gt;getName&lt;/code&gt;
1000      * when the name is &lt;code&gt;null&lt;/code&gt;.
1001      */
1002     String constructComponentName() {
1003         return null; // For strict compliance with prior platform versions, a Component
1004                      // that doesn't set its name should return null from
1005                      // getName()
1006     }
1007 
1008     /**
1009      * Gets the name of the component.
1010      * @return this component's name
1011      * @see    #setName
1012      * @since JDK1.1
1013      */
1014     public String getName() {
1015         if (name == null &amp;&amp; !nameExplicitlySet) {
1016             synchronized(getObjectLock()) {
1017                 if (name == null &amp;&amp; !nameExplicitlySet)
1018                     name = constructComponentName();
1019             }
1020         }
1021         return name;
1022     }
1023 
1024     /**
1025      * Sets the name of the component to the specified string.
1026      * @param name  the string that is to be this
1027      *           component's name
1028      * @see #getName
1029      * @since JDK1.1
1030      */
1031     public void setName(String name) {
1032         String oldName;
1033         synchronized(getObjectLock()) {
1034             oldName = this.name;
1035             this.name = name;
1036             nameExplicitlySet = true;
1037         }
1038         firePropertyChange("name", oldName, name);
1039     }
1040 
1041     /**
1042      * Gets the parent of this component.
1043      * @return the parent container of this component
1044      * @since JDK1.0
1045      */
1046     public Container getParent() {
1047         return getParent_NoClientCode();
1048     }
1049 
1050     // NOTE: This method may be called by privileged threads.
1051     //       This functionality is implemented in a package-private method
1052     //       to insure that it cannot be overridden by client subclasses.
1053     //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
1054     final Container getParent_NoClientCode() {
1055         return parent;
1056     }
1057 
1058     // This method is overridden in the Window class to return null,
1059     //    because the parent field of the Window object contains
1060     //    the owner of the window, not its parent.
1061     Container getContainer() {
1062         return getParent_NoClientCode();
1063     }
1064 
1065     /**
1066      * @deprecated As of JDK version 1.1,
1067      * programs should not directly manipulate peers;
1068      * replaced by &lt;code&gt;boolean isDisplayable()&lt;/code&gt;.
1069      */
1070     @Deprecated
1071     public ComponentPeer getPeer() {
1072         return peer;
1073     }
1074 
1075     /**
1076      * Associate a &lt;code&gt;DropTarget&lt;/code&gt; with this component.
1077      * The &lt;code&gt;Component&lt;/code&gt; will receive drops only if it
1078      * is enabled.
1079      *
1080      * @see #isEnabled
1081      * @param dt The DropTarget
1082      */
1083 
1084     public synchronized void setDropTarget(DropTarget dt) {
1085         if (dt == dropTarget || (dropTarget != null &amp;&amp; dropTarget.equals(dt)))
1086             return;
1087 
1088         DropTarget old;
1089 
1090         if ((old = dropTarget) != null) {
1091             if (peer != null) dropTarget.removeNotify(peer);
1092 
1093             DropTarget t = dropTarget;
1094 
1095             dropTarget = null;
1096 
1097             try {
1098                 t.setComponent(null);
1099             } catch (IllegalArgumentException iae) {
1100                 // ignore it.
1101             }
1102         }
1103 
1104         // if we have a new one, and we have a peer, add it!
1105 
1106         if ((dropTarget = dt) != null) {
1107             try {
1108                 dropTarget.setComponent(this);
1109                 if (peer != null) dropTarget.addNotify(peer);
1110             } catch (IllegalArgumentException iae) {
1111                 if (old != null) {
1112                     try {
1113                         old.setComponent(this);
1114                         if (peer != null) dropTarget.addNotify(peer);
1115                     } catch (IllegalArgumentException iae1) {
1116                         // ignore it!
1117                     }
1118                 }
1119             }
1120         }
1121     }
1122 
1123     /**
1124      * Gets the &lt;code&gt;DropTarget&lt;/code&gt; associated with this
1125      * &lt;code&gt;Component&lt;/code&gt;.
1126      */
1127 
1128     public synchronized DropTarget getDropTarget() { return dropTarget; }
1129 
1130     /**
1131      * Gets the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; associated with this
1132      * &lt;code&gt;Component&lt;/code&gt;.
1133      * If the &lt;code&gt;Component&lt;/code&gt; has not been assigned a specific
1134      * &lt;code&gt;GraphicsConfiguration&lt;/code&gt;,
1135      * the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; of the
1136      * &lt;code&gt;Component&lt;/code&gt; object's top-level container is
1137      * returned.
1138      * If the &lt;code&gt;Component&lt;/code&gt; has been created, but not yet added
1139      * to a &lt;code&gt;Container&lt;/code&gt;, this method returns &lt;code&gt;null&lt;/code&gt;.
1140      *
1141      * @return the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; used by this
1142      *          &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;
1143      * @since 1.3
1144      */
1145     public GraphicsConfiguration getGraphicsConfiguration() {
1146         synchronized(getTreeLock()) {
1147             return getGraphicsConfiguration_NoClientCode();
1148         }
1149     }
1150 
1151     final GraphicsConfiguration getGraphicsConfiguration_NoClientCode() {
1152         return graphicsConfig;
1153     }
1154 
1155     void setGraphicsConfiguration(GraphicsConfiguration gc) {
1156         synchronized(getTreeLock()) {
1157             if (updateGraphicsData(gc)) {
1158                 removeNotify();
1159                 addNotify();
1160             }
1161         }
1162     }
1163 
1164     boolean updateGraphicsData(GraphicsConfiguration gc) {
1165         checkTreeLock();
1166 
1167         if (graphicsConfig == gc) {
1168             return false;
1169         }
1170 
1171         graphicsConfig = gc;
1172 
1173         ComponentPeer peer = getPeer();
1174         if (peer != null) {
1175             return peer.updateGraphicsData(gc);
1176         }
1177         return false;
1178     }
1179 
1180     /**
1181      * Checks that this component's &lt;code&gt;GraphicsDevice&lt;/code&gt;
1182      * &lt;code&gt;idString&lt;/code&gt; matches the string argument.
1183      */
1184     void checkGD(String stringID) {
1185         if (graphicsConfig != null) {
1186             if (!graphicsConfig.getDevice().getIDstring().equals(stringID)) {
1187                 throw new IllegalArgumentException(
1188                                                    "adding a container to a container on a different GraphicsDevice");
1189             }
1190         }
1191     }
1192 
1193     /**
1194      * Gets this component's locking object (the object that owns the thread
1195      * synchronization monitor) for AWT component-tree and layout
1196      * operations.
1197      * @return this component's locking object
1198      */
1199     public final Object getTreeLock() {
1200         return LOCK;
1201     }
1202 
1203     final void checkTreeLock() {
1204         if (!Thread.holdsLock(getTreeLock())) {
1205             throw new IllegalStateException("This function should be called while holding treeLock");
1206         }
1207     }
1208 
1209     /**
1210      * Gets the toolkit of this component. Note that
1211      * the frame that contains a component controls which
1212      * toolkit is used by that component. Therefore if the component
1213      * is moved from one frame to another, the toolkit it uses may change.
1214      * @return  the toolkit of this component
1215      * @since JDK1.0
1216      */
1217     public Toolkit getToolkit() {
1218         return getToolkitImpl();
1219     }
1220 
1221     /*
1222      * This is called by the native code, so client code can't
1223      * be called on the toolkit thread.
1224      */
1225     final Toolkit getToolkitImpl() {
1226         Container parent = this.parent;
1227         if (parent != null) {
1228             return parent.getToolkitImpl();
1229         }
1230         return Toolkit.getDefaultToolkit();
1231     }
1232 
1233     /**
1234      * Determines whether this component is valid. A component is valid
1235      * when it is correctly sized and positioned within its parent
1236      * container and all its children are also valid.
1237      * In order to account for peers' size requirements, components are invalidated
1238      * before they are first shown on the screen. By the time the parent container
1239      * is fully realized, all its components will be valid.
1240      * @return &lt;code&gt;true&lt;/code&gt; if the component is valid, &lt;code&gt;false&lt;/code&gt;
1241      * otherwise
1242      * @see #validate
1243      * @see #invalidate
1244      * @since JDK1.0
1245      */
1246     public boolean isValid() {
1247         return (peer != null) &amp;&amp; valid;
1248     }
1249 
1250     /**
1251      * Determines whether this component is displayable. A component is
1252      * displayable when it is connected to a native screen resource.
1253      * &lt;p&gt;
1254      * A component is made displayable either when it is added to
1255      * a displayable containment hierarchy or when its containment
1256      * hierarchy is made displayable.
1257      * A containment hierarchy is made displayable when its ancestor
1258      * window is either packed or made visible.
1259      * &lt;p&gt;
1260      * A component is made undisplayable either when it is removed from
1261      * a displayable containment hierarchy or when its containment hierarchy
1262      * is made undisplayable.  A containment hierarchy is made
1263      * undisplayable when its ancestor window is disposed.
1264      *
1265      * @return &lt;code&gt;true&lt;/code&gt; if the component is displayable,
1266      * &lt;code&gt;false&lt;/code&gt; otherwise
1267      * @see Container#add(Component)
1268      * @see Window#pack
1269      * @see Window#show
1270      * @see Container#remove(Component)
1271      * @see Window#dispose
1272      * @since 1.2
1273      */
1274     public boolean isDisplayable() {
1275         return getPeer() != null;
1276     }
1277 
1278     /**
1279      * Determines whether this component should be visible when its
1280      * parent is visible. Components are
1281      * initially visible, with the exception of top level components such
1282      * as &lt;code&gt;Frame&lt;/code&gt; objects.
1283      * @return &lt;code&gt;true&lt;/code&gt; if the component is visible,
1284      * &lt;code&gt;false&lt;/code&gt; otherwise
1285      * @see #setVisible
1286      * @since JDK1.0
1287      */
1288     @Transient
1289     public boolean isVisible() {
1290         return isVisible_NoClientCode();
1291     }
1292     final boolean isVisible_NoClientCode() {
1293         return visible;
1294     }
1295 
1296     /**
1297      * Determines whether this component will be displayed on the screen.
1298      * @return &lt;code&gt;true&lt;/code&gt; if the component and all of its ancestors
1299      *          until a toplevel window or null parent are visible,
1300      *          &lt;code&gt;false&lt;/code&gt; otherwise
1301      */
1302     boolean isRecursivelyVisible() {
1303         return visible &amp;&amp; (parent == null || parent.isRecursivelyVisible());
1304     }
1305 
1306     /**
1307      * Translates absolute coordinates into coordinates in the coordinate
1308      * space of this component.
1309      */
1310     Point pointRelativeToComponent(Point absolute) {
1311         Point compCoords = getLocationOnScreen();
1312         return new Point(absolute.x - compCoords.x,
1313                          absolute.y - compCoords.y);
1314     }
1315 
1316     /**
1317      * Assuming that mouse location is stored in PointerInfo passed
1318      * to this method, it finds a Component that is in the same
1319      * Window as this Component and is located under the mouse pointer.
1320      * If no such Component exists, null is returned.
1321      * NOTE: this method should be called under the protection of
1322      * tree lock, as it is done in Component.getMousePosition() and
1323      * Container.getMousePosition(boolean).
1324      */
1325     Component findUnderMouseInWindow(PointerInfo pi) {
1326         if (!isShowing()) {
1327             return null;
1328         }
1329         Window win = getContainingWindow();
1330         if (!Toolkit.getDefaultToolkit().getMouseInfoPeer().isWindowUnderMouse(win)) {
1331             return null;
1332         }
1333         final boolean INCLUDE_DISABLED = true;
1334         Point relativeToWindow = win.pointRelativeToComponent(pi.getLocation());
1335         Component inTheSameWindow = win.findComponentAt(relativeToWindow.x,
1336                                                         relativeToWindow.y,
1337                                                         INCLUDE_DISABLED);
1338         return inTheSameWindow;
1339     }
1340 
1341     /**
1342      * Returns the position of the mouse pointer in this &lt;code&gt;Component&lt;/code&gt;'s
1343      * coordinate space if the &lt;code&gt;Component&lt;/code&gt; is directly under the mouse
1344      * pointer, otherwise returns &lt;code&gt;null&lt;/code&gt;.
1345      * If the &lt;code&gt;Component&lt;/code&gt; is not showing on the screen, this method
1346      * returns &lt;code&gt;null&lt;/code&gt; even if the mouse pointer is above the area
1347      * where the &lt;code&gt;Component&lt;/code&gt; would be displayed.
1348      * If the &lt;code&gt;Component&lt;/code&gt; is partially or fully obscured by other
1349      * &lt;code&gt;Component&lt;/code&gt;s or native windows, this method returns a non-null
1350      * value only if the mouse pointer is located above the unobscured part of the
1351      * &lt;code&gt;Component&lt;/code&gt;.
1352      * &lt;p&gt;
1353      * For &lt;code&gt;Container&lt;/code&gt;s it returns a non-null value if the mouse is
1354      * above the &lt;code&gt;Container&lt;/code&gt; itself or above any of its descendants.
1355      * Use {@link Container#getMousePosition(boolean)} if you need to exclude children.
1356      * &lt;p&gt;
1357      * Sometimes the exact mouse coordinates are not important, and the only thing
1358      * that matters is whether a specific &lt;code&gt;Component&lt;/code&gt; is under the mouse
1359      * pointer. If the return value of this method is &lt;code&gt;null&lt;/code&gt;, mouse
1360      * pointer is not directly above the &lt;code&gt;Component&lt;/code&gt;.
1361      *
1362      * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true
1363      * @see       #isShowing
1364      * @see       Container#getMousePosition
1365      * @return    mouse coordinates relative to this &lt;code&gt;Component&lt;/code&gt;, or null
1366      * @since     1.5
1367      */
1368     public Point getMousePosition() throws HeadlessException {
1369         if (GraphicsEnvironment.isHeadless()) {
1370             throw new HeadlessException();
1371         }
1372 
1373         PointerInfo pi = java.security.AccessController.doPrivileged(
1374                                                                      new java.security.PrivilegedAction&lt;PointerInfo&gt;() {
1375                                                                          public PointerInfo run() {
1376                                                                              return MouseInfo.getPointerInfo();
1377                                                                          }
1378                                                                      }
1379                                                                      );
1380 
1381         synchronized (getTreeLock()) {
1382             Component inTheSameWindow = findUnderMouseInWindow(pi);
1383             if (!isSameOrAncestorOf(inTheSameWindow, true)) {
1384                 return null;
1385             }
1386             return pointRelativeToComponent(pi.getLocation());
1387         }
1388     }
1389 
1390     /**
1391      * Overridden in Container. Must be called under TreeLock.
1392      */
1393     boolean isSameOrAncestorOf(Component comp, boolean allowChildren) {
1394         return comp == this;
1395     }
1396 
1397     /**
1398      * Determines whether this component is showing on screen. This means
1399      * that the component must be visible, and it must be in a container
1400      * that is visible and showing.
1401      * &lt;p&gt;
1402      * &lt;strong&gt;Note:&lt;/strong&gt; sometimes there is no way to detect whether the
1403      * {@code Component} is actually visible to the user.  This can happen when:
1404      * &lt;ul&gt;
1405      * &lt;li&gt;the component has been added to a visible {@code ScrollPane} but
1406      * the {@code Component} is not currently in the scroll pane's view port.
1407      * &lt;li&gt;the {@code Component} is obscured by another {@code Component} or
1408      * {@code Container}.
1409      * &lt;/ul&gt;
1410      * @return &lt;code&gt;true&lt;/code&gt; if the component is showing,
1411      *          &lt;code&gt;false&lt;/code&gt; otherwise
1412      * @see #setVisible
1413      * @since JDK1.0
1414      */
1415     public boolean isShowing() {
1416         if (visible &amp;&amp; (peer != null)) {
1417             Container parent = this.parent;
1418             return (parent == null) || parent.isShowing();
1419         }
1420         return false;
1421     }
1422 
1423     /**
1424      * Determines whether this component is enabled. An enabled component
1425      * can respond to user input and generate events. Components are
1426      * enabled initially by default. A component may be enabled or disabled by
1427      * calling its &lt;code&gt;setEnabled&lt;/code&gt; method.
1428      * @return &lt;code&gt;true&lt;/code&gt; if the component is enabled,
1429      *          &lt;code&gt;false&lt;/code&gt; otherwise
1430      * @see #setEnabled
1431      * @since JDK1.0
1432      */
1433     public boolean isEnabled() {
1434         return isEnabledImpl();
1435     }
1436 
1437     /*
1438      * This is called by the native code, so client code can't
1439      * be called on the toolkit thread.
1440      */
1441     final boolean isEnabledImpl() {
1442         return enabled;
1443     }
1444 
1445     /**
1446      * Enables or disables this component, depending on the value of the
1447      * parameter &lt;code&gt;b&lt;/code&gt;. An enabled component can respond to user
1448      * input and generate events. Components are enabled initially by default.
1449      *
1450      * &lt;p&gt;Note: Disabling a lightweight component does not prevent it from
1451      * receiving MouseEvents.
1452      * &lt;p&gt;Note: Disabling a heavyweight container prevents all components
1453      * in this container from receiving any input events.  But disabling a
1454      * lightweight container affects only this container.
1455      *
1456      * @param     b   If &lt;code&gt;true&lt;/code&gt;, this component is
1457      *            enabled; otherwise this component is disabled
1458      * @see #isEnabled
1459      * @see #isLightweight
1460      * @since JDK1.1
1461      */
1462     public void setEnabled(boolean b) {
1463         enable(b);
1464     }
1465 
1466     /**
1467      * @deprecated As of JDK version 1.1,
1468      * replaced by &lt;code&gt;setEnabled(boolean)&lt;/code&gt;.
1469      */
1470     @Deprecated
1471     public void enable() {
1472         if (!enabled) {
1473             synchronized (getTreeLock()) {
1474                 enabled = true;
1475                 ComponentPeer peer = this.peer;
1476                 if (peer != null) {
1477                     peer.setEnabled(true);
1478                     if (visible) {
1479                         updateCursorImmediately();
1480                     }
1481                 }
1482             }
1483             if (accessibleContext != null) {
1484                 accessibleContext.firePropertyChange(
1485                                                      AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
1486                                                      null, AccessibleState.ENABLED);
1487             }
1488         }
1489     }
1490 
1491     /**
1492      * @deprecated As of JDK version 1.1,
1493      * replaced by &lt;code&gt;setEnabled(boolean)&lt;/code&gt;.
1494      */
1495     @Deprecated
1496     public void enable(boolean b) {
1497         if (b) {
1498             enable();
1499         } else {
1500             disable();
1501         }
1502     }
1503 
1504     /**
1505      * @deprecated As of JDK version 1.1,
1506      * replaced by &lt;code&gt;setEnabled(boolean)&lt;/code&gt;.
1507      */
1508     @Deprecated
1509     public void disable() {
1510         if (enabled) {
1511             KeyboardFocusManager.clearMostRecentFocusOwner(this);
1512             synchronized (getTreeLock()) {
1513                 enabled = false;
1514                 // A disabled lw container is allowed to contain a focus owner.
1515                 if ((isFocusOwner() || (containsFocus() &amp;&amp; !isLightweight())) &amp;&amp;
1516                     KeyboardFocusManager.isAutoFocusTransferEnabled())
1517                 {
1518                     // Don't clear the global focus owner. If transferFocus
1519                     // fails, we want the focus to stay on the disabled
1520                     // Component so that keyboard traversal, et. al. still
1521                     // makes sense to the user.
1522                     transferFocus(false);
1523                 }
1524                 ComponentPeer peer = this.peer;
1525                 if (peer != null) {
1526                     peer.setEnabled(false);
1527                     if (visible) {
1528                         updateCursorImmediately();
1529                     }
1530                 }
1531             }
1532             if (accessibleContext != null) {
1533                 accessibleContext.firePropertyChange(
1534                                                      AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
1535                                                      null, AccessibleState.ENABLED);
1536             }
1537         }
1538     }
1539 
1540     /**
1541      * Returns true if this component is painted to an offscreen image
1542      * ("buffer") that's copied to the screen later.  Component
1543      * subclasses that support double buffering should override this
1544      * method to return true if double buffering is enabled.
1545      *
1546      * @return false by default
1547      */
1548     public boolean isDoubleBuffered() {
1549         return false;
1550     }
1551 
1552     /**
1553      * Enables or disables input method support for this component. If input
1554      * method support is enabled and the component also processes key events,
1555      * incoming events are offered to
1556      * the current input method and will only be processed by the component or
1557      * dispatched to its listeners if the input method does not consume them.
1558      * By default, input method support is enabled.
1559      *
1560      * @param enable true to enable, false to disable
1561      * @see #processKeyEvent
1562      * @since 1.2
1563      */
1564     public void enableInputMethods(boolean enable) {
1565         if (enable) {
1566             if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0)
1567                 return;
1568 
1569             // If this component already has focus, then activate the
1570             // input method by dispatching a synthesized focus gained
1571             // event.
1572             if (isFocusOwner()) {
1573                 InputContext inputContext = getInputContext();
1574                 if (inputContext != null) {
1575                     FocusEvent focusGainedEvent =
1576                         new FocusEvent(this, FocusEvent.FOCUS_GAINED);
1577                     inputContext.dispatchEvent(focusGainedEvent);
1578                 }
1579             }
1580 
1581             eventMask |= AWTEvent.INPUT_METHODS_ENABLED_MASK;
1582         } else {
1583             if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) {
1584                 InputContext inputContext = getInputContext();
1585                 if (inputContext != null) {
1586                     inputContext.endComposition();
1587                     inputContext.removeNotify(this);
1588                 }
1589             }
1590             eventMask &amp;= ~AWTEvent.INPUT_METHODS_ENABLED_MASK;
1591         }
1592     }
1593 
1594     /**
1595      * Shows or hides this component depending on the value of parameter
1596      * &lt;code&gt;b&lt;/code&gt;.
1597      * &lt;p&gt;
1598      * This method changes layout-related information, and therefore,
1599      * invalidates the component hierarchy.
1600      *
1601      * @param b  if &lt;code&gt;true&lt;/code&gt;, shows this component;
1602      * otherwise, hides this component
1603      * @see #isVisible
1604      * @see #invalidate
1605      * @since JDK1.1
1606      */
1607     public void setVisible(boolean b) {
1608         show(b);
1609     }
1610 
1611     /**
1612      * @deprecated As of JDK version 1.1,
1613      * replaced by &lt;code&gt;setVisible(boolean)&lt;/code&gt;.
1614      */
1615     @Deprecated
1616     public void show() {
1617         if (!visible) {
1618             synchronized (getTreeLock()) {
1619                 visible = true;
1620                 mixOnShowing();
1621                 ComponentPeer peer = this.peer;
1622                 if (peer != null) {
1623                     peer.setVisible(true);
1624                     createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED,
1625                                           this, parent,
1626                                           HierarchyEvent.SHOWING_CHANGED,
1627                                           Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));
1628                     if (peer instanceof LightweightPeer) {
1629                         repaint();
1630                     }
1631                     updateCursorImmediately();
1632                 }
1633 
1634                 if (componentListener != null ||
1635                     (eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0 ||
1636                     Toolkit.enabledOnToolkit(AWTEvent.COMPONENT_EVENT_MASK)) {
1637                     ComponentEvent e = new ComponentEvent(this,
1638                                                           ComponentEvent.COMPONENT_SHOWN);
1639                     Toolkit.getEventQueue().postEvent(e);
1640                 }
1641             }
1642             Container parent = this.parent;
1643             if (parent != null) {
1644                 parent.invalidate();
1645             }
1646         }
1647     }
1648 
1649     /**
1650      * @deprecated As of JDK version 1.1,
1651      * replaced by &lt;code&gt;setVisible(boolean)&lt;/code&gt;.
1652      */
1653     @Deprecated
1654     public void show(boolean b) {
1655         if (b) {
1656             show();
1657         } else {
1658             hide();
1659         }
1660     }
1661 
1662     boolean containsFocus() {
1663         return isFocusOwner();
1664     }
1665 
1666     void clearMostRecentFocusOwnerOnHide() {
1667         KeyboardFocusManager.clearMostRecentFocusOwner(this);
1668     }
1669 
1670     void clearCurrentFocusCycleRootOnHide() {
1671         /* do nothing */
1672     }
1673 
1674     /*
1675      * Delete references from LightweithDispatcher of a heavyweight parent
1676      */
1677     void clearLightweightDispatcherOnRemove(Component removedComponent) {
1678         if (parent != null) {
1679             parent.clearLightweightDispatcherOnRemove(removedComponent);
1680         }
1681     }
1682 
1683     /**
1684      * @deprecated As of JDK version 1.1,
1685      * replaced by &lt;code&gt;setVisible(boolean)&lt;/code&gt;.
1686      */
1687     @Deprecated
1688     public void hide() {
1689         isPacked = false;
1690 
1691         if (visible) {
1692             clearCurrentFocusCycleRootOnHide();
1693             clearMostRecentFocusOwnerOnHide();
1694             synchronized (getTreeLock()) {
1695                 visible = false;
1696                 mixOnHiding(isLightweight());
1697                 if (containsFocus() &amp;&amp; KeyboardFocusManager.isAutoFocusTransferEnabled()) {
1698                     transferFocus(true);
1699                 }
1700                 ComponentPeer peer = this.peer;
1701                 if (peer != null) {
1702                     peer.setVisible(false);
1703                     createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED,
1704                                           this, parent,
1705                                           HierarchyEvent.SHOWING_CHANGED,
1706                                           Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));
1707                     if (peer instanceof LightweightPeer) {
1708                         repaint();
1709                     }
1710                     updateCursorImmediately();
1711                 }
1712                 if (componentListener != null ||
1713                     (eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0 ||
1714                     Toolkit.enabledOnToolkit(AWTEvent.COMPONENT_EVENT_MASK)) {
1715                     ComponentEvent e = new ComponentEvent(this,
1716                                                           ComponentEvent.COMPONENT_HIDDEN);
1717                     Toolkit.getEventQueue().postEvent(e);
1718                 }
1719             }
1720             Container parent = this.parent;
1721             if (parent != null) {
1722                 parent.invalidate();
1723             }
1724         }
1725     }
1726 
1727     /**
1728      * Gets the foreground color of this component.
1729      * @return this component's foreground color; if this component does
1730      * not have a foreground color, the foreground color of its parent
1731      * is returned
1732      * @see #setForeground
1733      * @since JDK1.0
1734      * @beaninfo
1735      *       bound: true
1736      */
1737     @Transient
1738     public Color getForeground() {
1739         Color foreground = this.foreground;
1740         if (foreground != null) {
1741             return foreground;
1742         }
1743         Container parent = this.parent;
1744         return (parent != null) ? parent.getForeground() : null;
1745     }
1746 
1747     /**
1748      * Sets the foreground color of this component.
1749      * @param c the color to become this component's
1750      *          foreground color; if this parameter is &lt;code&gt;null&lt;/code&gt;
1751      *          then this component will inherit
1752      *          the foreground color of its parent
1753      * @see #getForeground
1754      * @since JDK1.0
1755      */
1756     public void setForeground(Color c) {
1757         Color oldColor = foreground;
1758         ComponentPeer peer = this.peer;
1759         foreground = c;
1760         if (peer != null) {
1761             c = getForeground();
1762             if (c != null) {
1763                 peer.setForeground(c);
1764             }
1765         }
1766         // This is a bound property, so report the change to
1767         // any registered listeners.  (Cheap if there are none.)
1768         firePropertyChange("foreground", oldColor, c);
1769     }
1770 
1771     /**
1772      * Returns whether the foreground color has been explicitly set for this
1773      * Component. If this method returns &lt;code&gt;false&lt;/code&gt;, this Component is
1774      * inheriting its foreground color from an ancestor.
1775      *
1776      * @return &lt;code&gt;true&lt;/code&gt; if the foreground color has been explicitly
1777      *         set for this Component; &lt;code&gt;false&lt;/code&gt; otherwise.
1778      * @since 1.4
1779      */
1780     public boolean isForegroundSet() {
1781         return (foreground != null);
1782     }
1783 
1784     /**
1785      * Gets the background color of this component.
1786      * @return this component's background color; if this component does
1787      *          not have a background color,
1788      *          the background color of its parent is returned
1789      * @see #setBackground
1790      * @since JDK1.0
1791      */
1792     @Transient
1793     public Color getBackground() {
1794         Color background = this.background;
1795         if (background != null) {
1796             return background;
1797         }
1798         Container parent = this.parent;
1799         return (parent != null) ? parent.getBackground() : null;
1800     }
1801 
1802     /**
1803      * Sets the background color of this component.
1804      * &lt;p&gt;
1805      * The background color affects each component differently and the
1806      * parts of the component that are affected by the background color
1807      * may differ between operating systems.
1808      *
1809      * @param c the color to become this component's color;
1810      *          if this parameter is &lt;code&gt;null&lt;/code&gt;, then this
1811      *          component will inherit the background color of its parent
1812      * @see #getBackground
1813      * @since JDK1.0
1814      * @beaninfo
1815      *       bound: true
1816      */
1817     public void setBackground(Color c) {
1818         Color oldColor = background;
1819         ComponentPeer peer = this.peer;
1820         background = c;
1821         if (peer != null) {
1822             c = getBackground();
1823             if (c != null) {
1824                 peer.setBackground(c);
1825             }
1826         }
1827         // This is a bound property, so report the change to
1828         // any registered listeners.  (Cheap if there are none.)
1829         firePropertyChange("background", oldColor, c);
1830     }
1831 
1832     /**
1833      * Returns whether the background color has been explicitly set for this
1834      * Component. If this method returns &lt;code&gt;false&lt;/code&gt;, this Component is
1835      * inheriting its background color from an ancestor.
1836      *
1837      * @return &lt;code&gt;true&lt;/code&gt; if the background color has been explicitly
1838      *         set for this Component; &lt;code&gt;false&lt;/code&gt; otherwise.
1839      * @since 1.4
1840      */
1841     public boolean isBackgroundSet() {
1842         return (background != null);
1843     }
1844 
1845     /**
1846      * Gets the font of this component.
1847      * @return this component's font; if a font has not been set
1848      * for this component, the font of its parent is returned
1849      * @see #setFont
1850      * @since JDK1.0
1851      */
1852     @Transient
1853     public Font getFont() {
1854         return getFont_NoClientCode();
1855     }
1856 
1857     // NOTE: This method may be called by privileged threads.
1858     //       This functionality is implemented in a package-private method
1859     //       to insure that it cannot be overridden by client subclasses.
1860     //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
1861     final Font getFont_NoClientCode() {
1862         Font font = this.font;
1863         if (font != null) {
1864             return font;
1865         }
1866         Container parent = this.parent;
1867         return (parent != null) ? parent.getFont_NoClientCode() : null;
1868     }
1869 
1870     /**
1871      * Sets the font of this component.
1872      * &lt;p&gt;
1873      * This method changes layout-related information, and therefore,
1874      * invalidates the component hierarchy.
1875      *
1876      * @param f the font to become this component's font;
1877      *          if this parameter is &lt;code&gt;null&lt;/code&gt; then this
1878      *          component will inherit the font of its parent
1879      * @see #getFont
1880      * @see #invalidate
1881      * @since JDK1.0
1882      * @beaninfo
1883      *       bound: true
1884      */
1885     public void setFont(Font f) {
1886         Font oldFont, newFont;
1887         synchronized(getTreeLock()) {
1888             oldFont = font;
1889             newFont = font = f;
1890             ComponentPeer peer = this.peer;
1891             if (peer != null) {
1892                 f = getFont();
1893                 if (f != null) {
1894                     peer.setFont(f);
1895                     peerFont = f;
1896                 }
1897             }
1898         }
1899         // This is a bound property, so report the change to
1900         // any registered listeners.  (Cheap if there are none.)
1901         firePropertyChange("font", oldFont, newFont);
1902 
1903         // This could change the preferred size of the Component.
1904         // Fix for 6213660. Should compare old and new fonts and do not
1905         // call invalidate() if they are equal.
1906         if (f != oldFont &amp;&amp; (oldFont == null ||
1907                                       !oldFont.equals(f))) {
1908             invalidateIfValid();
1909         }
1910     }
1911 
1912     /**
1913      * Returns whether the font has been explicitly set for this Component. If
1914      * this method returns &lt;code&gt;false&lt;/code&gt;, this Component is inheriting its
1915      * font from an ancestor.
1916      *
1917      * @return &lt;code&gt;true&lt;/code&gt; if the font has been explicitly set for this
1918      *         Component; &lt;code&gt;false&lt;/code&gt; otherwise.
1919      * @since 1.4
1920      */
1921     public boolean isFontSet() {
1922         return (font != null);
1923     }
1924 
1925     /**
1926      * Gets the locale of this component.
1927      * @return this component's locale; if this component does not
1928      *          have a locale, the locale of its parent is returned
1929      * @see #setLocale
1930      * @exception IllegalComponentStateException if the &lt;code&gt;Component&lt;/code&gt;
1931      *          does not have its own locale and has not yet been added to
1932      *          a containment hierarchy such that the locale can be determined
1933      *          from the containing parent
1934      * @since  JDK1.1
1935      */
1936     public Locale getLocale() {
1937         Locale locale = this.locale;
1938         if (locale != null) {
1939             return locale;
1940         }
1941         Container parent = this.parent;
1942 
1943         if (parent == null) {
1944             throw new IllegalComponentStateException("This component must have a parent in order to determine its locale");
1945         } else {
1946             return parent.getLocale();
1947         }
1948     }
1949 
1950     /**
1951      * Sets the locale of this component.  This is a bound property.
1952      * &lt;p&gt;
1953      * This method changes layout-related information, and therefore,
1954      * invalidates the component hierarchy.
1955      *
1956      * @param l the locale to become this component's locale
1957      * @see #getLocale
1958      * @see #invalidate
1959      * @since JDK1.1
1960      */
1961     public void setLocale(Locale l) {
1962         Locale oldValue = locale;
1963         locale = l;
1964 
1965         // This is a bound property, so report the change to
1966         // any registered listeners.  (Cheap if there are none.)
1967         firePropertyChange("locale", oldValue, l);
1968 
1969         // This could change the preferred size of the Component.
1970         invalidateIfValid();
1971     }
1972 
1973     /**
1974      * Gets the instance of &lt;code&gt;ColorModel&lt;/code&gt; used to display
1975      * the component on the output device.
1976      * @return the color model used by this component
1977      * @see java.awt.image.ColorModel
1978      * @see java.awt.peer.ComponentPeer#getColorModel()
1979      * @see Toolkit#getColorModel()
1980      * @since JDK1.0
1981      */
1982     public ColorModel getColorModel() {
1983         ComponentPeer peer = this.peer;
1984         if ((peer != null) &amp;&amp; ! (peer instanceof LightweightPeer)) {
1985             return peer.getColorModel();
1986         } else if (GraphicsEnvironment.isHeadless()) {
1987             return ColorModel.getRGBdefault();
1988         } // else
1989         return getToolkit().getColorModel();
1990     }
1991 
1992     /**
1993      * Gets the location of this component in the form of a
1994      * point specifying the component's top-left corner.
1995      * The location will be relative to the parent's coordinate space.
1996      * &lt;p&gt;
1997      * Due to the asynchronous nature of native event handling, this
1998      * method can return outdated values (for instance, after several calls
1999      * of &lt;code&gt;setLocation()&lt;/code&gt; in rapid succession).  For this
2000      * reason, the recommended method of obtaining a component's position is
2001      * within &lt;code&gt;java.awt.event.ComponentListener.componentMoved()&lt;/code&gt;,
2002      * which is called after the operating system has finished moving the
2003      * component.
2004      * &lt;/p&gt;
2005      * @return an instance of &lt;code&gt;Point&lt;/code&gt; representing
2006      *          the top-left corner of the component's bounds in
2007      *          the coordinate space of the component's parent
2008      * @see #setLocation
2009      * @see #getLocationOnScreen
2010      * @since JDK1.1
2011      */
2012     public Point getLocation() {
2013         return location();
2014     }
2015 
2016     /**
2017      * Gets the location of this component in the form of a point
2018      * specifying the component's top-left corner in the screen's
2019      * coordinate space.
2020      * @return an instance of &lt;code&gt;Point&lt;/code&gt; representing
2021      *          the top-left corner of the component's bounds in the
2022      *          coordinate space of the screen
2023      * @throws IllegalComponentStateException if the
2024      *          component is not showing on the screen
2025      * @see #setLocation
2026      * @see #getLocation
2027      */
2028     public Point getLocationOnScreen() {
2029         synchronized (getTreeLock()) {
2030             return getLocationOnScreen_NoTreeLock();
2031         }
2032     }
2033 
2034     /*
2035      * a package private version of getLocationOnScreen
2036      * used by GlobalCursormanager to update cursor
2037      */
2038     final Point getLocationOnScreen_NoTreeLock() {
2039 
2040         if (peer != null &amp;&amp; isShowing()) {
2041             if (peer instanceof LightweightPeer) {
2042                 // lightweight component location needs to be translated
2043                 // relative to a native component.
2044                 Container host = getNativeContainer();
2045                 Point pt = host.peer.getLocationOnScreen();
2046                 for(Component c = this; c != host; c = c.getParent()) {
2047                     pt.x += c.x;
2048                     pt.y += c.y;
2049                 }
2050                 return pt;
2051             } else {
2052                 Point pt = peer.getLocationOnScreen();
2053                 return pt;
2054             }
2055         } else {
2056             throw new IllegalComponentStateException("component must be showing on the screen to determine its location");
2057         }
2058     }
2059 
2060 
2061     /**
2062      * @deprecated As of JDK version 1.1,
2063      * replaced by &lt;code&gt;getLocation()&lt;/code&gt;.
2064      */
2065     @Deprecated
2066     public Point location() {
2067         return location_NoClientCode();
2068     }
2069 
2070     private Point location_NoClientCode() {
2071         return new Point(x, y);
2072     }
2073 
2074     /**
2075      * Moves this component to a new location. The top-left corner of
2076      * the new location is specified by the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;
2077      * parameters in the coordinate space of this component's parent.
2078      * &lt;p&gt;
2079      * This method changes layout-related information, and therefore,
2080      * invalidates the component hierarchy.
2081      *
2082      * @param x the &lt;i&gt;x&lt;/i&gt;-coordinate of the new location's
2083      *          top-left corner in the parent's coordinate space
2084      * @param y the &lt;i&gt;y&lt;/i&gt;-coordinate of the new location's
2085      *          top-left corner in the parent's coordinate space
2086      * @see #getLocation
2087      * @see #setBounds
2088      * @see #invalidate
2089      * @since JDK1.1
2090      */
2091     public void setLocation(int x, int y) {
2092         move(x, y);
2093     }
2094 
2095     /**
2096      * @deprecated As of JDK version 1.1,
2097      * replaced by &lt;code&gt;setLocation(int, int)&lt;/code&gt;.
2098      */
2099     @Deprecated
2100     public void move(int x, int y) {
2101         synchronized(getTreeLock()) {
2102             setBoundsOp(ComponentPeer.SET_LOCATION);
2103             setBounds(x, y, width, height);
2104         }
2105     }
2106 
2107     /**
2108      * Moves this component to a new location. The top-left corner of
2109      * the new location is specified by point &lt;code&gt;p&lt;/code&gt;. Point
2110      * &lt;code&gt;p&lt;/code&gt; is given in the parent's coordinate space.
2111      * &lt;p&gt;
2112      * This method changes layout-related information, and therefore,
2113      * invalidates the component hierarchy.
2114      *
2115      * @param p the point defining the top-left corner
2116      *          of the new location, given in the coordinate space of this
2117      *          component's parent
2118      * @see #getLocation
2119      * @see #setBounds
2120      * @see #invalidate
2121      * @since JDK1.1
2122      */
2123     public void setLocation(Point p) {
2124         setLocation(p.x, p.y);
2125     }
2126 
2127     /**
2128      * Returns the size of this component in the form of a
2129      * &lt;code&gt;Dimension&lt;/code&gt; object. The &lt;code&gt;height&lt;/code&gt;
2130      * field of the &lt;code&gt;Dimension&lt;/code&gt; object contains
2131      * this component's height, and the &lt;code&gt;width&lt;/code&gt;
2132      * field of the &lt;code&gt;Dimension&lt;/code&gt; object contains
2133      * this component's width.
2134      * @return a &lt;code&gt;Dimension&lt;/code&gt; object that indicates the
2135      *          size of this component
2136      * @see #setSize
2137      * @since JDK1.1
2138      */
2139     public Dimension getSize() {
2140         return size();
2141     }
2142 
2143     /**
2144      * @deprecated As of JDK version 1.1,
2145      * replaced by &lt;code&gt;getSize()&lt;/code&gt;.
2146      */
2147     @Deprecated
2148     public Dimension size() {
2149         return new Dimension(width, height);
2150     }
2151 
2152     /**
2153      * Resizes this component so that it has width &lt;code&gt;width&lt;/code&gt;
2154      * and height &lt;code&gt;height&lt;/code&gt;.
2155      * &lt;p&gt;
2156      * This method changes layout-related information, and therefore,
2157      * invalidates the component hierarchy.
2158      *
2159      * @param width the new width of this component in pixels
2160      * @param height the new height of this component in pixels
2161      * @see #getSize
2162      * @see #setBounds
2163      * @see #invalidate
2164      * @since JDK1.1
2165      */
2166     public void setSize(int width, int height) {
2167         resize(width, height);
2168     }
2169 
2170     /**
2171      * @deprecated As of JDK version 1.1,
2172      * replaced by &lt;code&gt;setSize(int, int)&lt;/code&gt;.
2173      */
2174     @Deprecated
2175     public void resize(int width, int height) {
2176         synchronized(getTreeLock()) {
2177             setBoundsOp(ComponentPeer.SET_SIZE);
2178             setBounds(x, y, width, height);
2179         }
2180     }
2181 
2182     /**
2183      * Resizes this component so that it has width &lt;code&gt;d.width&lt;/code&gt;
2184      * and height &lt;code&gt;d.height&lt;/code&gt;.
2185      * &lt;p&gt;
2186      * This method changes layout-related information, and therefore,
2187      * invalidates the component hierarchy.
2188      *
2189      * @param d the dimension specifying the new size
2190      *          of this component
2191      * @throws NullPointerException if {@code d} is {@code null}
2192      * @see #setSize
2193      * @see #setBounds
2194      * @see #invalidate
2195      * @since JDK1.1
2196      */
2197     public void setSize(Dimension d) {
2198         resize(d);
2199     }
2200 
2201     /**
2202      * @deprecated As of JDK version 1.1,
2203      * replaced by &lt;code&gt;setSize(Dimension)&lt;/code&gt;.
2204      */
2205     @Deprecated
2206     public void resize(Dimension d) {
2207         setSize(d.width, d.height);
2208     }
2209 
2210     /**
2211      * Gets the bounds of this component in the form of a
2212      * &lt;code&gt;Rectangle&lt;/code&gt; object. The bounds specify this
2213      * component's width, height, and location relative to
2214      * its parent.
2215      * @return a rectangle indicating this component's bounds
2216      * @see #setBounds
2217      * @see #getLocation
2218      * @see #getSize
2219      */
2220     public Rectangle getBounds() {
2221         return bounds();
2222     }
2223 
2224     /**
2225      * @deprecated As of JDK version 1.1,
2226      * replaced by &lt;code&gt;getBounds()&lt;/code&gt;.
2227      */
2228     @Deprecated
2229     public Rectangle bounds() {
2230         return new Rectangle(x, y, width, height);
2231     }
2232 
2233     /**
2234      * Moves and resizes this component. The new location of the top-left
2235      * corner is specified by &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and the
2236      * new size is specified by &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;.
2237      * &lt;p&gt;
2238      * This method changes layout-related information, and therefore,
2239      * invalidates the component hierarchy.
2240      *
2241      * @param x the new &lt;i&gt;x&lt;/i&gt;-coordinate of this component
2242      * @param y the new &lt;i&gt;y&lt;/i&gt;-coordinate of this component
2243      * @param width the new &lt;code&gt;width&lt;/code&gt; of this component
2244      * @param height the new &lt;code&gt;height&lt;/code&gt; of this
2245      *          component
2246      * @see #getBounds
2247      * @see #setLocation(int, int)
2248      * @see #setLocation(Point)
2249      * @see #setSize(int, int)
2250      * @see #setSize(Dimension)
2251      * @see #invalidate
2252      * @since JDK1.1
2253      */
2254     public void setBounds(int x, int y, int width, int height) {
2255         reshape(x, y, width, height);
2256     }
2257 
2258     /**
2259      * @deprecated As of JDK version 1.1,
2260      * replaced by &lt;code&gt;setBounds(int, int, int, int)&lt;/code&gt;.
2261      */
2262     @Deprecated
2263     public void reshape(int x, int y, int width, int height) {
2264         synchronized (getTreeLock()) {
2265             try {
2266                 setBoundsOp(ComponentPeer.SET_BOUNDS);
2267                 boolean resized = (this.width != width) || (this.height != height);
2268                 boolean moved = (this.x != x) || (this.y != y);
2269                 if (!resized &amp;&amp; !moved) {
2270                     return;
2271                 }
2272                 int oldX = this.x;
2273                 int oldY = this.y;
2274                 int oldWidth = this.width;
2275                 int oldHeight = this.height;
2276                 this.x = x;
2277                 this.y = y;
2278                 this.width = width;
2279                 this.height = height;
2280 
2281                 if (resized) {
2282                     isPacked = false;
2283                 }
2284 
2285                 boolean needNotify = true;
2286                 mixOnReshaping();
2287                 if (peer != null) {
2288                     // LightwightPeer is an empty stub so can skip peer.reshape
2289                     if (!(peer instanceof LightweightPeer)) {
2290                         reshapeNativePeer(x, y, width, height, getBoundsOp());
2291                         // Check peer actualy changed coordinates
2292                         resized = (oldWidth != this.width) || (oldHeight != this.height);
2293                         moved = (oldX != this.x) || (oldY != this.y);
2294                         // fix for 5025858: do not send ComponentEvents for toplevel
2295                         // windows here as it is done from peer or native code when
2296                         // the window is really resized or moved, otherwise some
2297                         // events may be sent twice
2298                         if (this instanceof Window) {
2299                             needNotify = false;
2300                         }
2301                     }
2302                     if (resized) {
2303                         invalidate();
2304                     }
2305                     if (parent != null) {
2306                         parent.invalidateIfValid();
2307                     }
2308                 }
2309                 if (needNotify) {
2310                     notifyNewBounds(resized, moved);
2311                 }
2312                 repaintParentIfNeeded(oldX, oldY, oldWidth, oldHeight);
2313             } finally {
2314                 setBoundsOp(ComponentPeer.RESET_OPERATION);
2315             }
2316         }
2317     }
2318 
2319     private void repaintParentIfNeeded(int oldX, int oldY, int oldWidth,
2320                                        int oldHeight)
2321     {
2322         if (parent != null &amp;&amp; peer instanceof LightweightPeer &amp;&amp; isShowing()) {
2323             // Have the parent redraw the area this component occupied.
2324             parent.repaint(oldX, oldY, oldWidth, oldHeight);
2325             // Have the parent redraw the area this component *now* occupies.
2326             repaint();
2327         }
2328     }
2329 
2330     private void reshapeNativePeer(int x, int y, int width, int height, int op) {
2331         // native peer might be offset by more than direct
2332         // parent since parent might be lightweight.
2333         int nativeX = x;
2334         int nativeY = y;
2335         for (Component c = parent;
2336              (c != null) &amp;&amp; (c.peer instanceof LightweightPeer);
2337              c = c.parent)
2338         {
2339             nativeX += c.x;
2340             nativeY += c.y;
2341         }
2342         peer.setBounds(nativeX, nativeY, width, height, op);
2343     }
2344 
2345     @SuppressWarnings("deprecation")
2346     private void notifyNewBounds(boolean resized, boolean moved) {
2347         if (componentListener != null
2348             || (eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0
2349             || Toolkit.enabledOnToolkit(AWTEvent.COMPONENT_EVENT_MASK))
2350             {
2351                 if (resized) {
2352                     ComponentEvent e = new ComponentEvent(this,
2353                                                           ComponentEvent.COMPONENT_RESIZED);
2354                     Toolkit.getEventQueue().postEvent(e);
2355                 }
2356                 if (moved) {
2357                     ComponentEvent e = new ComponentEvent(this,
2358                                                           ComponentEvent.COMPONENT_MOVED);
2359                     Toolkit.getEventQueue().postEvent(e);
2360                 }
2361             } else {
2362                 if (this instanceof Container &amp;&amp; ((Container)this).countComponents() &gt; 0) {
2363                     boolean enabledOnToolkit =
2364                         Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK);
2365                     if (resized) {
2366 
2367                         ((Container)this).createChildHierarchyEvents(
2368                                                                      HierarchyEvent.ANCESTOR_RESIZED, 0, enabledOnToolkit);
2369                     }
2370                     if (moved) {
2371                         ((Container)this).createChildHierarchyEvents(
2372                                                                      HierarchyEvent.ANCESTOR_MOVED, 0, enabledOnToolkit);
2373                     }
2374                 }
2375                 }
2376     }
2377 
2378     /**
2379      * Moves and resizes this component to conform to the new
2380      * bounding rectangle &lt;code&gt;r&lt;/code&gt;. This component's new
2381      * position is specified by &lt;code&gt;r.x&lt;/code&gt; and &lt;code&gt;r.y&lt;/code&gt;,
2382      * and its new size is specified by &lt;code&gt;r.width&lt;/code&gt; and
2383      * &lt;code&gt;r.height&lt;/code&gt;
2384      * &lt;p&gt;
2385      * This method changes layout-related information, and therefore,
2386      * invalidates the component hierarchy.
2387      *
2388      * @param r the new bounding rectangle for this component
2389      * @throws NullPointerException if {@code r} is {@code null}
2390      * @see       #getBounds
2391      * @see       #setLocation(int, int)
2392      * @see       #setLocation(Point)
2393      * @see       #setSize(int, int)
2394      * @see       #setSize(Dimension)
2395      * @see #invalidate
2396      * @since     JDK1.1
2397      */
2398     public void setBounds(Rectangle r) {
2399         setBounds(r.x, r.y, r.width, r.height);
2400     }
2401 
2402 
2403     /**
2404      * Returns the current x coordinate of the components origin.
2405      * This method is preferable to writing
2406      * &lt;code&gt;component.getBounds().x&lt;/code&gt;,
2407      * or &lt;code&gt;component.getLocation().x&lt;/code&gt; because it doesn't
2408      * cause any heap allocations.
2409      *
2410      * @return the current x coordinate of the components origin
2411      * @since 1.2
2412      */
2413     public int getX() {
2414         return x;
2415     }
2416 
2417 
2418     /**
2419      * Returns the current y coordinate of the components origin.
2420      * This method is preferable to writing
2421      * &lt;code&gt;component.getBounds().y&lt;/code&gt;,
2422      * or &lt;code&gt;component.getLocation().y&lt;/code&gt; because it
2423      * doesn't cause any heap allocations.
2424      *
2425      * @return the current y coordinate of the components origin
2426      * @since 1.2
2427      */
2428     public int getY() {
2429         return y;
2430     }
2431 
2432 
2433     /**
2434      * Returns the current width of this component.
2435      * This method is preferable to writing
2436      * &lt;code&gt;component.getBounds().width&lt;/code&gt;,
2437      * or &lt;code&gt;component.getSize().width&lt;/code&gt; because it
2438      * doesn't cause any heap allocations.
2439      *
2440      * @return the current width of this component
2441      * @since 1.2
2442      */
2443     public int getWidth() {
2444         return width;
2445     }
2446 
2447 
2448     /**
2449      * Returns the current height of this component.
2450      * This method is preferable to writing
2451      * &lt;code&gt;component.getBounds().height&lt;/code&gt;,
2452      * or &lt;code&gt;component.getSize().height&lt;/code&gt; because it
2453      * doesn't cause any heap allocations.
2454      *
2455      * @return the current height of this component
2456      * @since 1.2
2457      */
2458     public int getHeight() {
2459         return height;
2460     }
2461 
2462     /**
2463      * Stores the bounds of this component into "return value" &lt;b&gt;rv&lt;/b&gt; and
2464      * return &lt;b&gt;rv&lt;/b&gt;.  If rv is &lt;code&gt;null&lt;/code&gt; a new
2465      * &lt;code&gt;Rectangle&lt;/code&gt; is allocated.
2466      * This version of &lt;code&gt;getBounds&lt;/code&gt; is useful if the caller
2467      * wants to avoid allocating a new &lt;code&gt;Rectangle&lt;/code&gt; object
2468      * on the heap.
2469      *
2470      * @param rv the return value, modified to the components bounds
2471      * @return rv
2472      */
2473     public Rectangle getBounds(Rectangle rv) {
2474         if (rv == null) {
2475             return new Rectangle(getX(), getY(), getWidth(), getHeight());
2476         }
2477         else {
2478             rv.setBounds(getX(), getY(), getWidth(), getHeight());
2479             return rv;
2480         }
2481     }
2482 
2483     /**
2484      * Stores the width/height of this component into "return value" &lt;b&gt;rv&lt;/b&gt;
2485      * and return &lt;b&gt;rv&lt;/b&gt;.   If rv is &lt;code&gt;null&lt;/code&gt; a new
2486      * &lt;code&gt;Dimension&lt;/code&gt; object is allocated.  This version of
2487      * &lt;code&gt;getSize&lt;/code&gt; is useful if the caller wants to avoid
2488      * allocating a new &lt;code&gt;Dimension&lt;/code&gt; object on the heap.
2489      *
2490      * @param rv the return value, modified to the components size
2491      * @return rv
2492      */
2493     public Dimension getSize(Dimension rv) {
2494         if (rv == null) {
2495             return new Dimension(getWidth(), getHeight());
2496         }
2497         else {
2498             rv.setSize(getWidth(), getHeight());
2499             return rv;
2500         }
2501     }
2502 
2503     /**
2504      * Stores the x,y origin of this component into "return value" &lt;b&gt;rv&lt;/b&gt;
2505      * and return &lt;b&gt;rv&lt;/b&gt;.   If rv is &lt;code&gt;null&lt;/code&gt; a new
2506      * &lt;code&gt;Point&lt;/code&gt; is allocated.
2507      * This version of &lt;code&gt;getLocation&lt;/code&gt; is useful if the
2508      * caller wants to avoid allocating a new &lt;code&gt;Point&lt;/code&gt;
2509      * object on the heap.
2510      *
2511      * @param rv the return value, modified to the components location
2512      * @return rv
2513      */
2514     public Point getLocation(Point rv) {
2515         if (rv == null) {
2516             return new Point(getX(), getY());
2517         }
2518         else {
2519             rv.setLocation(getX(), getY());
2520             return rv;
2521         }
2522     }
2523 
2524     /**
2525      * Returns true if this component is completely opaque, returns
2526      * false by default.
2527      * &lt;p&gt;
2528      * An opaque component paints every pixel within its
2529      * rectangular region. A non-opaque component paints only some of
2530      * its pixels, allowing the pixels underneath it to "show through".
2531      * A component that does not fully paint its pixels therefore
2532      * provides a degree of transparency.
2533      * &lt;p&gt;
2534      * Subclasses that guarantee to always completely paint their
2535      * contents should override this method and return true.
2536      *
2537      * @return true if this component is completely opaque
2538      * @see #isLightweight
2539      * @since 1.2
2540      */
2541     public boolean isOpaque() {
2542         if (getPeer() == null) {
2543             return false;
2544         }
2545         else {
2546             return !isLightweight();
2547         }
2548     }
2549 
2550 
2551     /**
2552      * A lightweight component doesn't have a native toolkit peer.
2553      * Subclasses of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;Container&lt;/code&gt;,
2554      * other than the ones defined in this package like &lt;code&gt;Button&lt;/code&gt;
2555      * or &lt;code&gt;Scrollbar&lt;/code&gt;, are lightweight.
2556      * All of the Swing components are lightweights.
2557      * &lt;p&gt;
2558      * This method will always return &lt;code&gt;false&lt;/code&gt; if this component
2559      * is not displayable because it is impossible to determine the
2560      * weight of an undisplayable component.
2561      *
2562      * @return true if this component has a lightweight peer; false if
2563      *         it has a native peer or no peer
2564      * @see #isDisplayable
2565      * @since 1.2
2566      */
2567     public boolean isLightweight() {
2568         return getPeer() instanceof LightweightPeer;
2569     }
2570 
2571 
2572     /**
2573      * Sets the preferred size of this component to a constant
2574      * value.  Subsequent calls to &lt;code&gt;getPreferredSize&lt;/code&gt; will always
2575      * return this value.  Setting the preferred size to &lt;code&gt;null&lt;/code&gt;
2576      * restores the default behavior.
2577      *
2578      * @param preferredSize The new preferred size, or null
2579      * @see #getPreferredSize
2580      * @see #isPreferredSizeSet
2581      * @since 1.5
2582      */
2583     public void setPreferredSize(Dimension preferredSize) {
2584         Dimension old;
2585         // If the preferred size was set, use it as the old value, otherwise
2586         // use null to indicate we didn't previously have a set preferred
2587         // size.
2588         if (prefSizeSet) {
2589             old = this.prefSize;
2590         }
2591         else {
2592             old = null;
2593         }
2594         this.prefSize = preferredSize;
2595         prefSizeSet = (preferredSize != null);
2596         firePropertyChange("preferredSize", old, preferredSize);
2597     }
2598 
2599 
2600     /**
2601      * Returns true if the preferred size has been set to a
2602      * non-&lt;code&gt;null&lt;/code&gt; value otherwise returns false.
2603      *
2604      * @return true if &lt;code&gt;setPreferredSize&lt;/code&gt; has been invoked
2605      *         with a non-null value.
2606      * @since 1.5
2607      */
2608     public boolean isPreferredSizeSet() {
2609         return prefSizeSet;
2610     }
2611 
2612 
2613     /**
2614      * Gets the preferred size of this component.
2615      * @return a dimension object indicating this component's preferred size
2616      * @see #getMinimumSize
2617      * @see LayoutManager
2618      */
2619     public Dimension getPreferredSize() {
2620         return preferredSize();
2621     }
2622 
2623 
2624     /**
2625      * @deprecated As of JDK version 1.1,
2626      * replaced by &lt;code&gt;getPreferredSize()&lt;/code&gt;.
2627      */
2628     @Deprecated
2629     public Dimension preferredSize() {
2630         /* Avoid grabbing the lock if a reasonable cached size value
2631          * is available.
2632          */
2633         Dimension dim = prefSize;
2634         if (dim == null || !(isPreferredSizeSet() || isValid())) {
2635             synchronized (getTreeLock()) {
2636                 prefSize = (peer != null) ?
2637                     peer.getPreferredSize() :
2638                     getMinimumSize();
2639                 dim = prefSize;
2640             }
2641         }
2642         return new Dimension(dim);
2643     }
2644 
2645     /**
2646      * Sets the minimum size of this component to a constant
2647      * value.  Subsequent calls to &lt;code&gt;getMinimumSize&lt;/code&gt; will always
2648      * return this value.  Setting the minimum size to &lt;code&gt;null&lt;/code&gt;
2649      * restores the default behavior.
2650      *
2651      * @param minimumSize the new minimum size of this component
2652      * @see #getMinimumSize
2653      * @see #isMinimumSizeSet
2654      * @since 1.5
2655      */
2656     public void setMinimumSize(Dimension minimumSize) {
2657         Dimension old;
2658         // If the minimum size was set, use it as the old value, otherwise
2659         // use null to indicate we didn't previously have a set minimum
2660         // size.
2661         if (minSizeSet) {
2662             old = this.minSize;
2663         }
2664         else {
2665             old = null;
2666         }
2667         this.minSize = minimumSize;
2668         minSizeSet = (minimumSize != null);
2669         firePropertyChange("minimumSize", old, minimumSize);
2670     }
2671 
2672     /**
2673      * Returns whether or not &lt;code&gt;setMinimumSize&lt;/code&gt; has been
2674      * invoked with a non-null value.
2675      *
2676      * @return true if &lt;code&gt;setMinimumSize&lt;/code&gt; has been invoked with a
2677      *              non-null value.
2678      * @since 1.5
2679      */
2680     public boolean isMinimumSizeSet() {
2681         return minSizeSet;
2682     }
2683 
2684     /**
2685      * Gets the minimum size of this component.
2686      * @return a dimension object indicating this component's minimum size
2687      * @see #getPreferredSize
2688      * @see LayoutManager
2689      */
2690     public Dimension getMinimumSize() {
2691         return minimumSize();
2692     }
2693 
2694     /**
2695      * @deprecated As of JDK version 1.1,
2696      * replaced by &lt;code&gt;getMinimumSize()&lt;/code&gt;.
2697      */
2698     @Deprecated
2699     public Dimension minimumSize() {
2700         /* Avoid grabbing the lock if a reasonable cached size value
2701          * is available.
2702          */
2703         Dimension dim = minSize;
2704         if (dim == null || !(isMinimumSizeSet() || isValid())) {
2705             synchronized (getTreeLock()) {
2706                 minSize = (peer != null) ?
2707                     peer.getMinimumSize() :
2708                     size();
2709                 dim = minSize;
2710             }
2711         }
2712         return new Dimension(dim);
2713     }
2714 
2715     /**
2716      * Sets the maximum size of this component to a constant
2717      * value.  Subsequent calls to &lt;code&gt;getMaximumSize&lt;/code&gt; will always
2718      * return this value.  Setting the maximum size to &lt;code&gt;null&lt;/code&gt;
2719      * restores the default behavior.
2720      *
2721      * @param maximumSize a &lt;code&gt;Dimension&lt;/code&gt; containing the
2722      *          desired maximum allowable size
2723      * @see #getMaximumSize
2724      * @see #isMaximumSizeSet
2725      * @since 1.5
2726      */
2727     public void setMaximumSize(Dimension maximumSize) {
2728         // If the maximum size was set, use it as the old value, otherwise
2729         // use null to indicate we didn't previously have a set maximum
2730         // size.
2731         Dimension old;
2732         if (maxSizeSet) {
2733             old = this.maxSize;
2734         }
2735         else {
2736             old = null;
2737         }
2738         this.maxSize = maximumSize;
2739         maxSizeSet = (maximumSize != null);
2740         firePropertyChange("maximumSize", old, maximumSize);
2741     }
2742 
2743     /**
2744      * Returns true if the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt;
2745      * value otherwise returns false.
2746      *
2747      * @return true if &lt;code&gt;maximumSize&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;,
2748      *          false otherwise
2749      * @since 1.5
2750      */
2751     public boolean isMaximumSizeSet() {
2752         return maxSizeSet;
2753     }
2754 
2755     /**
2756      * Gets the maximum size of this component.
2757      * @return a dimension object indicating this component's maximum size
2758      * @see #getMinimumSize
2759      * @see #getPreferredSize
2760      * @see LayoutManager
2761      */
2762     public Dimension getMaximumSize() {
2763         if (isMaximumSizeSet()) {
2764             return new Dimension(maxSize);
2765         }
2766         return new Dimension(Short.MAX_VALUE, Short.MAX_VALUE);
2767     }
2768 
2769     /**
2770      * Returns the alignment along the x axis.  This specifies how
2771      * the component would like to be aligned relative to other
2772      * components.  The value should be a number between 0 and 1
2773      * where 0 represents alignment along the origin, 1 is aligned
2774      * the furthest away from the origin, 0.5 is centered, etc.
2775      */
2776     public float getAlignmentX() {
2777         return CENTER_ALIGNMENT;
2778     }
2779 
2780     /**
2781      * Returns the alignment along the y axis.  This specifies how
2782      * the component would like to be aligned relative to other
2783      * components.  The value should be a number between 0 and 1
2784      * where 0 represents alignment along the origin, 1 is aligned
2785      * the furthest away from the origin, 0.5 is centered, etc.
2786      */
2787     public float getAlignmentY() {
2788         return CENTER_ALIGNMENT;
2789     }
2790 
2791     /**
2792      * Returns the baseline.  The baseline is measured from the top of
2793      * the component.  This method is primarily meant for
2794      * &lt;code&gt;LayoutManager&lt;/code&gt;s to align components along their
2795      * baseline.  A return value less than 0 indicates this component
2796      * does not have a reasonable baseline and that
2797      * &lt;code&gt;LayoutManager&lt;/code&gt;s should not align this component on
2798      * its baseline.
2799      * &lt;p&gt;
2800      * The default implementation returns -1.  Subclasses that support
2801      * baseline should override appropriately.  If a value &amp;gt;= 0 is
2802      * returned, then the component has a valid baseline for any
2803      * size &amp;gt;= the minimum size and &lt;code&gt;getBaselineResizeBehavior&lt;/code&gt;
2804      * can be used to determine how the baseline changes with size.
2805      *
2806      * @param width the width to get the baseline for
2807      * @param height the height to get the baseline for
2808      * @return the baseline or &amp;lt; 0 indicating there is no reasonable
2809      *         baseline
2810      * @throws IllegalArgumentException if width or height is &amp;lt; 0
2811      * @see #getBaselineResizeBehavior
2812      * @see java.awt.FontMetrics
2813      * @since 1.6
2814      */
2815     public int getBaseline(int width, int height) {
2816         if (width &lt; 0 || height &lt; 0) {
2817             throw new IllegalArgumentException(
2818                     "Width and height must be &gt;= 0");
2819         }
2820         return -1;
2821     }
2822 
2823     /**
2824      * Returns an enum indicating how the baseline of the component
2825      * changes as the size changes.  This method is primarily meant for
2826      * layout managers and GUI builders.
2827      * &lt;p&gt;
2828      * The default implementation returns
2829      * &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt;.  Subclasses that have a
2830      * baseline should override appropriately.  Subclasses should
2831      * never return &lt;code&gt;null&lt;/code&gt;; if the baseline can not be
2832      * calculated return &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt;.  Callers
2833      * should first ask for the baseline using
2834      * &lt;code&gt;getBaseline&lt;/code&gt; and if a value &amp;gt;= 0 is returned use
2835      * this method.  It is acceptable for this method to return a
2836      * value other than &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; even if
2837      * &lt;code&gt;getBaseline&lt;/code&gt; returns a value less than 0.
2838      *
2839      * @return an enum indicating how the baseline changes as the component
2840      *         size changes
2841      * @see #getBaseline(int, int)
2842      * @since 1.6
2843      */
2844     public BaselineResizeBehavior getBaselineResizeBehavior() {
2845         return BaselineResizeBehavior.OTHER;
2846     }
2847 
2848     /**
2849      * Prompts the layout manager to lay out this component. This is
2850      * usually called when the component (more specifically, container)
2851      * is validated.
2852      * @see #validate
2853      * @see LayoutManager
2854      */
2855     public void doLayout() {
2856         layout();
2857     }
2858 
2859     /**
2860      * @deprecated As of JDK version 1.1,
2861      * replaced by &lt;code&gt;doLayout()&lt;/code&gt;.
2862      */
2863     @Deprecated
2864     public void layout() {
2865     }
2866 
2867     /**
2868      * Validates this component.
2869      * &lt;p&gt;
2870      * The meaning of the term &lt;i&gt;validating&lt;/i&gt; is defined by the ancestors of
2871      * this class. See {@link Container#validate} for more details.
2872      *
2873      * @see       #invalidate
2874      * @see       #doLayout()
2875      * @see       LayoutManager
2876      * @see       Container#validate
2877      * @since     JDK1.0
2878      */
2879     public void validate() {
2880         synchronized (getTreeLock()) {
2881             ComponentPeer peer = this.peer;
2882             boolean wasValid = isValid();
2883             if (!wasValid &amp;&amp; peer != null) {
2884                 Font newfont = getFont();
2885                 Font oldfont = peerFont;
2886                 if (newfont != oldfont &amp;&amp; (oldfont == null
2887                                            || !oldfont.equals(newfont))) {
2888                     peer.setFont(newfont);
2889                     peerFont = newfont;
2890                 }
2891                 peer.layout();
2892             }
2893             valid = true;
2894             if (!wasValid) {
2895                 mixOnValidating();
2896             }
2897         }
2898     }
2899 
2900     /**
2901      * Invalidates this component and its ancestors.
2902      * &lt;p&gt;
2903      * By default, all the ancestors of the component up to the top-most
2904      * container of the hierarchy are marked invalid. If the {@code
2905      * java.awt.smartInvalidate} system property is set to {@code true},
2906      * invalidation stops on the nearest validate root of this component.
2907      * Marking a container &lt;i&gt;invalid&lt;/i&gt; indicates that the container needs to
2908      * be laid out.
2909      * &lt;p&gt;
2910      * This method is called automatically when any layout-related information
2911      * changes (e.g. setting the bounds of the component, or adding the
2912      * component to a container).
2913      * &lt;p&gt;
2914      * This method might be called often, so it should work fast.
2915      *
2916      * @see       #validate
2917      * @see       #doLayout
2918      * @see       LayoutManager
2919      * @see       java.awt.Container#isValidateRoot
2920      * @since     JDK1.0
2921      */
2922     public void invalidate() {
2923         synchronized (getTreeLock()) {
2924             /* Nullify cached layout and size information.
2925              * For efficiency, propagate invalidate() upwards only if
2926              * some other component hasn't already done so first.
2927              */
2928             valid = false;
2929             if (!isPreferredSizeSet()) {
2930                 prefSize = null;
2931             }
2932             if (!isMinimumSizeSet()) {
2933                 minSize = null;
2934             }
2935             if (!isMaximumSizeSet()) {
2936                 maxSize = null;
2937             }
2938             invalidateParent();
2939         }
2940     }
2941 
2942     /**
2943      * Invalidates the parent of this component if any.
2944      *
2945      * This method MUST BE invoked under the TreeLock.
2946      */
2947     void invalidateParent() {
2948         if (parent != null) {
2949             parent.invalidateIfValid();
2950         }
2951     }
2952 
2953     /** Invalidates the component unless it is already invalid.
2954      */
2955     final void invalidateIfValid() {
2956         if (isValid()) {
2957             invalidate();
2958         }
2959     }
2960 
2961     /**
2962      * Revalidates the component hierarchy up to the nearest validate root.
2963      * &lt;p&gt;
2964      * This method first invalidates the component hierarchy starting from this
2965      * component up to the nearest validate root. Afterwards, the component
2966      * hierarchy is validated starting from the nearest validate root.
2967      * &lt;p&gt;
2968      * This is a convenience method supposed to help application developers
2969      * avoid looking for validate roots manually. Basically, it's equivalent to
2970      * first calling the {@link #invalidate()} method on this component, and
2971      * then calling the {@link #validate()} method on the nearest validate
2972      * root.
2973      *
2974      * @see Container#isValidateRoot
2975      * @since 1.7
2976      */
2977     public void revalidate() {
2978         revalidateSynchronously();
2979     }
2980 
2981     /**
2982      * Revalidates the component synchronously.
2983      */
2984     final void revalidateSynchronously() {
2985         synchronized (getTreeLock()) {
2986             invalidate();
2987 
2988             Container root = getContainer();
2989             if (root == null) {
2990                 // There's no parents. Just validate itself.
2991                 validate();
2992             } else {
2993                 while (!root.isValidateRoot()) {
2994                     if (root.getContainer() == null) {
2995                         // If there's no validate roots, we'll validate the
2996                         // topmost container
2997                         break;
2998                     }
2999 
3000                     root = root.getContainer();
3001                 }
3002 
3003                 root.validate();
3004             }
3005         }
3006     }
3007 
3008     /**
3009      * Creates a graphics context for this component. This method will
3010      * return &lt;code&gt;null&lt;/code&gt; if this component is currently not
3011      * displayable.
3012      * @return a graphics context for this component, or &lt;code&gt;null&lt;/code&gt;
3013      *             if it has none
3014      * @see       #paint
3015      * @since     JDK1.0
3016      */
3017     public Graphics getGraphics() {
3018         if (peer instanceof LightweightPeer) {
3019             // This is for a lightweight component, need to
3020             // translate coordinate spaces and clip relative
3021             // to the parent.
3022             if (parent == null) return null;
3023             Graphics g = parent.getGraphics();
3024             if (g == null) return null;
3025             if (g instanceof ConstrainableGraphics) {
3026                 ((ConstrainableGraphics) g).constrain(x, y, width, height);
3027             } else {
3028                 g.translate(x,y);
3029                 g.setClip(0, 0, width, height);
3030             }
3031             g.setFont(getFont());
3032             return g;
3033         } else {
3034             ComponentPeer peer = this.peer;
3035             return (peer != null) ? peer.getGraphics() : null;
3036         }
3037     }
3038 
3039     final Graphics getGraphics_NoClientCode() {
3040         ComponentPeer peer = this.peer;
3041         if (peer instanceof LightweightPeer) {
3042             // This is for a lightweight component, need to
3043             // translate coordinate spaces and clip relative
3044             // to the parent.
3045             Container parent = this.parent;
3046             if (parent == null) return null;
3047             Graphics g = parent.getGraphics_NoClientCode();
3048             if (g == null) return null;
3049             if (g instanceof ConstrainableGraphics) {
3050                 ((ConstrainableGraphics) g).constrain(x, y, width, height);
3051             } else {
3052                 g.translate(x,y);
3053                 g.setClip(0, 0, width, height);
3054             }
3055             g.setFont(getFont_NoClientCode());
3056             return g;
3057         } else {
3058             return (peer != null) ? peer.getGraphics() : null;
3059         }
3060     }
3061 
3062     /**
3063      * Gets the font metrics for the specified font.
3064      * Warning: Since Font metrics are affected by the
3065      * {@link java.awt.font.FontRenderContext FontRenderContext} and
3066      * this method does not provide one, it can return only metrics for
3067      * the default render context which may not match that used when
3068      * rendering on the Component if {@link Graphics2D} functionality is being
3069      * used. Instead metrics can be obtained at rendering time by calling
3070      * {@link Graphics#getFontMetrics()} or text measurement APIs on the
3071      * {@link Font Font} class.
3072      * @param font the font for which font metrics is to be
3073      *          obtained
3074      * @return the font metrics for &lt;code&gt;font&lt;/code&gt;
3075      * @see       #getFont
3076      * @see       #getPeer
3077      * @see       java.awt.peer.ComponentPeer#getFontMetrics(Font)
3078      * @see       Toolkit#getFontMetrics(Font)
3079      * @since     JDK1.0
3080      */
3081     public FontMetrics getFontMetrics(Font font) {
3082         // This is an unsupported hack, but left in for a customer.
3083         // Do not remove.
3084         FontManager fm = FontManagerFactory.getInstance();
3085         if (fm instanceof SunFontManager
3086             &amp;&amp; ((SunFontManager) fm).usePlatformFontMetrics()) {
3087 
3088             if (peer != null &amp;&amp;
3089                 !(peer instanceof LightweightPeer)) {
3090                 return peer.getFontMetrics(font);
3091             }
3092         }
3093         return sun.font.FontDesignMetrics.getMetrics(font);
3094     }
3095 
3096     /**
3097      * Sets the cursor image to the specified cursor.  This cursor
3098      * image is displayed when the &lt;code&gt;contains&lt;/code&gt; method for
3099      * this component returns true for the current cursor location, and
3100      * this Component is visible, displayable, and enabled. Setting the
3101      * cursor of a &lt;code&gt;Container&lt;/code&gt; causes that cursor to be displayed
3102      * within all of the container's subcomponents, except for those
3103      * that have a non-&lt;code&gt;null&lt;/code&gt; cursor.
3104      * &lt;p&gt;
3105      * The method may have no visual effect if the Java platform
3106      * implementation and/or the native system do not support
3107      * changing the mouse cursor shape.
3108      * @param cursor One of the constants defined
3109      *          by the &lt;code&gt;Cursor&lt;/code&gt; class;
3110      *          if this parameter is &lt;code&gt;null&lt;/code&gt;
3111      *          then this component will inherit
3112      *          the cursor of its parent
3113      * @see       #isEnabled
3114      * @see       #isShowing
3115      * @see       #getCursor
3116      * @see       #contains
3117      * @see       Toolkit#createCustomCursor
3118      * @see       Cursor
3119      * @since     JDK1.1
3120      */
3121     public void setCursor(Cursor cursor) {
3122         this.cursor = cursor;
3123         updateCursorImmediately();
3124     }
3125 
3126     /**
3127      * Updates the cursor.  May not be invoked from the native
3128      * message pump.
3129      */
3130     final void updateCursorImmediately() {
3131         if (peer instanceof LightweightPeer) {
3132             Container nativeContainer = getNativeContainer();
3133 
3134             if (nativeContainer == null) return;
3135 
3136             ComponentPeer cPeer = nativeContainer.getPeer();
3137 
3138             if (cPeer != null) {
3139                 cPeer.updateCursorImmediately();
3140             }
3141         } else if (peer != null) {
3142             peer.updateCursorImmediately();
3143         }
3144     }
3145 
3146     /**
3147      * Gets the cursor set in the component. If the component does
3148      * not have a cursor set, the cursor of its parent is returned.
3149      * If no cursor is set in the entire hierarchy,
3150      * &lt;code&gt;Cursor.DEFAULT_CURSOR&lt;/code&gt; is returned.
3151      * @see #setCursor
3152      * @since      JDK1.1
3153      */
3154     public Cursor getCursor() {
3155         return getCursor_NoClientCode();
3156     }
3157 
3158     final Cursor getCursor_NoClientCode() {
3159         Cursor cursor = this.cursor;
3160         if (cursor != null) {
3161             return cursor;
3162         }
3163         Container parent = this.parent;
3164         if (parent != null) {
3165             return parent.getCursor_NoClientCode();
3166         } else {
3167             return Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
3168         }
3169     }
3170 
3171     /**
3172      * Returns whether the cursor has been explicitly set for this Component.
3173      * If this method returns &lt;code&gt;false&lt;/code&gt;, this Component is inheriting
3174      * its cursor from an ancestor.
3175      *
3176      * @return &lt;code&gt;true&lt;/code&gt; if the cursor has been explicitly set for this
3177      *         Component; &lt;code&gt;false&lt;/code&gt; otherwise.
3178      * @since 1.4
3179      */
3180     public boolean isCursorSet() {
3181         return (cursor != null);
3182     }
3183 
3184     /**
3185      * Paints this component.
3186      * &lt;p&gt;
3187      * This method is called when the contents of the component should
3188      * be painted; such as when the component is first being shown or
3189      * is damaged and in need of repair.  The clip rectangle in the
3190      * &lt;code&gt;Graphics&lt;/code&gt; parameter is set to the area
3191      * which needs to be painted.
3192      * Subclasses of &lt;code&gt;Component&lt;/code&gt; that override this
3193      * method need not call &lt;code&gt;super.paint(g)&lt;/code&gt;.
3194      * &lt;p&gt;
3195      * For performance reasons, &lt;code&gt;Component&lt;/code&gt;s with zero width
3196      * or height aren't considered to need painting when they are first shown,
3197      * and also aren't considered to need repair.
3198      * &lt;p&gt;
3199      * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
3200      * by AWT and Swing, including information on how to write the most
3201      * efficient painting code, see
3202      * &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
3203      *
3204      * @param g the graphics context to use for painting
3205      * @see       #update
3206      * @since     JDK1.0
3207      */
3208     public void paint(Graphics g) {
3209     }
3210 
3211     /**
3212      * Updates this component.
3213      * &lt;p&gt;
3214      * If this component is not a lightweight component, the
3215      * AWT calls the &lt;code&gt;update&lt;/code&gt; method in response to
3216      * a call to &lt;code&gt;repaint&lt;/code&gt;.  You can assume that
3217      * the background is not cleared.
3218      * &lt;p&gt;
3219      * The &lt;code&gt;update&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;
3220      * calls this component's &lt;code&gt;paint&lt;/code&gt; method to redraw
3221      * this component.  This method is commonly overridden by subclasses
3222      * which need to do additional work in response to a call to
3223      * &lt;code&gt;repaint&lt;/code&gt;.
3224      * Subclasses of Component that override this method should either
3225      * call &lt;code&gt;super.update(g)&lt;/code&gt;, or call &lt;code&gt;paint(g)&lt;/code&gt;
3226      * directly from their &lt;code&gt;update&lt;/code&gt; method.
3227      * &lt;p&gt;
3228      * The origin of the graphics context, its
3229      * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
3230      * top-left corner of this component. The clipping region of the
3231      * graphics context is the bounding rectangle of this component.
3232      *
3233      * &lt;p&gt;
3234      * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
3235      * by AWT and Swing, including information on how to write the most
3236      * efficient painting code, see
3237      * &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
3238      *
3239      * @param g the specified context to use for updating
3240      * @see       #paint
3241      * @see       #repaint()
3242      * @since     JDK1.0
3243      */
3244     public void update(Graphics g) {
3245         paint(g);
3246     }
3247 
3248     /**
3249      * Paints this component and all of its subcomponents.
3250      * &lt;p&gt;
3251      * The origin of the graphics context, its
3252      * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
3253      * top-left corner of this component. The clipping region of the
3254      * graphics context is the bounding rectangle of this component.
3255      *
3256      * @param     g   the graphics context to use for painting
3257      * @see       #paint
3258      * @since     JDK1.0
3259      */
3260     public void paintAll(Graphics g) {
3261         if (isShowing()) {
3262             GraphicsCallback.PeerPaintCallback.getInstance().
3263                 runOneComponent(this, new Rectangle(0, 0, width, height),
3264                                 g, g.getClip(),
3265                                 GraphicsCallback.LIGHTWEIGHTS |
3266                                 GraphicsCallback.HEAVYWEIGHTS);
3267         }
3268     }
3269 
3270     /**
3271      * Simulates the peer callbacks into java.awt for painting of
3272      * lightweight Components.
3273      * @param     g   the graphics context to use for painting
3274      * @see       #paintAll
3275      */
3276     void lightweightPaint(Graphics g) {
3277         paint(g);
3278     }
3279 
3280     /**
3281      * Paints all the heavyweight subcomponents.
3282      */
3283     void paintHeavyweightComponents(Graphics g) {
3284     }
3285 
3286     /**
3287      * Repaints this component.
3288      * &lt;p&gt;
3289      * If this component is a lightweight component, this method
3290      * causes a call to this component's &lt;code&gt;paint&lt;/code&gt;
3291      * method as soon as possible.  Otherwise, this method causes
3292      * a call to this component's &lt;code&gt;update&lt;/code&gt; method as soon
3293      * as possible.
3294      * &lt;p&gt;
3295      * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
3296      * by AWT and Swing, including information on how to write the most
3297      * efficient painting code, see
3298      * &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
3299 
3300      *
3301      * @see       #update(Graphics)
3302      * @since     JDK1.0
3303      */
3304     public void repaint() {
3305         repaint(0, 0, 0, width, height);
3306     }
3307 
3308     /**
3309      * Repaints the component.  If this component is a lightweight
3310      * component, this results in a call to &lt;code&gt;paint&lt;/code&gt;
3311      * within &lt;code&gt;tm&lt;/code&gt; milliseconds.
3312      * &lt;p&gt;
3313      * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
3314      * by AWT and Swing, including information on how to write the most
3315      * efficient painting code, see
3316      * &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
3317      *
3318      * @param tm maximum time in milliseconds before update
3319      * @see #paint
3320      * @see #update(Graphics)
3321      * @since JDK1.0
3322      */
3323     public void repaint(long tm) {
3324         repaint(tm, 0, 0, width, height);
3325     }
3326 
3327     /**
3328      * Repaints the specified rectangle of this component.
3329      * &lt;p&gt;
3330      * If this component is a lightweight component, this method
3331      * causes a call to this component's &lt;code&gt;paint&lt;/code&gt; method
3332      * as soon as possible.  Otherwise, this method causes a call to
3333      * this component's &lt;code&gt;update&lt;/code&gt; method as soon as possible.
3334      * &lt;p&gt;
3335      * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
3336      * by AWT and Swing, including information on how to write the most
3337      * efficient painting code, see
3338      * &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
3339      *
3340      * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate
3341      * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate
3342      * @param     width   the width
3343      * @param     height  the height
3344      * @see       #update(Graphics)
3345      * @since     JDK1.0
3346      */
3347     public void repaint(int x, int y, int width, int height) {
3348         repaint(0, x, y, width, height);
3349     }
3350 
3351     /**
3352      * Repaints the specified rectangle of this component within
3353      * &lt;code&gt;tm&lt;/code&gt; milliseconds.
3354      * &lt;p&gt;
3355      * If this component is a lightweight component, this method causes
3356      * a call to this component's &lt;code&gt;paint&lt;/code&gt; method.
3357      * Otherwise, this method causes a call to this component's
3358      * &lt;code&gt;update&lt;/code&gt; method.
3359      * &lt;p&gt;
3360      * &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilitized
3361      * by AWT and Swing, including information on how to write the most
3362      * efficient painting code, see
3363      * &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
3364      *
3365      * @param     tm   maximum time in milliseconds before update
3366      * @param     x    the &lt;i&gt;x&lt;/i&gt; coordinate
3367      * @param     y    the &lt;i&gt;y&lt;/i&gt; coordinate
3368      * @param     width    the width
3369      * @param     height   the height
3370      * @see       #update(Graphics)
3371      * @since     JDK1.0
3372      */
3373     public void repaint(long tm, int x, int y, int width, int height) {
3374         if (this.peer instanceof LightweightPeer) {
3375             // Needs to be translated to parent coordinates since
3376             // a parent native container provides the actual repaint
3377             // services.  Additionally, the request is restricted to
3378             // the bounds of the component.
3379             if (parent != null) {
3380                 if (x &lt; 0) {
3381                     width += x;
3382                     x = 0;
3383                 }
3384                 if (y &lt; 0) {
3385                     height += y;
3386                     y = 0;
3387                 }
3388 
3389                 int pwidth = (width &gt; this.width) ? this.width : width;
3390                 int pheight = (height &gt; this.height) ? this.height : height;
3391 
3392                 if (pwidth &lt;= 0 || pheight &lt;= 0) {
3393                     return;
3394                 }
3395 
3396                 int px = this.x + x;
3397                 int py = this.y + y;
3398                 parent.repaint(tm, px, py, pwidth, pheight);
3399             }
3400         } else {
3401             if (isVisible() &amp;&amp; (this.peer != null) &amp;&amp;
3402                 (width &gt; 0) &amp;&amp; (height &gt; 0)) {
3403                 PaintEvent e = new PaintEvent(this, PaintEvent.UPDATE,
3404                                               new Rectangle(x, y, width, height));
3405                 Toolkit.getEventQueue().postEvent(e);
<a name="1" id="anc1"></a><span class="new">3406                 Toolkit.getDefaultToolkit().sync();    </span>
3407             }
3408         }
3409     }
3410 
3411     /**
3412      * Prints this component. Applications should override this method
3413      * for components that must do special processing before being
3414      * printed or should be printed differently than they are painted.
3415      * &lt;p&gt;
3416      * The default implementation of this method calls the
3417      * &lt;code&gt;paint&lt;/code&gt; method.
3418      * &lt;p&gt;
3419      * The origin of the graphics context, its
3420      * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
3421      * top-left corner of this component. The clipping region of the
3422      * graphics context is the bounding rectangle of this component.
3423      * @param     g   the graphics context to use for printing
3424      * @see       #paint(Graphics)
3425      * @since     JDK1.0
3426      */
3427     public void print(Graphics g) {
3428         paint(g);
3429     }
3430 
3431     /**
3432      * Prints this component and all of its subcomponents.
3433      * &lt;p&gt;
3434      * The origin of the graphics context, its
3435      * (&lt;code&gt;0&lt;/code&gt;,&amp;nbsp;&lt;code&gt;0&lt;/code&gt;) coordinate point, is the
3436      * top-left corner of this component. The clipping region of the
3437      * graphics context is the bounding rectangle of this component.
3438      * @param     g   the graphics context to use for printing
3439      * @see       #print(Graphics)
3440      * @since     JDK1.0
3441      */
3442     public void printAll(Graphics g) {
3443         if (isShowing()) {
3444             GraphicsCallback.PeerPrintCallback.getInstance().
3445                 runOneComponent(this, new Rectangle(0, 0, width, height),
3446                                 g, g.getClip(),
3447                                 GraphicsCallback.LIGHTWEIGHTS |
3448                                 GraphicsCallback.HEAVYWEIGHTS);
3449         }
3450     }
3451 
3452     /**
3453      * Simulates the peer callbacks into java.awt for printing of
3454      * lightweight Components.
3455      * @param     g   the graphics context to use for printing
3456      * @see       #printAll
3457      */
3458     void lightweightPrint(Graphics g) {
3459         print(g);
3460     }
3461 
3462     /**
3463      * Prints all the heavyweight subcomponents.
3464      */
3465     void printHeavyweightComponents(Graphics g) {
3466     }
3467 
3468     private Insets getInsets_NoClientCode() {
3469         ComponentPeer peer = this.peer;
3470         if (peer instanceof ContainerPeer) {
3471             return (Insets)((ContainerPeer)peer).getInsets().clone();
3472         }
3473         return new Insets(0, 0, 0, 0);
3474     }
3475 
3476     /**
3477      * Repaints the component when the image has changed.
3478      * This &lt;code&gt;imageUpdate&lt;/code&gt; method of an &lt;code&gt;ImageObserver&lt;/code&gt;
3479      * is called when more information about an
3480      * image which had been previously requested using an asynchronous
3481      * routine such as the &lt;code&gt;drawImage&lt;/code&gt; method of
3482      * &lt;code&gt;Graphics&lt;/code&gt; becomes available.
3483      * See the definition of &lt;code&gt;imageUpdate&lt;/code&gt; for
3484      * more information on this method and its arguments.
3485      * &lt;p&gt;
3486      * The &lt;code&gt;imageUpdate&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;
3487      * incrementally draws an image on the component as more of the bits
3488      * of the image are available.
3489      * &lt;p&gt;
3490      * If the system property &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt;
3491      * is missing or has the value &lt;code&gt;true&lt;/code&gt;, the image is
3492      * incrementally drawn. If the system property has any other value,
3493      * then the image is not drawn until it has been completely loaded.
3494      * &lt;p&gt;
3495      * Also, if incremental drawing is in effect, the value of the
3496      * system property &lt;code&gt;awt.image.redrawrate&lt;/code&gt; is interpreted
3497      * as an integer to give the maximum redraw rate, in milliseconds. If
3498      * the system property is missing or cannot be interpreted as an
3499      * integer, the redraw rate is once every 100ms.
3500      * &lt;p&gt;
3501      * The interpretation of the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;,
3502      * &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt; arguments depends on
3503      * the value of the &lt;code&gt;infoflags&lt;/code&gt; argument.
3504      *
3505      * @param     img   the image being observed
3506      * @param     infoflags   see &lt;code&gt;imageUpdate&lt;/code&gt; for more information
3507      * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate
3508      * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate
3509      * @param     w   the width
3510      * @param     h   the height
3511      * @return    &lt;code&gt;false&lt;/code&gt; if the infoflags indicate that the
3512      *            image is completely loaded; &lt;code&gt;true&lt;/code&gt; otherwise.
3513      *
3514      * @see     java.awt.image.ImageObserver
3515      * @see     Graphics#drawImage(Image, int, int, Color, java.awt.image.ImageObserver)
3516      * @see     Graphics#drawImage(Image, int, int, java.awt.image.ImageObserver)
3517      * @see     Graphics#drawImage(Image, int, int, int, int, Color, java.awt.image.ImageObserver)
3518      * @see     Graphics#drawImage(Image, int, int, int, int, java.awt.image.ImageObserver)
3519      * @see     java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)
3520      * @since   JDK1.0
3521      */
3522     public boolean imageUpdate(Image img, int infoflags,
3523                                int x, int y, int w, int h) {
3524         int rate = -1;
3525         if ((infoflags &amp; (FRAMEBITS|ALLBITS)) != 0) {
3526             rate = 0;
3527         } else if ((infoflags &amp; SOMEBITS) != 0) {
3528             if (isInc) {
3529                 rate = incRate;
3530                 if (rate &lt; 0) {
3531                     rate = 0;
3532                 }
3533             }
3534         }
3535         if (rate &gt;= 0) {
3536             repaint(rate, 0, 0, width, height);
3537         }
3538         return (infoflags &amp; (ALLBITS|ABORT)) == 0;
3539     }
3540 
3541     /**
3542      * Creates an image from the specified image producer.
3543      * @param     producer  the image producer
3544      * @return    the image produced
3545      * @since     JDK1.0
3546      */
3547     public Image createImage(ImageProducer producer) {
3548         ComponentPeer peer = this.peer;
3549         if ((peer != null) &amp;&amp; ! (peer instanceof LightweightPeer)) {
3550             return peer.createImage(producer);
3551         }
3552         return getToolkit().createImage(producer);
3553     }
3554 
3555     /**
3556      * Creates an off-screen drawable image
3557      *     to be used for double buffering.
3558      * @param     width the specified width
3559      * @param     height the specified height
3560      * @return    an off-screen drawable image, which can be used for double
3561      *    buffering.  The return value may be &lt;code&gt;null&lt;/code&gt; if the
3562      *    component is not displayable.  This will always happen if
3563      *    &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt; returns
3564      *    &lt;code&gt;true&lt;/code&gt;.
3565      * @see #isDisplayable
3566      * @see GraphicsEnvironment#isHeadless
3567      * @since     JDK1.0
3568      */
3569     public Image createImage(int width, int height) {
3570         ComponentPeer peer = this.peer;
3571         if (peer instanceof LightweightPeer) {
3572             if (parent != null) { return parent.createImage(width, height); }
3573             else { return null;}
3574         } else {
3575             return (peer != null) ? peer.createImage(width, height) : null;
3576         }
3577     }
3578 
3579     /**
3580      * Creates a volatile off-screen drawable image
3581      *     to be used for double buffering.
3582      * @param     width the specified width.
3583      * @param     height the specified height.
3584      * @return    an off-screen drawable image, which can be used for double
3585      *    buffering.  The return value may be &lt;code&gt;null&lt;/code&gt; if the
3586      *    component is not displayable.  This will always happen if
3587      *    &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt; returns
3588      *    &lt;code&gt;true&lt;/code&gt;.
3589      * @see java.awt.image.VolatileImage
3590      * @see #isDisplayable
3591      * @see GraphicsEnvironment#isHeadless
3592      * @since     1.4
3593      */
3594     public VolatileImage createVolatileImage(int width, int height) {
3595         ComponentPeer peer = this.peer;
3596         if (peer instanceof LightweightPeer) {
3597             if (parent != null) {
3598                 return parent.createVolatileImage(width, height);
3599             }
3600             else { return null;}
3601         } else {
3602             return (peer != null) ?
3603                 peer.createVolatileImage(width, height) : null;
3604         }
3605     }
3606 
3607     /**
3608      * Creates a volatile off-screen drawable image, with the given capabilities.
3609      * The contents of this image may be lost at any time due
3610      * to operating system issues, so the image must be managed
3611      * via the &lt;code&gt;VolatileImage&lt;/code&gt; interface.
3612      * @param width the specified width.
3613      * @param height the specified height.
3614      * @param caps the image capabilities
3615      * @exception AWTException if an image with the specified capabilities cannot
3616      * be created
3617      * @return a VolatileImage object, which can be used
3618      * to manage surface contents loss and capabilities.
3619      * @see java.awt.image.VolatileImage
3620      * @since 1.4
3621      */
3622     public VolatileImage createVolatileImage(int width, int height,
3623                                              ImageCapabilities caps) throws AWTException {
3624         // REMIND : check caps
3625         return createVolatileImage(width, height);
3626     }
3627 
3628     /**
3629      * Prepares an image for rendering on this component.  The image
3630      * data is downloaded asynchronously in another thread and the
3631      * appropriate screen representation of the image is generated.
3632      * @param     image   the &lt;code&gt;Image&lt;/code&gt; for which to
3633      *                    prepare a screen representation
3634      * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt; object
3635      *                       to be notified as the image is being prepared
3636      * @return    &lt;code&gt;true&lt;/code&gt; if the image has already been fully
3637      *           prepared; &lt;code&gt;false&lt;/code&gt; otherwise
3638      * @since     JDK1.0
3639      */
3640     public boolean prepareImage(Image image, ImageObserver observer) {
3641         return prepareImage(image, -1, -1, observer);
3642     }
3643 
3644     /**
3645      * Prepares an image for rendering on this component at the
3646      * specified width and height.
3647      * &lt;p&gt;
3648      * The image data is downloaded asynchronously in another thread,
3649      * and an appropriately scaled screen representation of the image is
3650      * generated.
3651      * @param     image    the instance of &lt;code&gt;Image&lt;/code&gt;
3652      *            for which to prepare a screen representation
3653      * @param     width    the width of the desired screen representation
3654      * @param     height   the height of the desired screen representation
3655      * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt; object
3656      *            to be notified as the image is being prepared
3657      * @return    &lt;code&gt;true&lt;/code&gt; if the image has already been fully
3658      *          prepared; &lt;code&gt;false&lt;/code&gt; otherwise
3659      * @see       java.awt.image.ImageObserver
3660      * @since     JDK1.0
3661      */
3662     public boolean prepareImage(Image image, int width, int height,
3663                                 ImageObserver observer) {
3664         ComponentPeer peer = this.peer;
3665         if (peer instanceof LightweightPeer) {
3666             return (parent != null)
3667                 ? parent.prepareImage(image, width, height, observer)
3668                 : getToolkit().prepareImage(image, width, height, observer);
3669         } else {
3670             return (peer != null)
3671                 ? peer.prepareImage(image, width, height, observer)
3672                 : getToolkit().prepareImage(image, width, height, observer);
3673         }
3674     }
3675 
3676     /**
3677      * Returns the status of the construction of a screen representation
3678      * of the specified image.
3679      * &lt;p&gt;
3680      * This method does not cause the image to begin loading. An
3681      * application must use the &lt;code&gt;prepareImage&lt;/code&gt; method
3682      * to force the loading of an image.
3683      * &lt;p&gt;
3684      * Information on the flags returned by this method can be found
3685      * with the discussion of the &lt;code&gt;ImageObserver&lt;/code&gt; interface.
3686      * @param     image   the &lt;code&gt;Image&lt;/code&gt; object whose status
3687      *            is being checked
3688      * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt;
3689      *            object to be notified as the image is being prepared
3690      * @return  the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
3691      *            &lt;code&gt;ImageObserver&lt;/code&gt; flags indicating what
3692      *            information about the image is currently available
3693      * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
3694      * @see      Toolkit#checkImage(Image, int, int, java.awt.image.ImageObserver)
3695      * @see      java.awt.image.ImageObserver
3696      * @since    JDK1.0
3697      */
3698     public int checkImage(Image image, ImageObserver observer) {
3699         return checkImage(image, -1, -1, observer);
3700     }
3701 
3702     /**
3703      * Returns the status of the construction of a screen representation
3704      * of the specified image.
3705      * &lt;p&gt;
3706      * This method does not cause the image to begin loading. An
3707      * application must use the &lt;code&gt;prepareImage&lt;/code&gt; method
3708      * to force the loading of an image.
3709      * &lt;p&gt;
3710      * The &lt;code&gt;checkImage&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt;
3711      * calls its peer's &lt;code&gt;checkImage&lt;/code&gt; method to calculate
3712      * the flags. If this component does not yet have a peer, the
3713      * component's toolkit's &lt;code&gt;checkImage&lt;/code&gt; method is called
3714      * instead.
3715      * &lt;p&gt;
3716      * Information on the flags returned by this method can be found
3717      * with the discussion of the &lt;code&gt;ImageObserver&lt;/code&gt; interface.
3718      * @param     image   the &lt;code&gt;Image&lt;/code&gt; object whose status
3719      *                    is being checked
3720      * @param     width   the width of the scaled version
3721      *                    whose status is to be checked
3722      * @param     height  the height of the scaled version
3723      *                    whose status is to be checked
3724      * @param     observer   the &lt;code&gt;ImageObserver&lt;/code&gt; object
3725      *                    to be notified as the image is being prepared
3726      * @return    the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
3727      *            &lt;code&gt;ImageObserver&lt;/code&gt; flags indicating what
3728      *            information about the image is currently available
3729      * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
3730      * @see      Toolkit#checkImage(Image, int, int, java.awt.image.ImageObserver)
3731      * @see      java.awt.image.ImageObserver
3732      * @since    JDK1.0
3733      */
3734     public int checkImage(Image image, int width, int height,
3735                           ImageObserver observer) {
3736         ComponentPeer peer = this.peer;
3737         if (peer instanceof LightweightPeer) {
3738             return (parent != null)
3739                 ? parent.checkImage(image, width, height, observer)
3740                 : getToolkit().checkImage(image, width, height, observer);
3741         } else {
3742             return (peer != null)
3743                 ? peer.checkImage(image, width, height, observer)
3744                 : getToolkit().checkImage(image, width, height, observer);
3745         }
3746     }
3747 
3748     /**
3749      * Creates a new strategy for multi-buffering on this component.
3750      * Multi-buffering is useful for rendering performance.  This method
3751      * attempts to create the best strategy available with the number of
3752      * buffers supplied.  It will always create a &lt;code&gt;BufferStrategy&lt;/code&gt;
3753      * with that number of buffers.
3754      * A page-flipping strategy is attempted first, then a blitting strategy
3755      * using accelerated buffers.  Finally, an unaccelerated blitting
3756      * strategy is used.
3757      * &lt;p&gt;
3758      * Each time this method is called,
3759      * the existing buffer strategy for this component is discarded.
3760      * @param numBuffers number of buffers to create, including the front buffer
3761      * @exception IllegalArgumentException if numBuffers is less than 1.
3762      * @exception IllegalStateException if the component is not displayable
3763      * @see #isDisplayable
3764      * @see Window#getBufferStrategy()
3765      * @see Canvas#getBufferStrategy()
3766      * @since 1.4
3767      */
3768     void createBufferStrategy(int numBuffers) {
3769         BufferCapabilities bufferCaps;
3770         if (numBuffers &gt; 1) {
3771             // Try to create a page-flipping strategy
3772             bufferCaps = new BufferCapabilities(new ImageCapabilities(true),
3773                                                 new ImageCapabilities(true),
3774                                                 BufferCapabilities.FlipContents.UNDEFINED);
3775             try {
3776                 createBufferStrategy(numBuffers, bufferCaps);
3777                 return; // Success
3778             } catch (AWTException e) {
3779                 // Failed
3780             }
3781         }
3782         // Try a blitting (but still accelerated) strategy
3783         bufferCaps = new BufferCapabilities(new ImageCapabilities(true),
3784                                             new ImageCapabilities(true),
3785                                             null);
3786         try {
3787             createBufferStrategy(numBuffers, bufferCaps);
3788             return; // Success
3789         } catch (AWTException e) {
3790             // Failed
3791         }
3792         // Try an unaccelerated blitting strategy
3793         bufferCaps = new BufferCapabilities(new ImageCapabilities(false),
3794                                             new ImageCapabilities(false),
3795                                             null);
3796         try {
3797             createBufferStrategy(numBuffers, bufferCaps);
3798             return; // Success
3799         } catch (AWTException e) {
3800             // Code should never reach here (an unaccelerated blitting
3801             // strategy should always work)
3802             throw new InternalError("Could not create a buffer strategy", e);
3803         }
3804     }
3805 
3806     /**
3807      * Creates a new strategy for multi-buffering on this component with the
3808      * required buffer capabilities.  This is useful, for example, if only
3809      * accelerated memory or page flipping is desired (as specified by the
3810      * buffer capabilities).
3811      * &lt;p&gt;
3812      * Each time this method
3813      * is called, &lt;code&gt;dispose&lt;/code&gt; will be invoked on the existing
3814      * &lt;code&gt;BufferStrategy&lt;/code&gt;.
3815      * @param numBuffers number of buffers to create
3816      * @param caps the required capabilities for creating the buffer strategy;
3817      * cannot be &lt;code&gt;null&lt;/code&gt;
3818      * @exception AWTException if the capabilities supplied could not be
3819      * supported or met; this may happen, for example, if there is not enough
3820      * accelerated memory currently available, or if page flipping is specified
3821      * but not possible.
3822      * @exception IllegalArgumentException if numBuffers is less than 1, or if
3823      * caps is &lt;code&gt;null&lt;/code&gt;
3824      * @see Window#getBufferStrategy()
3825      * @see Canvas#getBufferStrategy()
3826      * @since 1.4
3827      */
3828     void createBufferStrategy(int numBuffers,
3829                               BufferCapabilities caps) throws AWTException {
3830         // Check arguments
3831         if (numBuffers &lt; 1) {
3832             throw new IllegalArgumentException(
3833                 "Number of buffers must be at least 1");
3834         }
3835         if (caps == null) {
3836             throw new IllegalArgumentException("No capabilities specified");
3837         }
3838         // Destroy old buffers
3839         if (bufferStrategy != null) {
3840             bufferStrategy.dispose();
3841         }
3842         if (numBuffers == 1) {
3843             bufferStrategy = new SingleBufferStrategy(caps);
3844         } else {
3845             SunGraphicsEnvironment sge = (SunGraphicsEnvironment)
3846                 GraphicsEnvironment.getLocalGraphicsEnvironment();
3847             if (!caps.isPageFlipping() &amp;&amp; sge.isFlipStrategyPreferred(peer)) {
3848                 caps = new ProxyCapabilities(caps);
3849             }
3850             // assert numBuffers &gt; 1;
3851             if (caps.isPageFlipping()) {
3852                 bufferStrategy = new FlipSubRegionBufferStrategy(numBuffers, caps);
3853             } else {
3854                 bufferStrategy = new BltSubRegionBufferStrategy(numBuffers, caps);
3855             }
3856         }
3857     }
3858 
3859     /**
3860      * This is a proxy capabilities class used when a FlipBufferStrategy
3861      * is created instead of the requested Blit strategy.
3862      *
3863      * @see sun.java2d.SunGraphicsEnvironment#isFlipStrategyPreferred(ComponentPeer)
3864      */
3865     private class ProxyCapabilities extends ExtendedBufferCapabilities {
3866         private BufferCapabilities orig;
3867         private ProxyCapabilities(BufferCapabilities orig) {
3868             super(orig.getFrontBufferCapabilities(),
3869                   orig.getBackBufferCapabilities(),
3870                   orig.getFlipContents() ==
3871                       BufferCapabilities.FlipContents.BACKGROUND ?
3872                       BufferCapabilities.FlipContents.BACKGROUND :
3873                       BufferCapabilities.FlipContents.COPIED);
3874             this.orig = orig;
3875         }
3876     }
3877 
3878     /**
3879      * @return the buffer strategy used by this component
3880      * @see Window#createBufferStrategy
3881      * @see Canvas#createBufferStrategy
3882      * @since 1.4
3883      */
3884     BufferStrategy getBufferStrategy() {
3885         return bufferStrategy;
3886     }
3887 
3888     /**
3889      * @return the back buffer currently used by this component's
3890      * BufferStrategy.  If there is no BufferStrategy or no
3891      * back buffer, this method returns null.
3892      */
3893     Image getBackBuffer() {
3894         if (bufferStrategy != null) {
3895             if (bufferStrategy instanceof BltBufferStrategy) {
3896                 BltBufferStrategy bltBS = (BltBufferStrategy)bufferStrategy;
3897                 return bltBS.getBackBuffer();
3898             } else if (bufferStrategy instanceof FlipBufferStrategy) {
3899                 FlipBufferStrategy flipBS = (FlipBufferStrategy)bufferStrategy;
3900                 return flipBS.getBackBuffer();
3901             }
3902         }
3903         return null;
3904     }
3905 
3906     /**
3907      * Inner class for flipping buffers on a component.  That component must
3908      * be a &lt;code&gt;Canvas&lt;/code&gt; or &lt;code&gt;Window&lt;/code&gt;.
3909      * @see Canvas
3910      * @see Window
3911      * @see java.awt.image.BufferStrategy
3912      * @author Michael Martak
3913      * @since 1.4
3914      */
3915     protected class FlipBufferStrategy extends BufferStrategy {
3916         /**
3917          * The number of buffers
3918          */
3919         protected int numBuffers; // = 0
3920         /**
3921          * The buffering capabilities
3922          */
3923         protected BufferCapabilities caps; // = null
3924         /**
3925          * The drawing buffer
3926          */
3927         protected Image drawBuffer; // = null
3928         /**
3929          * The drawing buffer as a volatile image
3930          */
3931         protected VolatileImage drawVBuffer; // = null
3932         /**
3933          * Whether or not the drawing buffer has been recently restored from
3934          * a lost state.
3935          */
3936         protected boolean validatedContents; // = false
3937         /**
3938          * Size of the back buffers.  (Note: these fields were added in 6.0
3939          * but kept package-private to avoid exposing them in the spec.
3940          * None of these fields/methods really should have been marked
3941          * protected when they were introduced in 1.4, but now we just have
3942          * to live with that decision.)
3943          */
3944         int width;
3945         int height;
3946 
3947         /**
3948          * Creates a new flipping buffer strategy for this component.
3949          * The component must be a &lt;code&gt;Canvas&lt;/code&gt; or &lt;code&gt;Window&lt;/code&gt;.
3950          * @see Canvas
3951          * @see Window
3952          * @param numBuffers the number of buffers
3953          * @param caps the capabilities of the buffers
3954          * @exception AWTException if the capabilities supplied could not be
3955          * supported or met
3956          * @exception ClassCastException if the component is not a canvas or
3957          * window.
3958          * @exception IllegalStateException if the component has no peer
3959          * @exception IllegalArgumentException if {@code numBuffers} is less than two,
3960          * or if {@code BufferCapabilities.isPageFlipping} is not
3961          * {@code true}.
3962          * @see #createBuffers(int, BufferCapabilities)
3963          */
3964         protected FlipBufferStrategy(int numBuffers, BufferCapabilities caps)
3965             throws AWTException
3966         {
3967             if (!(Component.this instanceof Window) &amp;&amp;
3968                 !(Component.this instanceof Canvas))
3969             {
3970                 throw new ClassCastException(
3971                     "Component must be a Canvas or Window");
3972             }
3973             this.numBuffers = numBuffers;
3974             this.caps = caps;
3975             createBuffers(numBuffers, caps);
3976         }
3977 
3978         /**
3979          * Creates one or more complex, flipping buffers with the given
3980          * capabilities.
3981          * @param numBuffers number of buffers to create; must be greater than
3982          * one
3983          * @param caps the capabilities of the buffers.
3984          * &lt;code&gt;BufferCapabilities.isPageFlipping&lt;/code&gt; must be
3985          * &lt;code&gt;true&lt;/code&gt;.
3986          * @exception AWTException if the capabilities supplied could not be
3987          * supported or met
3988          * @exception IllegalStateException if the component has no peer
3989          * @exception IllegalArgumentException if numBuffers is less than two,
3990          * or if &lt;code&gt;BufferCapabilities.isPageFlipping&lt;/code&gt; is not
3991          * &lt;code&gt;true&lt;/code&gt;.
3992          * @see java.awt.BufferCapabilities#isPageFlipping()
3993          */
3994         protected void createBuffers(int numBuffers, BufferCapabilities caps)
3995             throws AWTException
3996         {
3997             if (numBuffers &lt; 2) {
3998                 throw new IllegalArgumentException(
3999                     "Number of buffers cannot be less than two");
4000             } else if (peer == null) {
4001                 throw new IllegalStateException(
4002                     "Component must have a valid peer");
4003             } else if (caps == null || !caps.isPageFlipping()) {
4004                 throw new IllegalArgumentException(
4005                     "Page flipping capabilities must be specified");
4006             }
4007 
4008             // save the current bounds
4009             width = getWidth();
4010             height = getHeight();
4011 
4012             if (drawBuffer != null) {
4013                 // dispose the existing backbuffers
4014                 drawBuffer = null;
4015                 drawVBuffer = null;
4016                 destroyBuffers();
4017                 // ... then recreate the backbuffers
4018             }
4019 
4020             if (caps instanceof ExtendedBufferCapabilities) {
4021                 ExtendedBufferCapabilities ebc =
4022                     (ExtendedBufferCapabilities)caps;
4023                 if (ebc.getVSync() == VSYNC_ON) {
4024                     // if this buffer strategy is not allowed to be v-synced,
4025                     // change the caps that we pass to the peer but keep on
4026                     // trying to create v-synced buffers;
4027                     // do not throw IAE here in case it is disallowed, see
4028                     // ExtendedBufferCapabilities for more info
4029                     if (!VSyncedBSManager.vsyncAllowed(this)) {
4030                         caps = ebc.derive(VSYNC_DEFAULT);
4031                     }
4032                 }
4033             }
4034 
4035             peer.createBuffers(numBuffers, caps);
4036             updateInternalBuffers();
4037         }
4038 
4039         /**
4040          * Updates internal buffers (both volatile and non-volatile)
4041          * by requesting the back-buffer from the peer.
4042          */
4043         private void updateInternalBuffers() {
4044             // get the images associated with the draw buffer
4045             drawBuffer = getBackBuffer();
4046             if (drawBuffer instanceof VolatileImage) {
4047                 drawVBuffer = (VolatileImage)drawBuffer;
4048             } else {
4049                 drawVBuffer = null;
4050             }
4051         }
4052 
4053         /**
4054          * @return direct access to the back buffer, as an image.
4055          * @exception IllegalStateException if the buffers have not yet
4056          * been created
4057          */
4058         protected Image getBackBuffer() {
4059             if (peer != null) {
4060                 return peer.getBackBuffer();
4061             } else {
4062                 throw new IllegalStateException(
4063                     "Component must have a valid peer");
4064             }
4065         }
4066 
4067         /**
4068          * Flipping moves the contents of the back buffer to the front buffer,
4069          * either by copying or by moving the video pointer.
4070          * @param flipAction an integer value describing the flipping action
4071          * for the contents of the back buffer.  This should be one of the
4072          * values of the &lt;code&gt;BufferCapabilities.FlipContents&lt;/code&gt;
4073          * property.
4074          * @exception IllegalStateException if the buffers have not yet
4075          * been created
4076          * @see java.awt.BufferCapabilities#getFlipContents()
4077          */
4078         protected void flip(BufferCapabilities.FlipContents flipAction) {
4079             if (peer != null) {
4080                 Image backBuffer = getBackBuffer();
4081                 if (backBuffer != null) {
4082                     peer.flip(0, 0,
4083                               backBuffer.getWidth(null),
4084                               backBuffer.getHeight(null), flipAction);
4085                 }
4086             } else {
4087                 throw new IllegalStateException(
4088                     "Component must have a valid peer");
4089             }
4090         }
4091 
4092         void flipSubRegion(int x1, int y1, int x2, int y2,
4093                       BufferCapabilities.FlipContents flipAction)
4094         {
4095             if (peer != null) {
4096                 peer.flip(x1, y1, x2, y2, flipAction);
4097             } else {
4098                 throw new IllegalStateException(
4099                     "Component must have a valid peer");
4100             }
4101         }
4102 
4103         /**
4104          * Destroys the buffers created through this object
4105          */
4106         protected void destroyBuffers() {
4107             VSyncedBSManager.releaseVsync(this);
4108             if (peer != null) {
4109                 peer.destroyBuffers();
4110             } else {
4111                 throw new IllegalStateException(
4112                     "Component must have a valid peer");
4113             }
4114         }
4115 
4116         /**
4117          * @return the buffering capabilities of this strategy
4118          */
4119         public BufferCapabilities getCapabilities() {
4120             if (caps instanceof ProxyCapabilities) {
4121                 return ((ProxyCapabilities)caps).orig;
4122             } else {
4123                 return caps;
4124             }
4125         }
4126 
4127         /**
4128          * @return the graphics on the drawing buffer.  This method may not
4129          * be synchronized for performance reasons; use of this method by multiple
4130          * threads should be handled at the application level.  Disposal of the
4131          * graphics object must be handled by the application.
4132          */
4133         public Graphics getDrawGraphics() {
4134             revalidate();
4135             return drawBuffer.getGraphics();
4136         }
4137 
4138         /**
4139          * Restore the drawing buffer if it has been lost
4140          */
4141         protected void revalidate() {
4142             revalidate(true);
4143         }
4144 
4145         void revalidate(boolean checkSize) {
4146             validatedContents = false;
4147 
4148             if (checkSize &amp;&amp; (getWidth() != width || getHeight() != height)) {
4149                 // component has been resized; recreate the backbuffers
4150                 try {
4151                     createBuffers(numBuffers, caps);
4152                 } catch (AWTException e) {
4153                     // shouldn't be possible
4154                 }
4155                 validatedContents = true;
4156             }
4157 
4158             // get the buffers from the peer every time since they
4159             // might have been replaced in response to a display change event
4160             updateInternalBuffers();
4161 
4162             // now validate the backbuffer
4163             if (drawVBuffer != null) {
4164                 GraphicsConfiguration gc =
4165                         getGraphicsConfiguration_NoClientCode();
4166                 int returnCode = drawVBuffer.validate(gc);
4167                 if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {
4168                     try {
4169                         createBuffers(numBuffers, caps);
4170                     } catch (AWTException e) {
4171                         // shouldn't be possible
4172                     }
4173                     if (drawVBuffer != null) {
4174                         // backbuffers were recreated, so validate again
4175                         drawVBuffer.validate(gc);
4176                     }
4177                     validatedContents = true;
4178                 } else if (returnCode == VolatileImage.IMAGE_RESTORED) {
4179                     validatedContents = true;
4180                 }
4181             }
4182         }
4183 
4184         /**
4185          * @return whether the drawing buffer was lost since the last call to
4186          * &lt;code&gt;getDrawGraphics&lt;/code&gt;
4187          */
4188         public boolean contentsLost() {
4189             if (drawVBuffer == null) {
4190                 return false;
4191             }
4192             return drawVBuffer.contentsLost();
4193         }
4194 
4195         /**
4196          * @return whether the drawing buffer was recently restored from a lost
4197          * state and reinitialized to the default background color (white)
4198          */
4199         public boolean contentsRestored() {
4200             return validatedContents;
4201         }
4202 
4203         /**
4204          * Makes the next available buffer visible by either blitting or
4205          * flipping.
4206          */
4207         public void show() {
4208             flip(caps.getFlipContents());
4209         }
4210 
4211         /**
4212          * Makes specified region of the the next available buffer visible
4213          * by either blitting or flipping.
4214          */
4215         void showSubRegion(int x1, int y1, int x2, int y2) {
4216             flipSubRegion(x1, y1, x2, y2, caps.getFlipContents());
4217         }
4218 
4219         /**
4220          * {@inheritDoc}
4221          * @since 1.6
4222          */
4223         public void dispose() {
4224             if (Component.this.bufferStrategy == this) {
4225                 Component.this.bufferStrategy = null;
4226                 if (peer != null) {
4227                     destroyBuffers();
4228                 }
4229             }
4230         }
4231 
4232     } // Inner class FlipBufferStrategy
4233 
4234     /**
4235      * Inner class for blitting offscreen surfaces to a component.
4236      *
4237      * @author Michael Martak
4238      * @since 1.4
4239      */
4240     protected class BltBufferStrategy extends BufferStrategy {
4241 
4242         /**
4243          * The buffering capabilities
4244          */
4245         protected BufferCapabilities caps; // = null
4246         /**
4247          * The back buffers
4248          */
4249         protected VolatileImage[] backBuffers; // = null
4250         /**
4251          * Whether or not the drawing buffer has been recently restored from
4252          * a lost state.
4253          */
4254         protected boolean validatedContents; // = false
4255         /**
4256          * Size of the back buffers
4257          */
4258         protected int width;
4259         protected int height;
4260 
4261         /**
4262          * Insets for the hosting Component.  The size of the back buffer
4263          * is constrained by these.
4264          */
4265         private Insets insets;
4266 
4267         /**
4268          * Creates a new blt buffer strategy around a component
4269          * @param numBuffers number of buffers to create, including the
4270          * front buffer
4271          * @param caps the capabilities of the buffers
4272          */
4273         protected BltBufferStrategy(int numBuffers, BufferCapabilities caps) {
4274             this.caps = caps;
4275             createBackBuffers(numBuffers - 1);
4276         }
4277 
4278         /**
4279          * {@inheritDoc}
4280          * @since 1.6
4281          */
4282         public void dispose() {
4283             if (backBuffers != null) {
4284                 for (int counter = backBuffers.length - 1; counter &gt;= 0;
4285                      counter--) {
4286                     if (backBuffers[counter] != null) {
4287                         backBuffers[counter].flush();
4288                         backBuffers[counter] = null;
4289                     }
4290                 }
4291             }
4292             if (Component.this.bufferStrategy == this) {
4293                 Component.this.bufferStrategy = null;
4294             }
4295         }
4296 
4297         /**
4298          * Creates the back buffers
4299          */
4300         protected void createBackBuffers(int numBuffers) {
4301             if (numBuffers == 0) {
4302                 backBuffers = null;
4303             } else {
4304                 // save the current bounds
4305                 width = getWidth();
4306                 height = getHeight();
4307                 insets = getInsets_NoClientCode();
4308                 int iWidth = width - insets.left - insets.right;
4309                 int iHeight = height - insets.top - insets.bottom;
4310 
4311                 // It is possible for the component's width and/or height
4312                 // to be 0 here.  Force the size of the backbuffers to
4313                 // be &gt; 0 so that creating the image won't fail.
4314                 iWidth = Math.max(1, iWidth);
4315                 iHeight = Math.max(1, iHeight);
4316                 if (backBuffers == null) {
4317                     backBuffers = new VolatileImage[numBuffers];
4318                 } else {
4319                     // flush any existing backbuffers
4320                     for (int i = 0; i &lt; numBuffers; i++) {
4321                         if (backBuffers[i] != null) {
4322                             backBuffers[i].flush();
4323                             backBuffers[i] = null;
4324                         }
4325                     }
4326                 }
4327 
4328                 // create the backbuffers
4329                 for (int i = 0; i &lt; numBuffers; i++) {
4330                     backBuffers[i] = createVolatileImage(iWidth, iHeight);
4331                 }
4332             }
4333         }
4334 
4335         /**
4336          * @return the buffering capabilities of this strategy
4337          */
4338         public BufferCapabilities getCapabilities() {
4339             return caps;
4340         }
4341 
4342         /**
4343          * @return the draw graphics
4344          */
4345         public Graphics getDrawGraphics() {
4346             revalidate();
4347             Image backBuffer = getBackBuffer();
4348             if (backBuffer == null) {
4349                 return getGraphics();
4350             }
4351             SunGraphics2D g = (SunGraphics2D)backBuffer.getGraphics();
4352             g.constrain(-insets.left, -insets.top,
4353                         backBuffer.getWidth(null) + insets.left,
4354                         backBuffer.getHeight(null) + insets.top);
4355             return g;
4356         }
4357 
4358         /**
4359          * @return direct access to the back buffer, as an image.
4360          * If there is no back buffer, returns null.
4361          */
4362         Image getBackBuffer() {
4363             if (backBuffers != null) {
4364                 return backBuffers[backBuffers.length - 1];
4365             } else {
4366                 return null;
4367             }
4368         }
4369 
4370         /**
4371          * Makes the next available buffer visible.
4372          */
4373         public void show() {
4374             showSubRegion(insets.left, insets.top,
4375                           width - insets.right,
4376                           height - insets.bottom);
4377         }
4378 
4379         /**
4380          * Package-private method to present a specific rectangular area
4381          * of this buffer.  This class currently shows only the entire
4382          * buffer, by calling showSubRegion() with the full dimensions of
4383          * the buffer.  Subclasses (e.g., BltSubRegionBufferStrategy
4384          * and FlipSubRegionBufferStrategy) may have region-specific show
4385          * methods that call this method with actual sub regions of the
4386          * buffer.
4387          */
4388         void showSubRegion(int x1, int y1, int x2, int y2) {
4389             if (backBuffers == null) {
4390                 return;
4391             }
4392             // Adjust location to be relative to client area.
4393             x1 -= insets.left;
4394             x2 -= insets.left;
4395             y1 -= insets.top;
4396             y2 -= insets.top;
4397             Graphics g = getGraphics_NoClientCode();
4398             if (g == null) {
4399                 // Not showing, bail
4400                 return;
4401             }
4402             try {
4403                 // First image copy is in terms of Frame's coordinates, need
4404                 // to translate to client area.
4405                 g.translate(insets.left, insets.top);
4406                 for (int i = 0; i &lt; backBuffers.length; i++) {
4407                     g.drawImage(backBuffers[i],
4408                                 x1, y1, x2, y2,
4409                                 x1, y1, x2, y2,
4410                                 null);
4411                     g.dispose();
4412                     g = null;
4413                     g = backBuffers[i].getGraphics();
4414                 }
4415             } finally {
4416                 if (g != null) {
4417                     g.dispose();
4418                 }
4419             }
4420         }
4421 
4422         /**
4423          * Restore the drawing buffer if it has been lost
4424          */
4425         protected void revalidate() {
4426             revalidate(true);
4427         }
4428 
4429         void revalidate(boolean checkSize) {
4430             validatedContents = false;
4431 
4432             if (backBuffers == null) {
4433                 return;
4434             }
4435 
4436             if (checkSize) {
4437                 Insets insets = getInsets_NoClientCode();
4438                 if (getWidth() != width || getHeight() != height ||
4439                     !insets.equals(this.insets)) {
4440                     // component has been resized; recreate the backbuffers
4441                     createBackBuffers(backBuffers.length);
4442                     validatedContents = true;
4443                 }
4444             }
4445 
4446             // now validate the backbuffer
4447             GraphicsConfiguration gc = getGraphicsConfiguration_NoClientCode();
4448             int returnCode =
4449                 backBuffers[backBuffers.length - 1].validate(gc);
4450             if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {
4451                 if (checkSize) {
4452                     createBackBuffers(backBuffers.length);
4453                     // backbuffers were recreated, so validate again
4454                     backBuffers[backBuffers.length - 1].validate(gc);
4455                 }
4456                 // else case means we're called from Swing on the toolkit
4457                 // thread, don't recreate buffers as that'll deadlock
4458                 // (creating VolatileImages invokes getting GraphicsConfig
4459                 // which grabs treelock).
4460                 validatedContents = true;
4461             } else if (returnCode == VolatileImage.IMAGE_RESTORED) {
4462                 validatedContents = true;
4463             }
4464         }
4465 
4466         /**
4467          * @return whether the drawing buffer was lost since the last call to
4468          * &lt;code&gt;getDrawGraphics&lt;/code&gt;
4469          */
4470         public boolean contentsLost() {
4471             if (backBuffers == null) {
4472                 return false;
4473             } else {
4474                 return backBuffers[backBuffers.length - 1].contentsLost();
4475             }
4476         }
4477 
4478         /**
4479          * @return whether the drawing buffer was recently restored from a lost
4480          * state and reinitialized to the default background color (white)
4481          */
4482         public boolean contentsRestored() {
4483             return validatedContents;
4484         }
4485     } // Inner class BltBufferStrategy
4486 
4487     /**
4488      * Private class to perform sub-region flipping.
4489      */
4490     private class FlipSubRegionBufferStrategy extends FlipBufferStrategy
4491         implements SubRegionShowable
4492     {
4493 
4494         protected FlipSubRegionBufferStrategy(int numBuffers,
4495                                               BufferCapabilities caps)
4496             throws AWTException
4497         {
4498             super(numBuffers, caps);
4499         }
4500 
4501         public void show(int x1, int y1, int x2, int y2) {
4502             showSubRegion(x1, y1, x2, y2);
4503         }
4504 
4505         // This is invoked by Swing on the toolkit thread.
4506         public boolean showIfNotLost(int x1, int y1, int x2, int y2) {
4507             if (!contentsLost()) {
4508                 showSubRegion(x1, y1, x2, y2);
4509                 return !contentsLost();
4510             }
4511             return false;
4512         }
4513     }
4514 
4515     /**
4516      * Private class to perform sub-region blitting.  Swing will use
4517      * this subclass via the SubRegionShowable interface in order to
4518      * copy only the area changed during a repaint.
4519      * See javax.swing.BufferStrategyPaintManager.
4520      */
4521     private class BltSubRegionBufferStrategy extends BltBufferStrategy
4522         implements SubRegionShowable
4523     {
4524 
4525         protected BltSubRegionBufferStrategy(int numBuffers,
4526                                              BufferCapabilities caps)
4527         {
4528             super(numBuffers, caps);
4529         }
4530 
4531         public void show(int x1, int y1, int x2, int y2) {
4532             showSubRegion(x1, y1, x2, y2);
4533         }
4534 
4535         // This method is called by Swing on the toolkit thread.
4536         public boolean showIfNotLost(int x1, int y1, int x2, int y2) {
4537             if (!contentsLost()) {
4538                 showSubRegion(x1, y1, x2, y2);
4539                 return !contentsLost();
4540             }
4541             return false;
4542         }
4543     }
4544 
4545     /**
4546      * Inner class for flipping buffers on a component.  That component must
4547      * be a &lt;code&gt;Canvas&lt;/code&gt; or &lt;code&gt;Window&lt;/code&gt;.
4548      * @see Canvas
4549      * @see Window
4550      * @see java.awt.image.BufferStrategy
4551      * @author Michael Martak
4552      * @since 1.4
4553      */
4554     private class SingleBufferStrategy extends BufferStrategy {
4555 
4556         private BufferCapabilities caps;
4557 
4558         public SingleBufferStrategy(BufferCapabilities caps) {
4559             this.caps = caps;
4560         }
4561         public BufferCapabilities getCapabilities() {
4562             return caps;
4563         }
4564         public Graphics getDrawGraphics() {
4565             return getGraphics();
4566         }
4567         public boolean contentsLost() {
4568             return false;
4569         }
4570         public boolean contentsRestored() {
4571             return false;
4572         }
4573         public void show() {
4574             // Do nothing
4575         }
4576     } // Inner class SingleBufferStrategy
4577 
4578     /**
4579      * Sets whether or not paint messages received from the operating system
4580      * should be ignored.  This does not affect paint events generated in
4581      * software by the AWT, unless they are an immediate response to an
4582      * OS-level paint message.
4583      * &lt;p&gt;
4584      * This is useful, for example, if running under full-screen mode and
4585      * better performance is desired, or if page-flipping is used as the
4586      * buffer strategy.
4587      *
4588      * @since 1.4
4589      * @see #getIgnoreRepaint
4590      * @see Canvas#createBufferStrategy
4591      * @see Window#createBufferStrategy
4592      * @see java.awt.image.BufferStrategy
4593      * @see GraphicsDevice#setFullScreenWindow
4594      */
4595     public void setIgnoreRepaint(boolean ignoreRepaint) {
4596         this.ignoreRepaint = ignoreRepaint;
4597     }
4598 
4599     /**
4600      * @return whether or not paint messages received from the operating system
4601      * should be ignored.
4602      *
4603      * @since 1.4
4604      * @see #setIgnoreRepaint
4605      */
4606     public boolean getIgnoreRepaint() {
4607         return ignoreRepaint;
4608     }
4609 
4610     /**
4611      * Checks whether this component "contains" the specified point,
4612      * where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are defined to be
4613      * relative to the coordinate system of this component.
4614      * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate of the point
4615      * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate of the point
4616      * @see       #getComponentAt(int, int)
4617      * @since     JDK1.1
4618      */
4619     public boolean contains(int x, int y) {
4620         return inside(x, y);
4621     }
4622 
4623     /**
4624      * @deprecated As of JDK version 1.1,
4625      * replaced by contains(int, int).
4626      */
4627     @Deprecated
4628     public boolean inside(int x, int y) {
4629         return (x &gt;= 0) &amp;&amp; (x &lt; width) &amp;&amp; (y &gt;= 0) &amp;&amp; (y &lt; height);
4630     }
4631 
4632     /**
4633      * Checks whether this component "contains" the specified point,
4634      * where the point's &lt;i&gt;x&lt;/i&gt; and &lt;i&gt;y&lt;/i&gt; coordinates are defined
4635      * to be relative to the coordinate system of this component.
4636      * @param     p     the point
4637      * @throws    NullPointerException if {@code p} is {@code null}
4638      * @see       #getComponentAt(Point)
4639      * @since     JDK1.1
4640      */
4641     public boolean contains(Point p) {
4642         return contains(p.x, p.y);
4643     }
4644 
4645     /**
4646      * Determines if this component or one of its immediate
4647      * subcomponents contains the (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) location,
4648      * and if so, returns the containing component. This method only
4649      * looks one level deep. If the point (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) is
4650      * inside a subcomponent that itself has subcomponents, it does not
4651      * go looking down the subcomponent tree.
4652      * &lt;p&gt;
4653      * The &lt;code&gt;locate&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; simply
4654      * returns the component itself if the (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;)
4655      * coordinate location is inside its bounding box, and &lt;code&gt;null&lt;/code&gt;
4656      * otherwise.
4657      * @param     x   the &lt;i&gt;x&lt;/i&gt; coordinate
4658      * @param     y   the &lt;i&gt;y&lt;/i&gt; coordinate
4659      * @return    the component or subcomponent that contains the
4660      *                (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) location;
4661      *                &lt;code&gt;null&lt;/code&gt; if the location
4662      *                is outside this component
4663      * @see       #contains(int, int)
4664      * @since     JDK1.0
4665      */
4666     public Component getComponentAt(int x, int y) {
4667         return locate(x, y);
4668     }
4669 
4670     /**
4671      * @deprecated As of JDK version 1.1,
4672      * replaced by getComponentAt(int, int).
4673      */
4674     @Deprecated
4675     public Component locate(int x, int y) {
4676         return contains(x, y) ? this : null;
4677     }
4678 
4679     /**
4680      * Returns the component or subcomponent that contains the
4681      * specified point.
4682      * @param     p   the point
4683      * @see       java.awt.Component#contains
4684      * @since     JDK1.1
4685      */
4686     public Component getComponentAt(Point p) {
4687         return getComponentAt(p.x, p.y);
4688     }
4689 
4690     /**
4691      * @deprecated As of JDK version 1.1,
4692      * replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;.
4693      */
4694     @Deprecated
4695     public void deliverEvent(Event e) {
4696         postEvent(e);
4697     }
4698 
4699     /**
4700      * Dispatches an event to this component or one of its sub components.
4701      * Calls &lt;code&gt;processEvent&lt;/code&gt; before returning for 1.1-style
4702      * events which have been enabled for the &lt;code&gt;Component&lt;/code&gt;.
4703      * @param e the event
4704      */
4705     public final void dispatchEvent(AWTEvent e) {
4706         dispatchEventImpl(e);
4707     }
4708 
4709     @SuppressWarnings("deprecation")
4710     void dispatchEventImpl(AWTEvent e) {
4711         int id = e.getID();
4712 
4713         // Check that this component belongs to this app-context
4714         AppContext compContext = appContext;
4715         if (compContext != null &amp;&amp; !compContext.equals(AppContext.getAppContext())) {
4716             if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
4717                 eventLog.fine("Event " + e + " is being dispatched on the wrong AppContext");
4718             }
4719         }
4720 
4721         if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
4722             eventLog.finest("{0}", e);
4723         }
4724 
4725         /*
4726          * 0. Set timestamp and modifiers of current event.
4727          */
4728         if (!(e instanceof KeyEvent)) {
4729             // Timestamp of a key event is set later in DKFM.preDispatchKeyEvent(KeyEvent).
4730             EventQueue.setCurrentEventAndMostRecentTime(e);
4731         }
4732 
4733         /*
4734          * 1. Pre-dispatchers. Do any necessary retargeting/reordering here
4735          *    before we notify AWTEventListeners.
4736          */
4737 
4738         if (e instanceof SunDropTargetEvent) {
4739             ((SunDropTargetEvent)e).dispatch();
4740             return;
4741         }
4742 
4743         if (!e.focusManagerIsDispatching) {
4744             // Invoke the private focus retargeting method which provides
4745             // lightweight Component support
4746             if (e.isPosted) {
4747                 e = KeyboardFocusManager.retargetFocusEvent(e);
4748                 e.isPosted = true;
4749             }
4750 
4751             // Now, with the event properly targeted to a lightweight
4752             // descendant if necessary, invoke the public focus retargeting
4753             // and dispatching function
4754             if (KeyboardFocusManager.getCurrentKeyboardFocusManager().
4755                 dispatchEvent(e))
4756             {
4757                 return;
4758             }
4759         }
4760         if ((e instanceof FocusEvent) &amp;&amp; focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
4761             focusLog.finest("" + e);
4762         }
4763         // MouseWheel may need to be retargeted here so that
4764         // AWTEventListener sees the event go to the correct
4765         // Component.  If the MouseWheelEvent needs to go to an ancestor,
4766         // the event is dispatched to the ancestor, and dispatching here
4767         // stops.
4768         if (id == MouseEvent.MOUSE_WHEEL &amp;&amp;
4769             (!eventTypeEnabled(id)) &amp;&amp;
4770             (peer != null &amp;&amp; !peer.handlesWheelScrolling()) &amp;&amp;
4771             (dispatchMouseWheelToAncestor((MouseWheelEvent)e)))
4772         {
4773             return;
4774         }
4775 
4776         /*
4777          * 2. Allow the Toolkit to pass this to AWTEventListeners.
4778          */
4779         Toolkit toolkit = Toolkit.getDefaultToolkit();
4780         toolkit.notifyAWTEventListeners(e);
4781 
4782 
4783         /*
4784          * 3. If no one has consumed a key event, allow the
4785          *    KeyboardFocusManager to process it.
4786          */
4787         if (!e.isConsumed()) {
4788             if (e instanceof java.awt.event.KeyEvent) {
4789                 KeyboardFocusManager.getCurrentKeyboardFocusManager().
4790                     processKeyEvent(this, (KeyEvent)e);
4791                 if (e.isConsumed()) {
4792                     return;
4793                 }
4794             }
4795         }
4796 
4797         /*
4798          * 4. Allow input methods to process the event
4799          */
4800         if (areInputMethodsEnabled()) {
4801             // We need to pass on InputMethodEvents since some host
4802             // input method adapters send them through the Java
4803             // event queue instead of directly to the component,
4804             // and the input context also handles the Java composition window
4805             if(((e instanceof InputMethodEvent) &amp;&amp; !(this instanceof CompositionArea))
4806                ||
4807                // Otherwise, we only pass on input and focus events, because
4808                // a) input methods shouldn't know about semantic or component-level events
4809                // b) passing on the events takes time
4810                // c) isConsumed() is always true for semantic events.
4811                (e instanceof InputEvent) || (e instanceof FocusEvent)) {
4812                 InputContext inputContext = getInputContext();
4813 
4814 
4815                 if (inputContext != null) {
4816                     inputContext.dispatchEvent(e);
4817                     if (e.isConsumed()) {
4818                         if ((e instanceof FocusEvent) &amp;&amp; focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
4819                             focusLog.finest("3579: Skipping " + e);
4820                         }
4821                         return;
4822                     }
4823                 }
4824             }
4825         } else {
4826             // When non-clients get focus, we need to explicitly disable the native
4827             // input method. The native input method is actually not disabled when
4828             // the active/passive/peered clients loose focus.
4829             if (id == FocusEvent.FOCUS_GAINED) {
4830                 InputContext inputContext = getInputContext();
4831                 if (inputContext != null &amp;&amp; inputContext instanceof sun.awt.im.InputContext) {
4832                     ((sun.awt.im.InputContext)inputContext).disableNativeIM();
4833                 }
4834             }
4835         }
4836 
4837 
4838         /*
4839          * 5. Pre-process any special events before delivery
4840          */
4841         switch(id) {
4842             // Handling of the PAINT and UPDATE events is now done in the
4843             // peer's handleEvent() method so the background can be cleared
4844             // selectively for non-native components on Windows only.
4845             // - Fred.Ecks@Eng.sun.com, 5-8-98
4846 
4847           case KeyEvent.KEY_PRESSED:
4848           case KeyEvent.KEY_RELEASED:
4849               Container p = (Container)((this instanceof Container) ? this : parent);
4850               if (p != null) {
4851                   p.preProcessKeyEvent((KeyEvent)e);
4852                   if (e.isConsumed()) {
4853                         if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
4854                             focusLog.finest("Pre-process consumed event");
4855                         }
4856                       return;
4857                   }
4858               }
4859               break;
4860 
4861           case WindowEvent.WINDOW_CLOSING:
4862               if (toolkit instanceof WindowClosingListener) {
4863                   windowClosingException = ((WindowClosingListener)
4864                                             toolkit).windowClosingNotify((WindowEvent)e);
4865                   if (checkWindowClosingException()) {
4866                       return;
4867                   }
4868               }
4869               break;
4870 
4871           default:
4872               break;
4873         }
4874 
4875         /*
4876          * 6. Deliver event for normal processing
4877          */
4878         if (newEventsOnly) {
4879             // Filtering needs to really be moved to happen at a lower
4880             // level in order to get maximum performance gain;  it is
4881             // here temporarily to ensure the API spec is honored.
4882             //
4883             if (eventEnabled(e)) {
4884                 processEvent(e);
4885             }
4886         } else if (id == MouseEvent.MOUSE_WHEEL) {
4887             // newEventsOnly will be false for a listenerless ScrollPane, but
4888             // MouseWheelEvents still need to be dispatched to it so scrolling
4889             // can be done.
4890             autoProcessMouseWheel((MouseWheelEvent)e);
4891         } else if (!(e instanceof MouseEvent &amp;&amp; !postsOldMouseEvents())) {
4892             //
4893             // backward compatibility
4894             //
4895             Event olde = e.convertToOld();
4896             if (olde != null) {
4897                 int key = olde.key;
4898                 int modifiers = olde.modifiers;
4899 
4900                 postEvent(olde);
4901                 if (olde.isConsumed()) {
4902                     e.consume();
4903                 }
4904                 // if target changed key or modifier values, copy them
4905                 // back to original event
4906                 //
4907                 switch(olde.id) {
4908                   case Event.KEY_PRESS:
4909                   case Event.KEY_RELEASE:
4910                   case Event.KEY_ACTION:
4911                   case Event.KEY_ACTION_RELEASE:
4912                       if (olde.key != key) {
4913                           ((KeyEvent)e).setKeyChar(olde.getKeyEventChar());
4914                       }
4915                       if (olde.modifiers != modifiers) {
4916                           ((KeyEvent)e).setModifiers(olde.modifiers);
4917                       }
4918                       break;
4919                   default:
4920                       break;
4921                 }
4922             }
4923         }
4924 
4925         /*
4926          * 8. Special handling for 4061116 : Hook for browser to close modal
4927          *    dialogs.
4928          */
4929         if (id == WindowEvent.WINDOW_CLOSING &amp;&amp; !e.isConsumed()) {
4930             if (toolkit instanceof WindowClosingListener) {
4931                 windowClosingException =
4932                     ((WindowClosingListener)toolkit).
4933                     windowClosingDelivered((WindowEvent)e);
4934                 if (checkWindowClosingException()) {
4935                     return;
4936                 }
4937             }
4938         }
4939 
4940         /*
4941          * 9. Allow the peer to process the event.
4942          * Except KeyEvents, they will be processed by peer after
4943          * all KeyEventPostProcessors
4944          * (see DefaultKeyboardFocusManager.dispatchKeyEvent())
4945          */
4946         if (!(e instanceof KeyEvent)) {
4947             ComponentPeer tpeer = peer;
4948             if (e instanceof FocusEvent &amp;&amp; (tpeer == null || tpeer instanceof LightweightPeer)) {
4949                 // if focus owner is lightweight then its native container
4950                 // processes event
4951                 Component source = (Component)e.getSource();
4952                 if (source != null) {
4953                     Container target = source.getNativeContainer();
4954                     if (target != null) {
4955                         tpeer = target.getPeer();
4956                     }
4957                 }
4958             }
4959             if (tpeer != null) {
4960                 tpeer.handleEvent(e);
4961             }
4962         }
4963     } // dispatchEventImpl()
4964 
4965     /*
4966      * If newEventsOnly is false, method is called so that ScrollPane can
4967      * override it and handle common-case mouse wheel scrolling.  NOP
4968      * for Component.
4969      */
4970     void autoProcessMouseWheel(MouseWheelEvent e) {}
4971 
4972     /*
4973      * Dispatch given MouseWheelEvent to the first ancestor for which
4974      * MouseWheelEvents are enabled.
4975      *
4976      * Returns whether or not event was dispatched to an ancestor
4977      */
4978     boolean dispatchMouseWheelToAncestor(MouseWheelEvent e) {
4979         int newX, newY;
4980         newX = e.getX() + getX(); // Coordinates take into account at least
4981         newY = e.getY() + getY(); // the cursor's position relative to this
4982                                   // Component (e.getX()), and this Component's
4983                                   // position relative to its parent.
4984         MouseWheelEvent newMWE;
4985 
4986         if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
4987             eventLog.finest("dispatchMouseWheelToAncestor");
4988             eventLog.finest("orig event src is of " + e.getSource().getClass());
4989         }
4990 
4991         /* parent field for Window refers to the owning Window.
4992          * MouseWheelEvents should NOT be propagated into owning Windows
4993          */
4994         synchronized (getTreeLock()) {
4995             Container anc = getParent();
4996             while (anc != null &amp;&amp; !anc.eventEnabled(e)) {
4997                 // fix coordinates to be relative to new event source
4998                 newX += anc.getX();
4999                 newY += anc.getY();
5000 
5001                 if (!(anc instanceof Window)) {
5002                     anc = anc.getParent();
5003                 }
5004                 else {
5005                     break;
5006                 }
5007             }
5008 
5009             if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
5010                 eventLog.finest("new event src is " + anc.getClass());
5011             }
5012 
5013             if (anc != null &amp;&amp; anc.eventEnabled(e)) {
5014                 // Change event to be from new source, with new x,y
5015                 // For now, just create a new event - yucky
5016 
5017                 newMWE = new MouseWheelEvent(anc, // new source
5018                                              e.getID(),
5019                                              e.getWhen(),
5020                                              e.getModifiers(),
5021                                              newX, // x relative to new source
5022                                              newY, // y relative to new source
5023                                              e.getXOnScreen(),
5024                                              e.getYOnScreen(),
5025                                              e.getClickCount(),
5026                                              e.isPopupTrigger(),
5027                                              e.getScrollType(),
5028                                              e.getScrollAmount(),
5029                                              e.getWheelRotation(),
5030                                              e.getPreciseWheelRotation());
5031                 ((AWTEvent)e).copyPrivateDataInto(newMWE);
5032                 // When dispatching a wheel event to
5033                 // ancestor, there is no need trying to find descendant
5034                 // lightweights to dispatch event to.
5035                 // If we dispatch the event to toplevel ancestor,
5036                 // this could encolse the loop: 6480024.
5037                 anc.dispatchEventToSelf(newMWE);
5038                 if (newMWE.isConsumed()) {
5039                     e.consume();
5040                 }
5041                 return true;
5042             }
5043         }
5044         return false;
5045     }
5046 
5047     boolean checkWindowClosingException() {
5048         if (windowClosingException != null) {
5049             if (this instanceof Dialog) {
5050                 ((Dialog)this).interruptBlocking();
5051             } else {
5052                 windowClosingException.fillInStackTrace();
5053                 windowClosingException.printStackTrace();
5054                 windowClosingException = null;
5055             }
5056             return true;
5057         }
5058         return false;
5059     }
5060 
5061     boolean areInputMethodsEnabled() {
5062         // in 1.2, we assume input method support is required for all
5063         // components that handle key events, but components can turn off
5064         // input methods by calling enableInputMethods(false).
5065         return ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) &amp;&amp;
5066             ((eventMask &amp; AWTEvent.KEY_EVENT_MASK) != 0 || keyListener != null);
5067     }
5068 
5069     // REMIND: remove when filtering is handled at lower level
5070     boolean eventEnabled(AWTEvent e) {
5071         return eventTypeEnabled(e.id);
5072     }
5073 
5074     boolean eventTypeEnabled(int type) {
5075         switch(type) {
5076           case ComponentEvent.COMPONENT_MOVED:
5077           case ComponentEvent.COMPONENT_RESIZED:
5078           case ComponentEvent.COMPONENT_SHOWN:
5079           case ComponentEvent.COMPONENT_HIDDEN:
5080               if ((eventMask &amp; AWTEvent.COMPONENT_EVENT_MASK) != 0 ||
5081                   componentListener != null) {
5082                   return true;
5083               }
5084               break;
5085           case FocusEvent.FOCUS_GAINED:
5086           case FocusEvent.FOCUS_LOST:
5087               if ((eventMask &amp; AWTEvent.FOCUS_EVENT_MASK) != 0 ||
5088                   focusListener != null) {
5089                   return true;
5090               }
5091               break;
5092           case KeyEvent.KEY_PRESSED:
5093           case KeyEvent.KEY_RELEASED:
5094           case KeyEvent.KEY_TYPED:
5095               if ((eventMask &amp; AWTEvent.KEY_EVENT_MASK) != 0 ||
5096                   keyListener != null) {
5097                   return true;
5098               }
5099               break;
5100           case MouseEvent.MOUSE_PRESSED:
5101           case MouseEvent.MOUSE_RELEASED:
5102           case MouseEvent.MOUSE_ENTERED:
5103           case MouseEvent.MOUSE_EXITED:
5104           case MouseEvent.MOUSE_CLICKED:
5105               if ((eventMask &amp; AWTEvent.MOUSE_EVENT_MASK) != 0 ||
5106                   mouseListener != null) {
5107                   return true;
5108               }
5109               break;
5110           case MouseEvent.MOUSE_MOVED:
5111           case MouseEvent.MOUSE_DRAGGED:
5112               if ((eventMask &amp; AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0 ||
5113                   mouseMotionListener != null) {
5114                   return true;
5115               }
5116               break;
5117           case MouseEvent.MOUSE_WHEEL:
5118               if ((eventMask &amp; AWTEvent.MOUSE_WHEEL_EVENT_MASK) != 0 ||
5119                   mouseWheelListener != null) {
5120                   return true;
5121               }
5122               break;
5123           case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
5124           case InputMethodEvent.CARET_POSITION_CHANGED:
5125               if ((eventMask &amp; AWTEvent.INPUT_METHOD_EVENT_MASK) != 0 ||
5126                   inputMethodListener != null) {
5127                   return true;
5128               }
5129               break;
5130           case HierarchyEvent.HIERARCHY_CHANGED:
5131               if ((eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||
5132                   hierarchyListener != null) {
5133                   return true;
5134               }
5135               break;
5136           case HierarchyEvent.ANCESTOR_MOVED:
5137           case HierarchyEvent.ANCESTOR_RESIZED:
5138               if ((eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 ||
5139                   hierarchyBoundsListener != null) {
5140                   return true;
5141               }
5142               break;
5143           case ActionEvent.ACTION_PERFORMED:
5144               if ((eventMask &amp; AWTEvent.ACTION_EVENT_MASK) != 0) {
5145                   return true;
5146               }
5147               break;
5148           case TextEvent.TEXT_VALUE_CHANGED:
5149               if ((eventMask &amp; AWTEvent.TEXT_EVENT_MASK) != 0) {
5150                   return true;
5151               }
5152               break;
5153           case ItemEvent.ITEM_STATE_CHANGED:
5154               if ((eventMask &amp; AWTEvent.ITEM_EVENT_MASK) != 0) {
5155                   return true;
5156               }
5157               break;
5158           case AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED:
5159               if ((eventMask &amp; AWTEvent.ADJUSTMENT_EVENT_MASK) != 0) {
5160                   return true;
5161               }
5162               break;
5163           default:
5164               break;
5165         }
5166         //
5167         // Always pass on events defined by external programs.
5168         //
5169         if (type &gt; AWTEvent.RESERVED_ID_MAX) {
5170             return true;
5171         }
5172         return false;
5173     }
5174 
5175     /**
5176      * @deprecated As of JDK version 1.1,
5177      * replaced by dispatchEvent(AWTEvent).
5178      */
5179     @Deprecated
5180     public boolean postEvent(Event e) {
5181         ComponentPeer peer = this.peer;
5182 
5183         if (handleEvent(e)) {
5184             e.consume();
5185             return true;
5186         }
5187 
5188         Component parent = this.parent;
5189         int eventx = e.x;
5190         int eventy = e.y;
5191         if (parent != null) {
5192             e.translate(x, y);
5193             if (parent.postEvent(e)) {
5194                 e.consume();
5195                 return true;
5196             }
5197             // restore coords
5198             e.x = eventx;
5199             e.y = eventy;
5200         }
5201         return false;
5202     }
5203 
5204     // Event source interfaces
5205 
5206     /**
5207      * Adds the specified component listener to receive component events from
5208      * this component.
5209      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5210      * no exception is thrown and no action is performed.
5211      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5212      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5213      *
5214      * @param    l   the component listener
5215      * @see      java.awt.event.ComponentEvent
5216      * @see      java.awt.event.ComponentListener
5217      * @see      #removeComponentListener
5218      * @see      #getComponentListeners
5219      * @since    JDK1.1
5220      */
5221     public synchronized void addComponentListener(ComponentListener l) {
5222         if (l == null) {
5223             return;
5224         }
5225         componentListener = AWTEventMulticaster.add(componentListener, l);
5226         newEventsOnly = true;
5227     }
5228 
5229     /**
5230      * Removes the specified component listener so that it no longer
5231      * receives component events from this component. This method performs
5232      * no function, nor does it throw an exception, if the listener
5233      * specified by the argument was not previously added to this component.
5234      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5235      * no exception is thrown and no action is performed.
5236      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5237      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5238      * @param    l   the component listener
5239      * @see      java.awt.event.ComponentEvent
5240      * @see      java.awt.event.ComponentListener
5241      * @see      #addComponentListener
5242      * @see      #getComponentListeners
5243      * @since    JDK1.1
5244      */
5245     public synchronized void removeComponentListener(ComponentListener l) {
5246         if (l == null) {
5247             return;
5248         }
5249         componentListener = AWTEventMulticaster.remove(componentListener, l);
5250     }
5251 
5252     /**
5253      * Returns an array of all the component listeners
5254      * registered on this component.
5255      *
5256      * @return all &lt;code&gt;ComponentListener&lt;/code&gt;s of this component
5257      *         or an empty array if no component
5258      *         listeners are currently registered
5259      *
5260      * @see #addComponentListener
5261      * @see #removeComponentListener
5262      * @since 1.4
5263      */
5264     public synchronized ComponentListener[] getComponentListeners() {
5265         return getListeners(ComponentListener.class);
5266     }
5267 
5268     /**
5269      * Adds the specified focus listener to receive focus events from
5270      * this component when this component gains input focus.
5271      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5272      * no exception is thrown and no action is performed.
5273      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5274      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5275      *
5276      * @param    l   the focus listener
5277      * @see      java.awt.event.FocusEvent
5278      * @see      java.awt.event.FocusListener
5279      * @see      #removeFocusListener
5280      * @see      #getFocusListeners
5281      * @since    JDK1.1
5282      */
5283     public synchronized void addFocusListener(FocusListener l) {
5284         if (l == null) {
5285             return;
5286         }
5287         focusListener = AWTEventMulticaster.add(focusListener, l);
5288         newEventsOnly = true;
5289 
5290         // if this is a lightweight component, enable focus events
5291         // in the native container.
5292         if (peer instanceof LightweightPeer) {
5293             parent.proxyEnableEvents(AWTEvent.FOCUS_EVENT_MASK);
5294         }
5295     }
5296 
5297     /**
5298      * Removes the specified focus listener so that it no longer
5299      * receives focus events from this component. This method performs
5300      * no function, nor does it throw an exception, if the listener
5301      * specified by the argument was not previously added to this component.
5302      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5303      * no exception is thrown and no action is performed.
5304      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5305      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5306      *
5307      * @param    l   the focus listener
5308      * @see      java.awt.event.FocusEvent
5309      * @see      java.awt.event.FocusListener
5310      * @see      #addFocusListener
5311      * @see      #getFocusListeners
5312      * @since    JDK1.1
5313      */
5314     public synchronized void removeFocusListener(FocusListener l) {
5315         if (l == null) {
5316             return;
5317         }
5318         focusListener = AWTEventMulticaster.remove(focusListener, l);
5319     }
5320 
5321     /**
5322      * Returns an array of all the focus listeners
5323      * registered on this component.
5324      *
5325      * @return all of this component's &lt;code&gt;FocusListener&lt;/code&gt;s
5326      *         or an empty array if no component
5327      *         listeners are currently registered
5328      *
5329      * @see #addFocusListener
5330      * @see #removeFocusListener
5331      * @since 1.4
5332      */
5333     public synchronized FocusListener[] getFocusListeners() {
5334         return getListeners(FocusListener.class);
5335     }
5336 
5337     /**
5338      * Adds the specified hierarchy listener to receive hierarchy changed
5339      * events from this component when the hierarchy to which this container
5340      * belongs changes.
5341      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5342      * no exception is thrown and no action is performed.
5343      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5344      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5345      *
5346      * @param    l   the hierarchy listener
5347      * @see      java.awt.event.HierarchyEvent
5348      * @see      java.awt.event.HierarchyListener
5349      * @see      #removeHierarchyListener
5350      * @see      #getHierarchyListeners
5351      * @since    1.3
5352      */
5353     public void addHierarchyListener(HierarchyListener l) {
5354         if (l == null) {
5355             return;
5356         }
5357         boolean notifyAncestors;
5358         synchronized (this) {
5359             notifyAncestors =
5360                 (hierarchyListener == null &amp;&amp;
5361                  (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) == 0);
5362             hierarchyListener = AWTEventMulticaster.add(hierarchyListener, l);
5363             notifyAncestors = (notifyAncestors &amp;&amp; hierarchyListener != null);
5364             newEventsOnly = true;
5365         }
5366         if (notifyAncestors) {
5367             synchronized (getTreeLock()) {
5368                 adjustListeningChildrenOnParent(AWTEvent.HIERARCHY_EVENT_MASK,
5369                                                 1);
5370             }
5371         }
5372     }
5373 
5374     /**
5375      * Removes the specified hierarchy listener so that it no longer
5376      * receives hierarchy changed events from this component. This method
5377      * performs no function, nor does it throw an exception, if the listener
5378      * specified by the argument was not previously added to this component.
5379      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5380      * no exception is thrown and no action is performed.
5381      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5382      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5383      *
5384      * @param    l   the hierarchy listener
5385      * @see      java.awt.event.HierarchyEvent
5386      * @see      java.awt.event.HierarchyListener
5387      * @see      #addHierarchyListener
5388      * @see      #getHierarchyListeners
5389      * @since    1.3
5390      */
5391     public void removeHierarchyListener(HierarchyListener l) {
5392         if (l == null) {
5393             return;
5394         }
5395         boolean notifyAncestors;
5396         synchronized (this) {
5397             notifyAncestors =
5398                 (hierarchyListener != null &amp;&amp;
5399                  (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) == 0);
5400             hierarchyListener =
5401                 AWTEventMulticaster.remove(hierarchyListener, l);
5402             notifyAncestors = (notifyAncestors &amp;&amp; hierarchyListener == null);
5403         }
5404         if (notifyAncestors) {
5405             synchronized (getTreeLock()) {
5406                 adjustListeningChildrenOnParent(AWTEvent.HIERARCHY_EVENT_MASK,
5407                                                 -1);
5408             }
5409         }
5410     }
5411 
5412     /**
5413      * Returns an array of all the hierarchy listeners
5414      * registered on this component.
5415      *
5416      * @return all of this component's &lt;code&gt;HierarchyListener&lt;/code&gt;s
5417      *         or an empty array if no hierarchy
5418      *         listeners are currently registered
5419      *
5420      * @see      #addHierarchyListener
5421      * @see      #removeHierarchyListener
5422      * @since    1.4
5423      */
5424     public synchronized HierarchyListener[] getHierarchyListeners() {
5425         return getListeners(HierarchyListener.class);
5426     }
5427 
5428     /**
5429      * Adds the specified hierarchy bounds listener to receive hierarchy
5430      * bounds events from this component when the hierarchy to which this
5431      * container belongs changes.
5432      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5433      * no exception is thrown and no action is performed.
5434      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5435      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5436      *
5437      * @param    l   the hierarchy bounds listener
5438      * @see      java.awt.event.HierarchyEvent
5439      * @see      java.awt.event.HierarchyBoundsListener
5440      * @see      #removeHierarchyBoundsListener
5441      * @see      #getHierarchyBoundsListeners
5442      * @since    1.3
5443      */
5444     public void addHierarchyBoundsListener(HierarchyBoundsListener l) {
5445         if (l == null) {
5446             return;
5447         }
5448         boolean notifyAncestors;
5449         synchronized (this) {
5450             notifyAncestors =
5451                 (hierarchyBoundsListener == null &amp;&amp;
5452                  (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0);
5453             hierarchyBoundsListener =
5454                 AWTEventMulticaster.add(hierarchyBoundsListener, l);
5455             notifyAncestors = (notifyAncestors &amp;&amp;
5456                                hierarchyBoundsListener != null);
5457             newEventsOnly = true;
5458         }
5459         if (notifyAncestors) {
5460             synchronized (getTreeLock()) {
5461                 adjustListeningChildrenOnParent(
5462                                                 AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK, 1);
5463             }
5464         }
5465     }
5466 
5467     /**
5468      * Removes the specified hierarchy bounds listener so that it no longer
5469      * receives hierarchy bounds events from this component. This method
5470      * performs no function, nor does it throw an exception, if the listener
5471      * specified by the argument was not previously added to this component.
5472      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5473      * no exception is thrown and no action is performed.
5474      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5475      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5476      *
5477      * @param    l   the hierarchy bounds listener
5478      * @see      java.awt.event.HierarchyEvent
5479      * @see      java.awt.event.HierarchyBoundsListener
5480      * @see      #addHierarchyBoundsListener
5481      * @see      #getHierarchyBoundsListeners
5482      * @since    1.3
5483      */
5484     public void removeHierarchyBoundsListener(HierarchyBoundsListener l) {
5485         if (l == null) {
5486             return;
5487         }
5488         boolean notifyAncestors;
5489         synchronized (this) {
5490             notifyAncestors =
5491                 (hierarchyBoundsListener != null &amp;&amp;
5492                  (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0);
5493             hierarchyBoundsListener =
5494                 AWTEventMulticaster.remove(hierarchyBoundsListener, l);
5495             notifyAncestors = (notifyAncestors &amp;&amp;
5496                                hierarchyBoundsListener == null);
5497         }
5498         if (notifyAncestors) {
5499             synchronized (getTreeLock()) {
5500                 adjustListeningChildrenOnParent(
5501                                                 AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK, -1);
5502             }
5503         }
5504     }
5505 
5506     // Should only be called while holding the tree lock
5507     int numListening(long mask) {
5508         // One mask or the other, but not neither or both.
5509         if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
5510             if ((mask != AWTEvent.HIERARCHY_EVENT_MASK) &amp;&amp;
5511                 (mask != AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK))
5512             {
5513                 eventLog.fine("Assertion failed");
5514             }
5515         }
5516         if ((mask == AWTEvent.HIERARCHY_EVENT_MASK &amp;&amp;
5517              (hierarchyListener != null ||
5518               (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0)) ||
5519             (mask == AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK &amp;&amp;
5520              (hierarchyBoundsListener != null ||
5521               (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0))) {
5522             return 1;
5523         } else {
5524             return 0;
5525         }
5526     }
5527 
5528     // Should only be called while holding tree lock
5529     int countHierarchyMembers() {
5530         return 1;
5531     }
5532     // Should only be called while holding the tree lock
5533     int createHierarchyEvents(int id, Component changed,
5534                               Container changedParent, long changeFlags,
5535                               boolean enabledOnToolkit) {
5536         switch (id) {
5537           case HierarchyEvent.HIERARCHY_CHANGED:
5538               if (hierarchyListener != null ||
5539                   (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||
5540                   enabledOnToolkit) {
5541                   HierarchyEvent e = new HierarchyEvent(this, id, changed,
5542                                                         changedParent,
5543                                                         changeFlags);
5544                   dispatchEvent(e);
5545                   return 1;
5546               }
5547               break;
5548           case HierarchyEvent.ANCESTOR_MOVED:
5549           case HierarchyEvent.ANCESTOR_RESIZED:
5550               if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
5551                   if (changeFlags != 0) {
5552                       eventLog.fine("Assertion (changeFlags == 0) failed");
5553                   }
5554               }
5555               if (hierarchyBoundsListener != null ||
5556                   (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 ||
5557                   enabledOnToolkit) {
5558                   HierarchyEvent e = new HierarchyEvent(this, id, changed,
5559                                                         changedParent);
5560                   dispatchEvent(e);
5561                   return 1;
5562               }
5563               break;
5564           default:
5565               // assert false
5566               if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
5567                   eventLog.fine("This code must never be reached");
5568               }
5569               break;
5570         }
5571         return 0;
5572     }
5573 
5574     /**
5575      * Returns an array of all the hierarchy bounds listeners
5576      * registered on this component.
5577      *
5578      * @return all of this component's &lt;code&gt;HierarchyBoundsListener&lt;/code&gt;s
5579      *         or an empty array if no hierarchy bounds
5580      *         listeners are currently registered
5581      *
5582      * @see      #addHierarchyBoundsListener
5583      * @see      #removeHierarchyBoundsListener
5584      * @since    1.4
5585      */
5586     public synchronized HierarchyBoundsListener[] getHierarchyBoundsListeners() {
5587         return getListeners(HierarchyBoundsListener.class);
5588     }
5589 
5590     /*
5591      * Should only be called while holding the tree lock.
5592      * It's added only for overriding in java.awt.Window
5593      * because parent in Window is owner.
5594      */
5595     void adjustListeningChildrenOnParent(long mask, int num) {
5596         if (parent != null) {
5597             parent.adjustListeningChildren(mask, num);
5598         }
5599     }
5600 
5601     /**
5602      * Adds the specified key listener to receive key events from
5603      * this component.
5604      * If l is null, no exception is thrown and no action is performed.
5605      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5606      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5607      *
5608      * @param    l   the key listener.
5609      * @see      java.awt.event.KeyEvent
5610      * @see      java.awt.event.KeyListener
5611      * @see      #removeKeyListener
5612      * @see      #getKeyListeners
5613      * @since    JDK1.1
5614      */
5615     public synchronized void addKeyListener(KeyListener l) {
5616         if (l == null) {
5617             return;
5618         }
5619         keyListener = AWTEventMulticaster.add(keyListener, l);
5620         newEventsOnly = true;
5621 
5622         // if this is a lightweight component, enable key events
5623         // in the native container.
5624         if (peer instanceof LightweightPeer) {
5625             parent.proxyEnableEvents(AWTEvent.KEY_EVENT_MASK);
5626         }
5627     }
5628 
5629     /**
5630      * Removes the specified key listener so that it no longer
5631      * receives key events from this component. This method performs
5632      * no function, nor does it throw an exception, if the listener
5633      * specified by the argument was not previously added to this component.
5634      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5635      * no exception is thrown and no action is performed.
5636      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5637      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5638      *
5639      * @param    l   the key listener
5640      * @see      java.awt.event.KeyEvent
5641      * @see      java.awt.event.KeyListener
5642      * @see      #addKeyListener
5643      * @see      #getKeyListeners
5644      * @since    JDK1.1
5645      */
5646     public synchronized void removeKeyListener(KeyListener l) {
5647         if (l == null) {
5648             return;
5649         }
5650         keyListener = AWTEventMulticaster.remove(keyListener, l);
5651     }
5652 
5653     /**
5654      * Returns an array of all the key listeners
5655      * registered on this component.
5656      *
5657      * @return all of this component's &lt;code&gt;KeyListener&lt;/code&gt;s
5658      *         or an empty array if no key
5659      *         listeners are currently registered
5660      *
5661      * @see      #addKeyListener
5662      * @see      #removeKeyListener
5663      * @since    1.4
5664      */
5665     public synchronized KeyListener[] getKeyListeners() {
5666         return getListeners(KeyListener.class);
5667     }
5668 
5669     /**
5670      * Adds the specified mouse listener to receive mouse events from
5671      * this component.
5672      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5673      * no exception is thrown and no action is performed.
5674      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5675      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5676      *
5677      * @param    l   the mouse listener
5678      * @see      java.awt.event.MouseEvent
5679      * @see      java.awt.event.MouseListener
5680      * @see      #removeMouseListener
5681      * @see      #getMouseListeners
5682      * @since    JDK1.1
5683      */
5684     public synchronized void addMouseListener(MouseListener l) {
5685         if (l == null) {
5686             return;
5687         }
5688         mouseListener = AWTEventMulticaster.add(mouseListener,l);
5689         newEventsOnly = true;
5690 
5691         // if this is a lightweight component, enable mouse events
5692         // in the native container.
5693         if (peer instanceof LightweightPeer) {
5694             parent.proxyEnableEvents(AWTEvent.MOUSE_EVENT_MASK);
5695         }
5696     }
5697 
5698     /**
5699      * Removes the specified mouse listener so that it no longer
5700      * receives mouse events from this component. This method performs
5701      * no function, nor does it throw an exception, if the listener
5702      * specified by the argument was not previously added to this component.
5703      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5704      * no exception is thrown and no action is performed.
5705      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5706      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5707      *
5708      * @param    l   the mouse listener
5709      * @see      java.awt.event.MouseEvent
5710      * @see      java.awt.event.MouseListener
5711      * @see      #addMouseListener
5712      * @see      #getMouseListeners
5713      * @since    JDK1.1
5714      */
5715     public synchronized void removeMouseListener(MouseListener l) {
5716         if (l == null) {
5717             return;
5718         }
5719         mouseListener = AWTEventMulticaster.remove(mouseListener, l);
5720     }
5721 
5722     /**
5723      * Returns an array of all the mouse listeners
5724      * registered on this component.
5725      *
5726      * @return all of this component's &lt;code&gt;MouseListener&lt;/code&gt;s
5727      *         or an empty array if no mouse
5728      *         listeners are currently registered
5729      *
5730      * @see      #addMouseListener
5731      * @see      #removeMouseListener
5732      * @since    1.4
5733      */
5734     public synchronized MouseListener[] getMouseListeners() {
5735         return getListeners(MouseListener.class);
5736     }
5737 
5738     /**
5739      * Adds the specified mouse motion listener to receive mouse motion
5740      * events from this component.
5741      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5742      * no exception is thrown and no action is performed.
5743      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5744      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5745      *
5746      * @param    l   the mouse motion listener
5747      * @see      java.awt.event.MouseEvent
5748      * @see      java.awt.event.MouseMotionListener
5749      * @see      #removeMouseMotionListener
5750      * @see      #getMouseMotionListeners
5751      * @since    JDK1.1
5752      */
5753     public synchronized void addMouseMotionListener(MouseMotionListener l) {
5754         if (l == null) {
5755             return;
5756         }
5757         mouseMotionListener = AWTEventMulticaster.add(mouseMotionListener,l);
5758         newEventsOnly = true;
5759 
5760         // if this is a lightweight component, enable mouse events
5761         // in the native container.
5762         if (peer instanceof LightweightPeer) {
5763             parent.proxyEnableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);
5764         }
5765     }
5766 
5767     /**
5768      * Removes the specified mouse motion listener so that it no longer
5769      * receives mouse motion events from this component. This method performs
5770      * no function, nor does it throw an exception, if the listener
5771      * specified by the argument was not previously added to this component.
5772      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5773      * no exception is thrown and no action is performed.
5774      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5775      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5776      *
5777      * @param    l   the mouse motion listener
5778      * @see      java.awt.event.MouseEvent
5779      * @see      java.awt.event.MouseMotionListener
5780      * @see      #addMouseMotionListener
5781      * @see      #getMouseMotionListeners
5782      * @since    JDK1.1
5783      */
5784     public synchronized void removeMouseMotionListener(MouseMotionListener l) {
5785         if (l == null) {
5786             return;
5787         }
5788         mouseMotionListener = AWTEventMulticaster.remove(mouseMotionListener, l);
5789     }
5790 
5791     /**
5792      * Returns an array of all the mouse motion listeners
5793      * registered on this component.
5794      *
5795      * @return all of this component's &lt;code&gt;MouseMotionListener&lt;/code&gt;s
5796      *         or an empty array if no mouse motion
5797      *         listeners are currently registered
5798      *
5799      * @see      #addMouseMotionListener
5800      * @see      #removeMouseMotionListener
5801      * @since    1.4
5802      */
5803     public synchronized MouseMotionListener[] getMouseMotionListeners() {
5804         return getListeners(MouseMotionListener.class);
5805     }
5806 
5807     /**
5808      * Adds the specified mouse wheel listener to receive mouse wheel events
5809      * from this component.  Containers also receive mouse wheel events from
5810      * sub-components.
5811      * &lt;p&gt;
5812      * For information on how mouse wheel events are dispatched, see
5813      * the class description for {@link MouseWheelEvent}.
5814      * &lt;p&gt;
5815      * If l is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no
5816      * action is performed.
5817      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5818      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5819      *
5820      * @param    l   the mouse wheel listener
5821      * @see      java.awt.event.MouseWheelEvent
5822      * @see      java.awt.event.MouseWheelListener
5823      * @see      #removeMouseWheelListener
5824      * @see      #getMouseWheelListeners
5825      * @since    1.4
5826      */
5827     public synchronized void addMouseWheelListener(MouseWheelListener l) {
5828         if (l == null) {
5829             return;
5830         }
5831         mouseWheelListener = AWTEventMulticaster.add(mouseWheelListener,l);
5832         newEventsOnly = true;
5833 
5834         // if this is a lightweight component, enable mouse events
5835         // in the native container.
5836         if (peer instanceof LightweightPeer) {
5837             parent.proxyEnableEvents(AWTEvent.MOUSE_WHEEL_EVENT_MASK);
5838         }
5839     }
5840 
5841     /**
5842      * Removes the specified mouse wheel listener so that it no longer
5843      * receives mouse wheel events from this component. This method performs
5844      * no function, nor does it throw an exception, if the listener
5845      * specified by the argument was not previously added to this component.
5846      * If l is null, no exception is thrown and no action is performed.
5847      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5848      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5849      *
5850      * @param    l   the mouse wheel listener.
5851      * @see      java.awt.event.MouseWheelEvent
5852      * @see      java.awt.event.MouseWheelListener
5853      * @see      #addMouseWheelListener
5854      * @see      #getMouseWheelListeners
5855      * @since    1.4
5856      */
5857     public synchronized void removeMouseWheelListener(MouseWheelListener l) {
5858         if (l == null) {
5859             return;
5860         }
5861         mouseWheelListener = AWTEventMulticaster.remove(mouseWheelListener, l);
5862     }
5863 
5864     /**
5865      * Returns an array of all the mouse wheel listeners
5866      * registered on this component.
5867      *
5868      * @return all of this component's &lt;code&gt;MouseWheelListener&lt;/code&gt;s
5869      *         or an empty array if no mouse wheel
5870      *         listeners are currently registered
5871      *
5872      * @see      #addMouseWheelListener
5873      * @see      #removeMouseWheelListener
5874      * @since    1.4
5875      */
5876     public synchronized MouseWheelListener[] getMouseWheelListeners() {
5877         return getListeners(MouseWheelListener.class);
5878     }
5879 
5880     /**
5881      * Adds the specified input method listener to receive
5882      * input method events from this component. A component will
5883      * only receive input method events from input methods
5884      * if it also overrides &lt;code&gt;getInputMethodRequests&lt;/code&gt; to return an
5885      * &lt;code&gt;InputMethodRequests&lt;/code&gt; instance.
5886      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5887      * no exception is thrown and no action is performed.
5888      * &lt;p&gt;Refer to &lt;a href="{@docRoot}/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads"
5889      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5890      *
5891      * @param    l   the input method listener
5892      * @see      java.awt.event.InputMethodEvent
5893      * @see      java.awt.event.InputMethodListener
5894      * @see      #removeInputMethodListener
5895      * @see      #getInputMethodListeners
5896      * @see      #getInputMethodRequests
5897      * @since    1.2
5898      */
5899     public synchronized void addInputMethodListener(InputMethodListener l) {
5900         if (l == null) {
5901             return;
5902         }
5903         inputMethodListener = AWTEventMulticaster.add(inputMethodListener, l);
5904         newEventsOnly = true;
5905     }
5906 
5907     /**
5908      * Removes the specified input method listener so that it no longer
5909      * receives input method events from this component. This method performs
5910      * no function, nor does it throw an exception, if the listener
5911      * specified by the argument was not previously added to this component.
5912      * If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
5913      * no exception is thrown and no action is performed.
5914      * &lt;p&gt;Refer to &lt;a href="doc-files/AWTThreadIssues.html#ListenersThreads"
5915      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT's threading model.
5916      *
5917      * @param    l   the input method listener
5918      * @see      java.awt.event.InputMethodEvent
5919      * @see      java.awt.event.InputMethodListener
5920      * @see      #addInputMethodListener
5921      * @see      #getInputMethodListeners
5922      * @since    1.2
5923      */
5924     public synchronized void removeInputMethodListener(InputMethodListener l) {
5925         if (l == null) {
5926             return;
5927         }
5928         inputMethodListener = AWTEventMulticaster.remove(inputMethodListener, l);
5929     }
5930 
5931     /**
5932      * Returns an array of all the input method listeners
5933      * registered on this component.
5934      *
5935      * @return all of this component's &lt;code&gt;InputMethodListener&lt;/code&gt;s
5936      *         or an empty array if no input method
5937      *         listeners are currently registered
5938      *
5939      * @see      #addInputMethodListener
5940      * @see      #removeInputMethodListener
5941      * @since    1.4
5942      */
5943     public synchronized InputMethodListener[] getInputMethodListeners() {
5944         return getListeners(InputMethodListener.class);
5945     }
5946 
5947     /**
5948      * Returns an array of all the objects currently registered
5949      * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
5950      * upon this &lt;code&gt;Component&lt;/code&gt;.
5951      * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
5952      * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
5953      *
5954      * &lt;p&gt;
5955      * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
5956      * with a class literal, such as
5957      * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
5958      * For example, you can query a
5959      * &lt;code&gt;Component&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
5960      * for its mouse listeners with the following code:
5961      *
5962      * &lt;pre&gt;MouseListener[] mls = (MouseListener[])(c.getListeners(MouseListener.class));&lt;/pre&gt;
5963      *
5964      * If no such listeners exist, this method returns an empty array.
5965      *
5966      * @param listenerType the type of listeners requested; this parameter
5967      *          should specify an interface that descends from
5968      *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
5969      * @return an array of all objects registered as
5970      *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this component,
5971      *          or an empty array if no such listeners have been added
5972      * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
5973      *          doesn't specify a class or interface that implements
5974      *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
5975      * @throws NullPointerException if {@code listenerType} is {@code null}
5976      * @see #getComponentListeners
5977      * @see #getFocusListeners
5978      * @see #getHierarchyListeners
5979      * @see #getHierarchyBoundsListeners
5980      * @see #getKeyListeners
5981      * @see #getMouseListeners
5982      * @see #getMouseMotionListeners
5983      * @see #getMouseWheelListeners
5984      * @see #getInputMethodListeners
5985      * @see #getPropertyChangeListeners
5986      *
5987      * @since 1.3
5988      */
5989     @SuppressWarnings("unchecked")
5990     public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
5991         EventListener l = null;
5992         if  (listenerType == ComponentListener.class) {
5993             l = componentListener;
5994         } else if (listenerType == FocusListener.class) {
5995             l = focusListener;
5996         } else if (listenerType == HierarchyListener.class) {
5997             l = hierarchyListener;
5998         } else if (listenerType == HierarchyBoundsListener.class) {
5999             l = hierarchyBoundsListener;
6000         } else if (listenerType == KeyListener.class) {
6001             l = keyListener;
6002         } else if (listenerType == MouseListener.class) {
6003             l = mouseListener;
6004         } else if (listenerType == MouseMotionListener.class) {
6005             l = mouseMotionListener;
6006         } else if (listenerType == MouseWheelListener.class) {
6007             l = mouseWheelListener;
6008         } else if (listenerType == InputMethodListener.class) {
6009             l = inputMethodListener;
6010         } else if (listenerType == PropertyChangeListener.class) {
6011             return (T[])getPropertyChangeListeners();
6012         }
6013         return AWTEventMulticaster.getListeners(l, listenerType);
6014     }
6015 
6016     /**
6017      * Gets the input method request handler which supports
6018      * requests from input methods for this component. A component
6019      * that supports on-the-spot text input must override this
6020      * method to return an &lt;code&gt;InputMethodRequests&lt;/code&gt; instance.
6021      * At the same time, it also has to handle input method events.
6022      *
6023      * @return the input method request handler for this component,
6024      *          &lt;code&gt;null&lt;/code&gt; by default
6025      * @see #addInputMethodListener
6026      * @since 1.2
6027      */
6028     public InputMethodRequests getInputMethodRequests() {
6029         return null;
6030     }
6031 
6032     /**
6033      * Gets the input context used by this component for handling
6034      * the communication with input methods when text is entered
6035      * in this component. By default, the input context used for
6036      * the parent component is returned. Components may
6037      * override this to return a private input context.
6038      *
6039      * @return the input context used by this component;
6040      *          &lt;code&gt;null&lt;/code&gt; if no context can be determined
6041      * @since 1.2
6042      */
6043     public InputContext getInputContext() {
6044         Container parent = this.parent;
6045         if (parent == null) {
6046             return null;
6047         } else {
6048             return parent.getInputContext();
6049         }
6050     }
6051 
6052     /**
6053      * Enables the events defined by the specified event mask parameter
6054      * to be delivered to this component.
6055      * &lt;p&gt;
6056      * Event types are automatically enabled when a listener for
6057      * that event type is added to the component.
6058      * &lt;p&gt;
6059      * This method only needs to be invoked by subclasses of
6060      * &lt;code&gt;Component&lt;/code&gt; which desire to have the specified event
6061      * types delivered to &lt;code&gt;processEvent&lt;/code&gt; regardless of whether
6062      * or not a listener is registered.
6063      * @param      eventsToEnable   the event mask defining the event types
6064      * @see        #processEvent
6065      * @see        #disableEvents
6066      * @see        AWTEvent
6067      * @since      JDK1.1
6068      */
6069     protected final void enableEvents(long eventsToEnable) {
6070         long notifyAncestors = 0;
6071         synchronized (this) {
6072             if ((eventsToEnable &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 &amp;&amp;
6073                 hierarchyListener == null &amp;&amp;
6074                 (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) == 0) {
6075                 notifyAncestors |= AWTEvent.HIERARCHY_EVENT_MASK;
6076             }
6077             if ((eventsToEnable &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 &amp;&amp;
6078                 hierarchyBoundsListener == null &amp;&amp;
6079                 (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0) {
6080                 notifyAncestors |= AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK;
6081             }
6082             eventMask |= eventsToEnable;
6083             newEventsOnly = true;
6084         }
6085 
6086         // if this is a lightweight component, enable mouse events
6087         // in the native container.
6088         if (peer instanceof LightweightPeer) {
6089             parent.proxyEnableEvents(eventMask);
6090         }
6091         if (notifyAncestors != 0) {
6092             synchronized (getTreeLock()) {
6093                 adjustListeningChildrenOnParent(notifyAncestors, 1);
6094             }
6095         }
6096     }
6097 
6098     /**
6099      * Disables the events defined by the specified event mask parameter
6100      * from being delivered to this component.
6101      * @param      eventsToDisable   the event mask defining the event types
6102      * @see        #enableEvents
6103      * @since      JDK1.1
6104      */
6105     protected final void disableEvents(long eventsToDisable) {
6106         long notifyAncestors = 0;
6107         synchronized (this) {
6108             if ((eventsToDisable &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 &amp;&amp;
6109                 hierarchyListener == null &amp;&amp;
6110                 (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0) {
6111                 notifyAncestors |= AWTEvent.HIERARCHY_EVENT_MASK;
6112             }
6113             if ((eventsToDisable &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK)!=0 &amp;&amp;
6114                 hierarchyBoundsListener == null &amp;&amp;
6115                 (eventMask &amp; AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0) {
6116                 notifyAncestors |= AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK;
6117             }
6118             eventMask &amp;= ~eventsToDisable;
6119         }
6120         if (notifyAncestors != 0) {
6121             synchronized (getTreeLock()) {
6122                 adjustListeningChildrenOnParent(notifyAncestors, -1);
6123             }
6124         }
6125     }
6126 
6127     transient sun.awt.EventQueueItem[] eventCache;
6128 
6129     /**
6130      * @see #isCoalescingEnabled
6131      * @see #checkCoalescing
6132      */
6133     transient private boolean coalescingEnabled = checkCoalescing();
6134 
6135     /**
6136      * Weak map of known coalesceEvent overriders.
6137      * Value indicates whether overriden.
6138      * Bootstrap classes are not included.
6139      */
6140     private static final Map&lt;Class&lt;?&gt;, Boolean&gt; coalesceMap =
6141         new java.util.WeakHashMap&lt;Class&lt;?&gt;, Boolean&gt;();
6142 
6143     /**
6144      * Indicates whether this class overrides coalesceEvents.
6145      * It is assumed that all classes that are loaded from the bootstrap
6146      *   do not.
6147      * The boostrap class loader is assumed to be represented by null.
6148      * We do not check that the method really overrides
6149      *   (it might be static, private or package private).
6150      */
6151      private boolean checkCoalescing() {
6152          if (getClass().getClassLoader()==null) {
6153              return false;
6154          }
6155          final Class&lt;? extends Component&gt; clazz = getClass();
6156          synchronized (coalesceMap) {
6157              // Check cache.
6158              Boolean value = coalesceMap.get(clazz);
6159              if (value != null) {
6160                  return value;
6161              }
6162 
6163              // Need to check non-bootstraps.
6164              Boolean enabled = java.security.AccessController.doPrivileged(
6165                  new java.security.PrivilegedAction&lt;Boolean&gt;() {
6166                      public Boolean run() {
6167                          return isCoalesceEventsOverriden(clazz);
6168                      }
6169                  }
6170                  );
6171              coalesceMap.put(clazz, enabled);
6172              return enabled;
6173          }
6174      }
6175 
6176     /**
6177      * Parameter types of coalesceEvents(AWTEvent,AWTEVent).
6178      */
6179     private static final Class[] coalesceEventsParams = {
6180         AWTEvent.class, AWTEvent.class
6181     };
6182 
6183     /**
6184      * Indicates whether a class or its superclasses override coalesceEvents.
6185      * Must be called with lock on coalesceMap and privileged.
6186      * @see checkCoalsecing
6187      */
6188     private static boolean isCoalesceEventsOverriden(Class&lt;?&gt; clazz) {
6189         assert Thread.holdsLock(coalesceMap);
6190 
6191         // First check superclass - we may not need to bother ourselves.
6192         Class&lt;?&gt; superclass = clazz.getSuperclass();
6193         if (superclass == null) {
6194             // Only occurs on implementations that
6195             //   do not use null to represent the bootsrap class loader.
6196             return false;
6197         }
6198         if (superclass.getClassLoader() != null) {
6199             Boolean value = coalesceMap.get(superclass);
6200             if (value == null) {
6201                 // Not done already - recurse.
6202                 if (isCoalesceEventsOverriden(superclass)) {
6203                     coalesceMap.put(superclass, true);
6204                     return true;
6205                 }
6206             } else if (value) {
6207                 return true;
6208             }
6209         }
6210 
6211         try {
6212             // Throws if not overriden.
6213             clazz.getDeclaredMethod(
6214                 "coalesceEvents", coalesceEventsParams
6215                 );
6216             return true;
6217         } catch (NoSuchMethodException e) {
6218             // Not present in this class.
6219             return false;
6220         }
6221     }
6222 
6223     /**
6224      * Indicates whether coalesceEvents may do something.
6225      */
6226     final boolean isCoalescingEnabled() {
6227         return coalescingEnabled;
6228      }
6229 
6230 
6231     /**
6232      * Potentially coalesce an event being posted with an existing
6233      * event.  This method is called by &lt;code&gt;EventQueue.postEvent&lt;/code&gt;
6234      * if an event with the same ID as the event to be posted is found in
6235      * the queue (both events must have this component as their source).
6236      * This method either returns a coalesced event which replaces
6237      * the existing event (and the new event is then discarded), or
6238      * &lt;code&gt;null&lt;/code&gt; to indicate that no combining should be done
6239      * (add the second event to the end of the queue).  Either event
6240      * parameter may be modified and returned, as the other one is discarded
6241      * unless &lt;code&gt;null&lt;/code&gt; is returned.
6242      * &lt;p&gt;
6243      * This implementation of &lt;code&gt;coalesceEvents&lt;/code&gt; coalesces
6244      * two event types: mouse move (and drag) events,
6245      * and paint (and update) events.
6246      * For mouse move events the last event is always returned, causing
6247      * intermediate moves to be discarded.  For paint events, the new
6248      * event is coalesced into a complex &lt;code&gt;RepaintArea&lt;/code&gt; in the peer.
6249      * The new &lt;code&gt;AWTEvent&lt;/code&gt; is always returned.
6250      *
6251      * @param  existingEvent  the event already on the &lt;code&gt;EventQueue&lt;/code&gt;
6252      * @param  newEvent       the event being posted to the
6253      *          &lt;code&gt;EventQueue&lt;/code&gt;
6254      * @return a coalesced event, or &lt;code&gt;null&lt;/code&gt; indicating that no
6255      *          coalescing was done
6256      */
6257     protected AWTEvent coalesceEvents(AWTEvent existingEvent,
6258                                       AWTEvent newEvent) {
6259         return null;
6260     }
6261 
6262     /**
6263      * Processes events occurring on this component. By default this
6264      * method calls the appropriate
6265      * &lt;code&gt;process&amp;lt;event&amp;nbsp;type&amp;gt;Event&lt;/code&gt;
6266      * method for the given class of event.
6267      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6268      * the behavior is unspecified and may result in an
6269      * exception.
6270      *
6271      * @param     e the event
6272      * @see       #processComponentEvent
6273      * @see       #processFocusEvent
6274      * @see       #processKeyEvent
6275      * @see       #processMouseEvent
6276      * @see       #processMouseMotionEvent
6277      * @see       #processInputMethodEvent
6278      * @see       #processHierarchyEvent
6279      * @see       #processMouseWheelEvent
6280      * @since     JDK1.1
6281      */
6282     protected void processEvent(AWTEvent e) {
6283         if (e instanceof FocusEvent) {
6284             processFocusEvent((FocusEvent)e);
6285 
6286         } else if (e instanceof MouseEvent) {
6287             switch(e.getID()) {
6288               case MouseEvent.MOUSE_PRESSED:
6289               case MouseEvent.MOUSE_RELEASED:
6290               case MouseEvent.MOUSE_CLICKED:
6291               case MouseEvent.MOUSE_ENTERED:
6292               case MouseEvent.MOUSE_EXITED:
6293                   processMouseEvent((MouseEvent)e);
6294                   break;
6295               case MouseEvent.MOUSE_MOVED:
6296               case MouseEvent.MOUSE_DRAGGED:
6297                   processMouseMotionEvent((MouseEvent)e);
6298                   break;
6299               case MouseEvent.MOUSE_WHEEL:
6300                   processMouseWheelEvent((MouseWheelEvent)e);
6301                   break;
6302             }
6303 
6304         } else if (e instanceof KeyEvent) {
6305             processKeyEvent((KeyEvent)e);
6306 
6307         } else if (e instanceof ComponentEvent) {
6308             processComponentEvent((ComponentEvent)e);
6309         } else if (e instanceof InputMethodEvent) {
6310             processInputMethodEvent((InputMethodEvent)e);
6311         } else if (e instanceof HierarchyEvent) {
6312             switch (e.getID()) {
6313               case HierarchyEvent.HIERARCHY_CHANGED:
6314                   processHierarchyEvent((HierarchyEvent)e);
6315                   break;
6316               case HierarchyEvent.ANCESTOR_MOVED:
6317               case HierarchyEvent.ANCESTOR_RESIZED:
6318                   processHierarchyBoundsEvent((HierarchyEvent)e);
6319                   break;
6320             }
6321         }
6322     }
6323 
6324     /**
6325      * Processes component events occurring on this component by
6326      * dispatching them to any registered
6327      * &lt;code&gt;ComponentListener&lt;/code&gt; objects.
6328      * &lt;p&gt;
6329      * This method is not called unless component events are
6330      * enabled for this component. Component events are enabled
6331      * when one of the following occurs:
6332      * &lt;ul&gt;
6333      * &lt;li&gt;A &lt;code&gt;ComponentListener&lt;/code&gt; object is registered
6334      * via &lt;code&gt;addComponentListener&lt;/code&gt;.
6335      * &lt;li&gt;Component events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6336      * &lt;/ul&gt;
6337      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6338      * the behavior is unspecified and may result in an
6339      * exception.
6340      *
6341      * @param       e the component event
6342      * @see         java.awt.event.ComponentEvent
6343      * @see         java.awt.event.ComponentListener
6344      * @see         #addComponentListener
6345      * @see         #enableEvents
6346      * @since       JDK1.1
6347      */
6348     protected void processComponentEvent(ComponentEvent e) {
6349         ComponentListener listener = componentListener;
6350         if (listener != null) {
6351             int id = e.getID();
6352             switch(id) {
6353               case ComponentEvent.COMPONENT_RESIZED:
6354                   listener.componentResized(e);
6355                   break;
6356               case ComponentEvent.COMPONENT_MOVED:
6357                   listener.componentMoved(e);
6358                   break;
6359               case ComponentEvent.COMPONENT_SHOWN:
6360                   listener.componentShown(e);
6361                   break;
6362               case ComponentEvent.COMPONENT_HIDDEN:
6363                   listener.componentHidden(e);
6364                   break;
6365             }
6366         }
6367     }
6368 
6369     /**
6370      * Processes focus events occurring on this component by
6371      * dispatching them to any registered
6372      * &lt;code&gt;FocusListener&lt;/code&gt; objects.
6373      * &lt;p&gt;
6374      * This method is not called unless focus events are
6375      * enabled for this component. Focus events are enabled
6376      * when one of the following occurs:
6377      * &lt;ul&gt;
6378      * &lt;li&gt;A &lt;code&gt;FocusListener&lt;/code&gt; object is registered
6379      * via &lt;code&gt;addFocusListener&lt;/code&gt;.
6380      * &lt;li&gt;Focus events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6381      * &lt;/ul&gt;
6382      * &lt;p&gt;
6383      * If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;,
6384      * the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines
6385      * whether or not a focus event should be dispatched to
6386      * registered &lt;code&gt;FocusListener&lt;/code&gt; objects.  If the
6387      * events are to be dispatched, the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
6388      * calls the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt;
6389      * method, which results in a call to the &lt;code&gt;Component&lt;/code&gt;'s
6390      * &lt;code&gt;processFocusEvent&lt;/code&gt; method.
6391      * &lt;p&gt;
6392      * If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, calling
6393      * the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method
6394      * with a &lt;code&gt;FocusEvent&lt;/code&gt; as the argument will result in a
6395      * call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt;
6396      * method regardless of the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
6397      *
6398      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6399      * the behavior is unspecified and may result in an
6400      * exception.
6401      *
6402      * @param       e the focus event
6403      * @see         java.awt.event.FocusEvent
6404      * @see         java.awt.event.FocusListener
6405      * @see         java.awt.KeyboardFocusManager
6406      * @see         #addFocusListener
6407      * @see         #enableEvents
6408      * @see         #dispatchEvent
6409      * @since       JDK1.1
6410      */
6411     protected void processFocusEvent(FocusEvent e) {
6412         FocusListener listener = focusListener;
6413         if (listener != null) {
6414             int id = e.getID();
6415             switch(id) {
6416               case FocusEvent.FOCUS_GAINED:
6417                   listener.focusGained(e);
6418                   break;
6419               case FocusEvent.FOCUS_LOST:
6420                   listener.focusLost(e);
6421                   break;
6422             }
6423         }
6424     }
6425 
6426     /**
6427      * Processes key events occurring on this component by
6428      * dispatching them to any registered
6429      * &lt;code&gt;KeyListener&lt;/code&gt; objects.
6430      * &lt;p&gt;
6431      * This method is not called unless key events are
6432      * enabled for this component. Key events are enabled
6433      * when one of the following occurs:
6434      * &lt;ul&gt;
6435      * &lt;li&gt;A &lt;code&gt;KeyListener&lt;/code&gt; object is registered
6436      * via &lt;code&gt;addKeyListener&lt;/code&gt;.
6437      * &lt;li&gt;Key events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6438      * &lt;/ul&gt;
6439      *
6440      * &lt;p&gt;
6441      * If key events are enabled for a &lt;code&gt;Component&lt;/code&gt;,
6442      * the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines
6443      * whether or not a key event should be dispatched to
6444      * registered &lt;code&gt;KeyListener&lt;/code&gt; objects.  The
6445      * &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; will not dispatch
6446      * key events to a &lt;code&gt;Component&lt;/code&gt; that is not the focus
6447      * owner or is not showing.
6448      * &lt;p&gt;
6449      * As of J2SE 1.4, &lt;code&gt;KeyEvent&lt;/code&gt;s are redirected to
6450      * the focus owner. Please see the
6451      * &lt;a href="doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
6452      * for further information.
6453      * &lt;p&gt;
6454      * Calling a &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt;
6455      * method with a &lt;code&gt;KeyEvent&lt;/code&gt; as the argument will
6456      * result in a call to the &lt;code&gt;Component&lt;/code&gt;'s
6457      * &lt;code&gt;processKeyEvent&lt;/code&gt; method regardless of the
6458      * current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; as long as the
6459      * component is showing, focused, and enabled, and key events
6460      * are enabled on it.
6461      * &lt;p&gt;If the event parameter is &lt;code&gt;null&lt;/code&gt;
6462      * the behavior is unspecified and may result in an
6463      * exception.
6464      *
6465      * @param       e the key event
6466      * @see         java.awt.event.KeyEvent
6467      * @see         java.awt.event.KeyListener
6468      * @see         java.awt.KeyboardFocusManager
6469      * @see         java.awt.DefaultKeyboardFocusManager
6470      * @see         #processEvent
6471      * @see         #dispatchEvent
6472      * @see         #addKeyListener
6473      * @see         #enableEvents
6474      * @see         #isShowing
6475      * @since       JDK1.1
6476      */
6477     protected void processKeyEvent(KeyEvent e) {
6478         KeyListener listener = keyListener;
6479         if (listener != null) {
6480             int id = e.getID();
6481             switch(id) {
6482               case KeyEvent.KEY_TYPED:
6483                   listener.keyTyped(e);
6484                   break;
6485               case KeyEvent.KEY_PRESSED:
6486                   listener.keyPressed(e);
6487                   break;
6488               case KeyEvent.KEY_RELEASED:
6489                   listener.keyReleased(e);
6490                   break;
6491             }
6492         }
6493     }
6494 
6495     /**
6496      * Processes mouse events occurring on this component by
6497      * dispatching them to any registered
6498      * &lt;code&gt;MouseListener&lt;/code&gt; objects.
6499      * &lt;p&gt;
6500      * This method is not called unless mouse events are
6501      * enabled for this component. Mouse events are enabled
6502      * when one of the following occurs:
6503      * &lt;ul&gt;
6504      * &lt;li&gt;A &lt;code&gt;MouseListener&lt;/code&gt; object is registered
6505      * via &lt;code&gt;addMouseListener&lt;/code&gt;.
6506      * &lt;li&gt;Mouse events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6507      * &lt;/ul&gt;
6508      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6509      * the behavior is unspecified and may result in an
6510      * exception.
6511      *
6512      * @param       e the mouse event
6513      * @see         java.awt.event.MouseEvent
6514      * @see         java.awt.event.MouseListener
6515      * @see         #addMouseListener
6516      * @see         #enableEvents
6517      * @since       JDK1.1
6518      */
6519     protected void processMouseEvent(MouseEvent e) {
6520         MouseListener listener = mouseListener;
6521         if (listener != null) {
6522             int id = e.getID();
6523             switch(id) {
6524               case MouseEvent.MOUSE_PRESSED:
6525                   listener.mousePressed(e);
6526                   break;
6527               case MouseEvent.MOUSE_RELEASED:
6528                   listener.mouseReleased(e);
6529                   break;
6530               case MouseEvent.MOUSE_CLICKED:
6531                   listener.mouseClicked(e);
6532                   break;
6533               case MouseEvent.MOUSE_EXITED:
6534                   listener.mouseExited(e);
6535                   break;
6536               case MouseEvent.MOUSE_ENTERED:
6537                   listener.mouseEntered(e);
6538                   break;
6539             }
6540         }
6541     }
6542 
6543     /**
6544      * Processes mouse motion events occurring on this component by
6545      * dispatching them to any registered
6546      * &lt;code&gt;MouseMotionListener&lt;/code&gt; objects.
6547      * &lt;p&gt;
6548      * This method is not called unless mouse motion events are
6549      * enabled for this component. Mouse motion events are enabled
6550      * when one of the following occurs:
6551      * &lt;ul&gt;
6552      * &lt;li&gt;A &lt;code&gt;MouseMotionListener&lt;/code&gt; object is registered
6553      * via &lt;code&gt;addMouseMotionListener&lt;/code&gt;.
6554      * &lt;li&gt;Mouse motion events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6555      * &lt;/ul&gt;
6556      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6557      * the behavior is unspecified and may result in an
6558      * exception.
6559      *
6560      * @param       e the mouse motion event
6561      * @see         java.awt.event.MouseEvent
6562      * @see         java.awt.event.MouseMotionListener
6563      * @see         #addMouseMotionListener
6564      * @see         #enableEvents
6565      * @since       JDK1.1
6566      */
6567     protected void processMouseMotionEvent(MouseEvent e) {
6568         MouseMotionListener listener = mouseMotionListener;
6569         if (listener != null) {
6570             int id = e.getID();
6571             switch(id) {
6572               case MouseEvent.MOUSE_MOVED:
6573                   listener.mouseMoved(e);
6574                   break;
6575               case MouseEvent.MOUSE_DRAGGED:
6576                   listener.mouseDragged(e);
6577                   break;
6578             }
6579         }
6580     }
6581 
6582     /**
6583      * Processes mouse wheel events occurring on this component by
6584      * dispatching them to any registered
6585      * &lt;code&gt;MouseWheelListener&lt;/code&gt; objects.
6586      * &lt;p&gt;
6587      * This method is not called unless mouse wheel events are
6588      * enabled for this component. Mouse wheel events are enabled
6589      * when one of the following occurs:
6590      * &lt;ul&gt;
6591      * &lt;li&gt;A &lt;code&gt;MouseWheelListener&lt;/code&gt; object is registered
6592      * via &lt;code&gt;addMouseWheelListener&lt;/code&gt;.
6593      * &lt;li&gt;Mouse wheel events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6594      * &lt;/ul&gt;
6595      * &lt;p&gt;
6596      * For information on how mouse wheel events are dispatched, see
6597      * the class description for {@link MouseWheelEvent}.
6598      * &lt;p&gt;
6599      * Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6600      * the behavior is unspecified and may result in an
6601      * exception.
6602      *
6603      * @param       e the mouse wheel event
6604      * @see         java.awt.event.MouseWheelEvent
6605      * @see         java.awt.event.MouseWheelListener
6606      * @see         #addMouseWheelListener
6607      * @see         #enableEvents
6608      * @since       1.4
6609      */
6610     protected void processMouseWheelEvent(MouseWheelEvent e) {
6611         MouseWheelListener listener = mouseWheelListener;
6612         if (listener != null) {
6613             int id = e.getID();
6614             switch(id) {
6615               case MouseEvent.MOUSE_WHEEL:
6616                   listener.mouseWheelMoved(e);
6617                   break;
6618             }
6619         }
6620     }
6621 
6622     boolean postsOldMouseEvents() {
6623         return false;
6624     }
6625 
6626     /**
6627      * Processes input method events occurring on this component by
6628      * dispatching them to any registered
6629      * &lt;code&gt;InputMethodListener&lt;/code&gt; objects.
6630      * &lt;p&gt;
6631      * This method is not called unless input method events
6632      * are enabled for this component. Input method events are enabled
6633      * when one of the following occurs:
6634      * &lt;ul&gt;
6635      * &lt;li&gt;An &lt;code&gt;InputMethodListener&lt;/code&gt; object is registered
6636      * via &lt;code&gt;addInputMethodListener&lt;/code&gt;.
6637      * &lt;li&gt;Input method events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6638      * &lt;/ul&gt;
6639      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6640      * the behavior is unspecified and may result in an
6641      * exception.
6642      *
6643      * @param       e the input method event
6644      * @see         java.awt.event.InputMethodEvent
6645      * @see         java.awt.event.InputMethodListener
6646      * @see         #addInputMethodListener
6647      * @see         #enableEvents
6648      * @since       1.2
6649      */
6650     protected void processInputMethodEvent(InputMethodEvent e) {
6651         InputMethodListener listener = inputMethodListener;
6652         if (listener != null) {
6653             int id = e.getID();
6654             switch (id) {
6655               case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
6656                   listener.inputMethodTextChanged(e);
6657                   break;
6658               case InputMethodEvent.CARET_POSITION_CHANGED:
6659                   listener.caretPositionChanged(e);
6660                   break;
6661             }
6662         }
6663     }
6664 
6665     /**
6666      * Processes hierarchy events occurring on this component by
6667      * dispatching them to any registered
6668      * &lt;code&gt;HierarchyListener&lt;/code&gt; objects.
6669      * &lt;p&gt;
6670      * This method is not called unless hierarchy events
6671      * are enabled for this component. Hierarchy events are enabled
6672      * when one of the following occurs:
6673      * &lt;ul&gt;
6674      * &lt;li&gt;An &lt;code&gt;HierarchyListener&lt;/code&gt; object is registered
6675      * via &lt;code&gt;addHierarchyListener&lt;/code&gt;.
6676      * &lt;li&gt;Hierarchy events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6677      * &lt;/ul&gt;
6678      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6679      * the behavior is unspecified and may result in an
6680      * exception.
6681      *
6682      * @param       e the hierarchy event
6683      * @see         java.awt.event.HierarchyEvent
6684      * @see         java.awt.event.HierarchyListener
6685      * @see         #addHierarchyListener
6686      * @see         #enableEvents
6687      * @since       1.3
6688      */
6689     protected void processHierarchyEvent(HierarchyEvent e) {
6690         HierarchyListener listener = hierarchyListener;
6691         if (listener != null) {
6692             int id = e.getID();
6693             switch (id) {
6694               case HierarchyEvent.HIERARCHY_CHANGED:
6695                   listener.hierarchyChanged(e);
6696                   break;
6697             }
6698         }
6699     }
6700 
6701     /**
6702      * Processes hierarchy bounds events occurring on this component by
6703      * dispatching them to any registered
6704      * &lt;code&gt;HierarchyBoundsListener&lt;/code&gt; objects.
6705      * &lt;p&gt;
6706      * This method is not called unless hierarchy bounds events
6707      * are enabled for this component. Hierarchy bounds events are enabled
6708      * when one of the following occurs:
6709      * &lt;ul&gt;
6710      * &lt;li&gt;An &lt;code&gt;HierarchyBoundsListener&lt;/code&gt; object is registered
6711      * via &lt;code&gt;addHierarchyBoundsListener&lt;/code&gt;.
6712      * &lt;li&gt;Hierarchy bounds events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;.
6713      * &lt;/ul&gt;
6714      * &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
6715      * the behavior is unspecified and may result in an
6716      * exception.
6717      *
6718      * @param       e the hierarchy event
6719      * @see         java.awt.event.HierarchyEvent
6720      * @see         java.awt.event.HierarchyBoundsListener
6721      * @see         #addHierarchyBoundsListener
6722      * @see         #enableEvents
6723      * @since       1.3
6724      */
6725     protected void processHierarchyBoundsEvent(HierarchyEvent e) {
6726         HierarchyBoundsListener listener = hierarchyBoundsListener;
6727         if (listener != null) {
6728             int id = e.getID();
6729             switch (id) {
6730               case HierarchyEvent.ANCESTOR_MOVED:
6731                   listener.ancestorMoved(e);
6732                   break;
6733               case HierarchyEvent.ANCESTOR_RESIZED:
6734                   listener.ancestorResized(e);
6735                   break;
6736             }
6737         }
6738     }
6739 
6740     /**
6741      * @deprecated As of JDK version 1.1
6742      * replaced by processEvent(AWTEvent).
6743      */
6744     @Deprecated
6745     public boolean handleEvent(Event evt) {
6746         switch (evt.id) {
6747           case Event.MOUSE_ENTER:
6748               return mouseEnter(evt, evt.x, evt.y);
6749 
6750           case Event.MOUSE_EXIT:
6751               return mouseExit(evt, evt.x, evt.y);
6752 
6753           case Event.MOUSE_MOVE:
6754               return mouseMove(evt, evt.x, evt.y);
6755 
6756           case Event.MOUSE_DOWN:
6757               return mouseDown(evt, evt.x, evt.y);
6758 
6759           case Event.MOUSE_DRAG:
6760               return mouseDrag(evt, evt.x, evt.y);
6761 
6762           case Event.MOUSE_UP:
6763               return mouseUp(evt, evt.x, evt.y);
6764 
6765           case Event.KEY_PRESS:
6766           case Event.KEY_ACTION:
6767               return keyDown(evt, evt.key);
6768 
6769           case Event.KEY_RELEASE:
6770           case Event.KEY_ACTION_RELEASE:
6771               return keyUp(evt, evt.key);
6772 
6773           case Event.ACTION_EVENT:
6774               return action(evt, evt.arg);
6775           case Event.GOT_FOCUS:
6776               return gotFocus(evt, evt.arg);
6777           case Event.LOST_FOCUS:
6778               return lostFocus(evt, evt.arg);
6779         }
6780         return false;
6781     }
6782 
6783     /**
6784      * @deprecated As of JDK version 1.1,
6785      * replaced by processMouseEvent(MouseEvent).
6786      */
6787     @Deprecated
6788     public boolean mouseDown(Event evt, int x, int y) {
6789         return false;
6790     }
6791 
6792     /**
6793      * @deprecated As of JDK version 1.1,
6794      * replaced by processMouseMotionEvent(MouseEvent).
6795      */
6796     @Deprecated
6797     public boolean mouseDrag(Event evt, int x, int y) {
6798         return false;
6799     }
6800 
6801     /**
6802      * @deprecated As of JDK version 1.1,
6803      * replaced by processMouseEvent(MouseEvent).
6804      */
6805     @Deprecated
6806     public boolean mouseUp(Event evt, int x, int y) {
6807         return false;
6808     }
6809 
6810     /**
6811      * @deprecated As of JDK version 1.1,
6812      * replaced by processMouseMotionEvent(MouseEvent).
6813      */
6814     @Deprecated
6815     public boolean mouseMove(Event evt, int x, int y) {
6816         return false;
6817     }
6818 
6819     /**
6820      * @deprecated As of JDK version 1.1,
6821      * replaced by processMouseEvent(MouseEvent).
6822      */
6823     @Deprecated
6824     public boolean mouseEnter(Event evt, int x, int y) {
6825         return false;
6826     }
6827 
6828     /**
6829      * @deprecated As of JDK version 1.1,
6830      * replaced by processMouseEvent(MouseEvent).
6831      */
6832     @Deprecated
6833     public boolean mouseExit(Event evt, int x, int y) {
6834         return false;
6835     }
6836 
6837     /**
6838      * @deprecated As of JDK version 1.1,
6839      * replaced by processKeyEvent(KeyEvent).
6840      */
6841     @Deprecated
6842     public boolean keyDown(Event evt, int key) {
6843         return false;
6844     }
6845 
6846     /**
6847      * @deprecated As of JDK version 1.1,
6848      * replaced by processKeyEvent(KeyEvent).
6849      */
6850     @Deprecated
6851     public boolean keyUp(Event evt, int key) {
6852         return false;
6853     }
6854 
6855     /**
6856      * @deprecated As of JDK version 1.1,
6857      * should register this component as ActionListener on component
6858      * which fires action events.
6859      */
6860     @Deprecated
6861     public boolean action(Event evt, Object what) {
6862         return false;
6863     }
6864 
6865     /**
6866      * Makes this &lt;code&gt;Component&lt;/code&gt; displayable by connecting it to a
6867      * native screen resource.
6868      * This method is called internally by the toolkit and should
6869      * not be called directly by programs.
6870      * &lt;p&gt;
6871      * This method changes layout-related information, and therefore,
6872      * invalidates the component hierarchy.
6873      *
6874      * @see       #isDisplayable
6875      * @see       #removeNotify
6876      * @see #invalidate
6877      * @since JDK1.0
6878      */
6879     public void addNotify() {
6880         synchronized (getTreeLock()) {
6881             ComponentPeer peer = this.peer;
6882             if (peer == null || peer instanceof LightweightPeer){
6883                 if (peer == null) {
6884                     // Update both the Component's peer variable and the local
6885                     // variable we use for thread safety.
6886                     this.peer = peer = getToolkit().createComponent(this);
6887                 }
6888 
6889                 // This is a lightweight component which means it won't be
6890                 // able to get window-related events by itself.  If any
6891                 // have been enabled, then the nearest native container must
6892                 // be enabled.
6893                 if (parent != null) {
6894                     long mask = 0;
6895                     if ((mouseListener != null) || ((eventMask &amp; AWTEvent.MOUSE_EVENT_MASK) != 0)) {
6896                         mask |= AWTEvent.MOUSE_EVENT_MASK;
6897                     }
6898                     if ((mouseMotionListener != null) ||
6899                         ((eventMask &amp; AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0)) {
6900                         mask |= AWTEvent.MOUSE_MOTION_EVENT_MASK;
6901                     }
6902                     if ((mouseWheelListener != null ) ||
6903                         ((eventMask &amp; AWTEvent.MOUSE_WHEEL_EVENT_MASK) != 0)) {
6904                         mask |= AWTEvent.MOUSE_WHEEL_EVENT_MASK;
6905                     }
6906                     if (focusListener != null || (eventMask &amp; AWTEvent.FOCUS_EVENT_MASK) != 0) {
6907                         mask |= AWTEvent.FOCUS_EVENT_MASK;
6908                     }
6909                     if (keyListener != null || (eventMask &amp; AWTEvent.KEY_EVENT_MASK) != 0) {
6910                         mask |= AWTEvent.KEY_EVENT_MASK;
6911                     }
6912                     if (mask != 0) {
6913                         parent.proxyEnableEvents(mask);
6914                     }
6915                 }
6916             } else {
6917                 // It's native. If the parent is lightweight it will need some
6918                 // help.
6919                 Container parent = getContainer();
6920                 if (parent != null &amp;&amp; parent.isLightweight()) {
6921                     relocateComponent();
6922                     if (!parent.isRecursivelyVisibleUpToHeavyweightContainer())
6923                     {
6924                         peer.setVisible(false);
6925                     }
6926                 }
6927             }
6928             invalidate();
6929 
6930             int npopups = (popups != null? popups.size() : 0);
6931             for (int i = 0 ; i &lt; npopups ; i++) {
6932                 PopupMenu popup = popups.elementAt(i);
6933                 popup.addNotify();
6934             }
6935 
6936             if (dropTarget != null) dropTarget.addNotify(peer);
6937 
6938             peerFont = getFont();
6939 
6940             if (getContainer() != null &amp;&amp; !isAddNotifyComplete) {
6941                 getContainer().increaseComponentCount(this);
6942             }
6943 
6944 
6945             // Update stacking order
6946             updateZOrder();
6947 
6948             if (!isAddNotifyComplete) {
6949                 mixOnShowing();
6950             }
6951 
6952             isAddNotifyComplete = true;
6953 
6954             if (hierarchyListener != null ||
6955                 (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||
6956                 Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK)) {
6957                 HierarchyEvent e =
6958                     new HierarchyEvent(this, HierarchyEvent.HIERARCHY_CHANGED,
6959                                        this, parent,
6960                                        HierarchyEvent.DISPLAYABILITY_CHANGED |
6961                                        ((isRecursivelyVisible())
6962                                         ? HierarchyEvent.SHOWING_CHANGED
6963                                         : 0));
6964                 dispatchEvent(e);
6965             }
6966         }
6967     }
6968 
6969     /**
6970      * Makes this &lt;code&gt;Component&lt;/code&gt; undisplayable by destroying it native
6971      * screen resource.
6972      * &lt;p&gt;
6973      * This method is called by the toolkit internally and should
6974      * not be called directly by programs. Code overriding
6975      * this method should call &lt;code&gt;super.removeNotify&lt;/code&gt; as
6976      * the first line of the overriding method.
6977      *
6978      * @see       #isDisplayable
6979      * @see       #addNotify
6980      * @since JDK1.0
6981      */
6982     public void removeNotify() {
6983         KeyboardFocusManager.clearMostRecentFocusOwner(this);
6984         if (KeyboardFocusManager.getCurrentKeyboardFocusManager().
6985             getPermanentFocusOwner() == this)
6986         {
6987             KeyboardFocusManager.getCurrentKeyboardFocusManager().
6988                 setGlobalPermanentFocusOwner(null);
6989         }
6990 
6991         synchronized (getTreeLock()) {
6992             clearLightweightDispatcherOnRemove(this);
6993 
6994             if (isFocusOwner() &amp;&amp; KeyboardFocusManager.isAutoFocusTransferEnabledFor(this)) {
6995                 transferFocus(true);
6996             }
6997 
6998             if (getContainer() != null &amp;&amp; isAddNotifyComplete) {
6999                 getContainer().decreaseComponentCount(this);
7000             }
7001 
7002             int npopups = (popups != null? popups.size() : 0);
7003             for (int i = 0 ; i &lt; npopups ; i++) {
7004                 PopupMenu popup = popups.elementAt(i);
7005                 popup.removeNotify();
7006             }
7007             // If there is any input context for this component, notify
7008             // that this component is being removed. (This has to be done
7009             // before hiding peer.)
7010             if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) {
7011                 InputContext inputContext = getInputContext();
7012                 if (inputContext != null) {
7013                     inputContext.removeNotify(this);
7014                 }
7015             }
7016 
7017             ComponentPeer p = peer;
7018             if (p != null) {
7019                 boolean isLightweight = isLightweight();
7020 
7021                 if (bufferStrategy instanceof FlipBufferStrategy) {
7022                     ((FlipBufferStrategy)bufferStrategy).destroyBuffers();
7023                 }
7024 
7025                 if (dropTarget != null) dropTarget.removeNotify(peer);
7026 
7027                 // Hide peer first to stop system events such as cursor moves.
7028                 if (visible) {
7029                     p.setVisible(false);
7030                 }
7031 
7032                 peer = null; // Stop peer updates.
7033                 peerFont = null;
7034 
7035                 Toolkit.getEventQueue().removeSourceEvents(this, false);
7036                 KeyboardFocusManager.getCurrentKeyboardFocusManager().
7037                     discardKeyEvents(this);
7038 
7039                 p.dispose();
7040 
7041                 mixOnHiding(isLightweight);
7042 
7043                 isAddNotifyComplete = false;
7044                 // Nullifying compoundShape means that the component has normal shape
7045                 // (or has no shape at all).
7046                 this.compoundShape = null;
7047             }
7048 
7049             if (hierarchyListener != null ||
7050                 (eventMask &amp; AWTEvent.HIERARCHY_EVENT_MASK) != 0 ||
7051                 Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK)) {
7052                 HierarchyEvent e =
7053                     new HierarchyEvent(this, HierarchyEvent.HIERARCHY_CHANGED,
7054                                        this, parent,
7055                                        HierarchyEvent.DISPLAYABILITY_CHANGED |
7056                                        ((isRecursivelyVisible())
7057                                         ? HierarchyEvent.SHOWING_CHANGED
7058                                         : 0));
7059                 dispatchEvent(e);
7060             }
7061         }
7062     }
7063 
7064     /**
7065      * @deprecated As of JDK version 1.1,
7066      * replaced by processFocusEvent(FocusEvent).
7067      */
7068     @Deprecated
7069     public boolean gotFocus(Event evt, Object what) {
7070         return false;
7071     }
7072 
7073     /**
7074      * @deprecated As of JDK version 1.1,
7075      * replaced by processFocusEvent(FocusEvent).
7076      */
7077     @Deprecated
7078     public boolean lostFocus(Event evt, Object what) {
7079         return false;
7080     }
7081 
7082     /**
7083      * Returns whether this &lt;code&gt;Component&lt;/code&gt; can become the focus
7084      * owner.
7085      *
7086      * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is
7087      * focusable; &lt;code&gt;false&lt;/code&gt; otherwise
7088      * @see #setFocusable
7089      * @since JDK1.1
7090      * @deprecated As of 1.4, replaced by &lt;code&gt;isFocusable()&lt;/code&gt;.
7091      */
7092     @Deprecated
7093     public boolean isFocusTraversable() {
7094         if (isFocusTraversableOverridden == FOCUS_TRAVERSABLE_UNKNOWN) {
7095             isFocusTraversableOverridden = FOCUS_TRAVERSABLE_DEFAULT;
7096         }
7097         return focusable;
7098     }
7099 
7100     /**
7101      * Returns whether this Component can be focused.
7102      *
7103      * @return &lt;code&gt;true&lt;/code&gt; if this Component is focusable;
7104      *         &lt;code&gt;false&lt;/code&gt; otherwise.
7105      * @see #setFocusable
7106      * @since 1.4
7107      */
7108     public boolean isFocusable() {
7109         return isFocusTraversable();
7110     }
7111 
7112     /**
7113      * Sets the focusable state of this Component to the specified value. This
7114      * value overrides the Component's default focusability.
7115      *
7116      * @param focusable indicates whether this Component is focusable
7117      * @see #isFocusable
7118      * @since 1.4
7119      * @beaninfo
7120      *       bound: true
7121      */
7122     public void setFocusable(boolean focusable) {
7123         boolean oldFocusable;
7124         synchronized (this) {
7125             oldFocusable = this.focusable;
7126             this.focusable = focusable;
7127         }
7128         isFocusTraversableOverridden = FOCUS_TRAVERSABLE_SET;
7129 
7130         firePropertyChange("focusable", oldFocusable, focusable);
7131         if (oldFocusable &amp;&amp; !focusable) {
7132             if (isFocusOwner() &amp;&amp; KeyboardFocusManager.isAutoFocusTransferEnabled()) {
7133                 transferFocus(true);
7134             }
7135             KeyboardFocusManager.clearMostRecentFocusOwner(this);
7136         }
7137     }
7138 
7139     final boolean isFocusTraversableOverridden() {
7140         return (isFocusTraversableOverridden != FOCUS_TRAVERSABLE_DEFAULT);
7141     }
7142 
7143     /**
7144      * Sets the focus traversal keys for a given traversal operation for this
7145      * Component.
7146      * &lt;p&gt;
7147      * The default values for a Component's focus traversal keys are
7148      * implementation-dependent. Sun recommends that all implementations for a
7149      * particular native platform use the same default values. The
7150      * recommendations for Windows and Unix are listed below. These
7151      * recommendations are used in the Sun AWT implementations.
7152      *
7153      * &lt;table border=1 summary="Recommended default values for a Component's focus traversal keys"&gt;
7154      * &lt;tr&gt;
7155      *    &lt;th&gt;Identifier&lt;/th&gt;
7156      *    &lt;th&gt;Meaning&lt;/th&gt;
7157      *    &lt;th&gt;Default&lt;/th&gt;
7158      * &lt;/tr&gt;
7159      * &lt;tr&gt;
7160      *    &lt;td&gt;KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS&lt;/td&gt;
7161      *    &lt;td&gt;Normal forward keyboard traversal&lt;/td&gt;
7162      *    &lt;td&gt;TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED&lt;/td&gt;
7163      * &lt;/tr&gt;
7164      * &lt;tr&gt;
7165      *    &lt;td&gt;KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS&lt;/td&gt;
7166      *    &lt;td&gt;Normal reverse keyboard traversal&lt;/td&gt;
7167      *    &lt;td&gt;SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED&lt;/td&gt;
7168      * &lt;/tr&gt;
7169      * &lt;tr&gt;
7170      *    &lt;td&gt;KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS&lt;/td&gt;
7171      *    &lt;td&gt;Go up one focus traversal cycle&lt;/td&gt;
7172      *    &lt;td&gt;none&lt;/td&gt;
7173      * &lt;/tr&gt;
7174      * &lt;/table&gt;
7175      *
7176      * To disable a traversal key, use an empty Set; Collections.EMPTY_SET is
7177      * recommended.
7178      * &lt;p&gt;
7179      * Using the AWTKeyStroke API, client code can specify on which of two
7180      * specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal
7181      * operation will occur. Regardless of which KeyEvent is specified,
7182      * however, all KeyEvents related to the focus traversal key, including the
7183      * associated KEY_TYPED event, will be consumed, and will not be dispatched
7184      * to any Component. It is a runtime error to specify a KEY_TYPED event as
7185      * mapping to a focus traversal operation, or to map the same event to
7186      * multiple default focus traversal operations.
7187      * &lt;p&gt;
7188      * If a value of null is specified for the Set, this Component inherits the
7189      * Set from its parent. If all ancestors of this Component have null
7190      * specified for the Set, then the current KeyboardFocusManager's default
7191      * Set is used.
7192      * &lt;p&gt;
7193      * This method may throw a {@code ClassCastException} if any {@code Object}
7194      * in {@code keystrokes} is not an {@code AWTKeyStroke}.
7195      *
7196      * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
7197      *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
7198      *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
7199      * @param keystrokes the Set of AWTKeyStroke for the specified operation
7200      * @see #getFocusTraversalKeys
7201      * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
7202      * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
7203      * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
7204      * @throws IllegalArgumentException if id is not one of
7205      *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
7206      *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
7207      *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes
7208      *         contains null, or if any keystroke represents a KEY_TYPED event,
7209      *         or if any keystroke already maps to another focus traversal
7210      *         operation for this Component
7211      * @since 1.4
7212      * @beaninfo
7213      *       bound: true
7214      */
7215     public void setFocusTraversalKeys(int id,
7216                                       Set&lt;? extends AWTKeyStroke&gt; keystrokes)
7217     {
7218         if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {
7219             throw new IllegalArgumentException("invalid focus traversal key identifier");
7220         }
7221 
7222         setFocusTraversalKeys_NoIDCheck(id, keystrokes);
7223     }
7224 
7225     /**
7226      * Returns the Set of focus traversal keys for a given traversal operation
7227      * for this Component. (See
7228      * &lt;code&gt;setFocusTraversalKeys&lt;/code&gt; for a full description of each key.)
7229      * &lt;p&gt;
7230      * If a Set of traversal keys has not been explicitly defined for this
7231      * Component, then this Component's parent's Set is returned. If no Set
7232      * has been explicitly defined for any of this Component's ancestors, then
7233      * the current KeyboardFocusManager's default Set is returned.
7234      *
7235      * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
7236      *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
7237      *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
7238      * @return the Set of AWTKeyStrokes for the specified operation. The Set
7239      *         will be unmodifiable, and may be empty. null will never be
7240      *         returned.
7241      * @see #setFocusTraversalKeys
7242      * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
7243      * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
7244      * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
7245      * @throws IllegalArgumentException if id is not one of
7246      *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
7247      *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
7248      *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
7249      * @since 1.4
7250      */
7251     public Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys(int id) {
7252         if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {
7253             throw new IllegalArgumentException("invalid focus traversal key identifier");
7254         }
7255 
7256         return getFocusTraversalKeys_NoIDCheck(id);
7257     }
7258 
7259     // We define these methods so that Container does not need to repeat this
7260     // code. Container cannot call super.&lt;method&gt; because Container allows
7261     // DOWN_CYCLE_TRAVERSAL_KEY while Component does not. The Component method
7262     // would erroneously generate an IllegalArgumentException for
7263     // DOWN_CYCLE_TRAVERSAL_KEY.
7264     final void setFocusTraversalKeys_NoIDCheck(int id, Set&lt;? extends AWTKeyStroke&gt; keystrokes) {
7265         Set&lt;AWTKeyStroke&gt; oldKeys;
7266 
7267         synchronized (this) {
7268             if (focusTraversalKeys == null) {
7269                 initializeFocusTraversalKeys();
7270             }
7271 
7272             if (keystrokes != null) {
7273                 for (AWTKeyStroke keystroke : keystrokes ) {
7274 
7275                     if (keystroke == null) {
7276                         throw new IllegalArgumentException("cannot set null focus traversal key");
7277                     }
7278 
7279                     if (keystroke.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {
7280                         throw new IllegalArgumentException("focus traversal keys cannot map to KEY_TYPED events");
7281                     }
7282 
7283                     for (int i = 0; i &lt; focusTraversalKeys.length; i++) {
7284                         if (i == id) {
7285                             continue;
7286                         }
7287 
7288                         if (getFocusTraversalKeys_NoIDCheck(i).contains(keystroke))
7289                         {
7290                             throw new IllegalArgumentException("focus traversal keys must be unique for a Component");
7291                         }
7292                     }
7293                 }
7294             }
7295 
7296             oldKeys = focusTraversalKeys[id];
7297             focusTraversalKeys[id] = (keystrokes != null)
7298                 ? Collections.unmodifiableSet(new HashSet&lt;AWTKeyStroke&gt;(keystrokes))
7299                 : null;
7300         }
7301 
7302         firePropertyChange(focusTraversalKeyPropertyNames[id], oldKeys,
7303                            keystrokes);
7304     }
7305     final Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys_NoIDCheck(int id) {
7306         // Okay to return Set directly because it is an unmodifiable view
7307         @SuppressWarnings("unchecked")
7308         Set&lt;AWTKeyStroke&gt; keystrokes = (focusTraversalKeys != null)
7309             ? focusTraversalKeys[id]
7310             : null;
7311 
7312         if (keystrokes != null) {
7313             return keystrokes;
7314         } else {
7315             Container parent = this.parent;
7316             if (parent != null) {
7317                 return parent.getFocusTraversalKeys(id);
7318             } else {
7319                 return KeyboardFocusManager.getCurrentKeyboardFocusManager().
7320                     getDefaultFocusTraversalKeys(id);
7321             }
7322         }
7323     }
7324 
7325     /**
7326      * Returns whether the Set of focus traversal keys for the given focus
7327      * traversal operation has been explicitly defined for this Component. If
7328      * this method returns &lt;code&gt;false&lt;/code&gt;, this Component is inheriting the
7329      * Set from an ancestor, or from the current KeyboardFocusManager.
7330      *
7331      * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
7332      *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
7333      *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
7334      * @return &lt;code&gt;true&lt;/code&gt; if the the Set of focus traversal keys for the
7335      *         given focus traversal operation has been explicitly defined for
7336      *         this Component; &lt;code&gt;false&lt;/code&gt; otherwise.
7337      * @throws IllegalArgumentException if id is not one of
7338      *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
7339      *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
7340      *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
7341      * @since 1.4
7342      */
7343     public boolean areFocusTraversalKeysSet(int id) {
7344         if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {
7345             throw new IllegalArgumentException("invalid focus traversal key identifier");
7346         }
7347 
7348         return (focusTraversalKeys != null &amp;&amp; focusTraversalKeys[id] != null);
7349     }
7350 
7351     /**
7352      * Sets whether focus traversal keys are enabled for this Component.
7353      * Components for which focus traversal keys are disabled receive key
7354      * events for focus traversal keys. Components for which focus traversal
7355      * keys are enabled do not see these events; instead, the events are
7356      * automatically converted to traversal operations.
7357      *
7358      * @param focusTraversalKeysEnabled whether focus traversal keys are
7359      *        enabled for this Component
7360      * @see #getFocusTraversalKeysEnabled
7361      * @see #setFocusTraversalKeys
7362      * @see #getFocusTraversalKeys
7363      * @since 1.4
7364      * @beaninfo
7365      *       bound: true
7366      */
7367     public void setFocusTraversalKeysEnabled(boolean
7368                                              focusTraversalKeysEnabled) {
7369         boolean oldFocusTraversalKeysEnabled;
7370         synchronized (this) {
7371             oldFocusTraversalKeysEnabled = this.focusTraversalKeysEnabled;
7372             this.focusTraversalKeysEnabled = focusTraversalKeysEnabled;
7373         }
7374         firePropertyChange("focusTraversalKeysEnabled",
7375                            oldFocusTraversalKeysEnabled,
7376                            focusTraversalKeysEnabled);
7377     }
7378 
7379     /**
7380      * Returns whether focus traversal keys are enabled for this Component.
7381      * Components for which focus traversal keys are disabled receive key
7382      * events for focus traversal keys. Components for which focus traversal
7383      * keys are enabled do not see these events; instead, the events are
7384      * automatically converted to traversal operations.
7385      *
7386      * @return whether focus traversal keys are enabled for this Component
7387      * @see #setFocusTraversalKeysEnabled
7388      * @see #setFocusTraversalKeys
7389      * @see #getFocusTraversalKeys
7390      * @since 1.4
7391      */
7392     public boolean getFocusTraversalKeysEnabled() {
7393         return focusTraversalKeysEnabled;
7394     }
7395 
7396     /**
7397      * Requests that this Component get the input focus, and that this
7398      * Component's top-level ancestor become the focused Window. This
7399      * component must be displayable, focusable, visible and all of
7400      * its ancestors (with the exception of the top-level Window) must
7401      * be visible for the request to be granted. Every effort will be
7402      * made to honor the request; however, in some cases it may be
7403      * impossible to do so. Developers must never assume that this
7404      * Component is the focus owner until this Component receives a
7405      * FOCUS_GAINED event. If this request is denied because this
7406      * Component's top-level Window cannot become the focused Window,
7407      * the request will be remembered and will be granted when the
7408      * Window is later focused by the user.
7409      * &lt;p&gt;
7410      * This method cannot be used to set the focus owner to no Component at
7411      * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner()&lt;/code&gt;
7412      * instead.
7413      * &lt;p&gt;
7414      * Because the focus behavior of this method is platform-dependent,
7415      * developers are strongly encouraged to use
7416      * &lt;code&gt;requestFocusInWindow&lt;/code&gt; when possible.
7417      *
7418      * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
7419      * such, a component may receive focus without this or any of the other
7420      * {@code requestFocus} methods of {@code Component} being invoked.
7421      *
7422      * @see #requestFocusInWindow
7423      * @see java.awt.event.FocusEvent
7424      * @see #addFocusListener
7425      * @see #isFocusable
7426      * @see #isDisplayable
7427      * @see KeyboardFocusManager#clearGlobalFocusOwner
7428      * @since JDK1.0
7429      */
7430     public void requestFocus() {
7431         requestFocusHelper(false, true);
7432     }
7433 
7434     boolean requestFocus(CausedFocusEvent.Cause cause) {
7435         return requestFocusHelper(false, true, cause);
7436     }
7437 
7438     /**
7439      * Requests that this &lt;code&gt;Component&lt;/code&gt; get the input focus,
7440      * and that this &lt;code&gt;Component&lt;/code&gt;'s top-level ancestor
7441      * become the focused &lt;code&gt;Window&lt;/code&gt;. This component must be
7442      * displayable, focusable, visible and all of its ancestors (with
7443      * the exception of the top-level Window) must be visible for the
7444      * request to be granted. Every effort will be made to honor the
7445      * request; however, in some cases it may be impossible to do
7446      * so. Developers must never assume that this component is the
7447      * focus owner until this component receives a FOCUS_GAINED
7448      * event. If this request is denied because this component's
7449      * top-level window cannot become the focused window, the request
7450      * will be remembered and will be granted when the window is later
7451      * focused by the user.
7452      * &lt;p&gt;
7453      * This method returns a boolean value. If &lt;code&gt;false&lt;/code&gt; is returned,
7454      * the request is &lt;b&gt;guaranteed to fail&lt;/b&gt;. If &lt;code&gt;true&lt;/code&gt; is
7455      * returned, the request will succeed &lt;b&gt;unless&lt;/b&gt; it is vetoed, or an
7456      * extraordinary event, such as disposal of the component's peer, occurs
7457      * before the request can be granted by the native windowing system. Again,
7458      * while a return value of &lt;code&gt;true&lt;/code&gt; indicates that the request is
7459      * likely to succeed, developers must never assume that this component is
7460      * the focus owner until this component receives a FOCUS_GAINED event.
7461      * &lt;p&gt;
7462      * This method cannot be used to set the focus owner to no component at
7463      * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner&lt;/code&gt;
7464      * instead.
7465      * &lt;p&gt;
7466      * Because the focus behavior of this method is platform-dependent,
7467      * developers are strongly encouraged to use
7468      * &lt;code&gt;requestFocusInWindow&lt;/code&gt; when possible.
7469      * &lt;p&gt;
7470      * Every effort will be made to ensure that &lt;code&gt;FocusEvent&lt;/code&gt;s
7471      * generated as a
7472      * result of this request will have the specified temporary value. However,
7473      * because specifying an arbitrary temporary state may not be implementable
7474      * on all native windowing systems, correct behavior for this method can be
7475      * guaranteed only for lightweight &lt;code&gt;Component&lt;/code&gt;s.
7476      * This method is not intended
7477      * for general use, but exists instead as a hook for lightweight component
7478      * libraries, such as Swing.
7479      *
7480      * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
7481      * such, a component may receive focus without this or any of the other
7482      * {@code requestFocus} methods of {@code Component} being invoked.
7483      *
7484      * @param temporary true if the focus change is temporary,
7485      *        such as when the window loses the focus; for
7486      *        more information on temporary focus changes see the
7487      *&lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
7488      * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
7489      *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
7490      * @see java.awt.event.FocusEvent
7491      * @see #addFocusListener
7492      * @see #isFocusable
7493      * @see #isDisplayable
7494      * @see KeyboardFocusManager#clearGlobalFocusOwner
7495      * @since 1.4
7496      */
7497     protected boolean requestFocus(boolean temporary) {
7498         return requestFocusHelper(temporary, true);
7499     }
7500 
7501     boolean requestFocus(boolean temporary, CausedFocusEvent.Cause cause) {
7502         return requestFocusHelper(temporary, true, cause);
7503     }
7504     /**
7505      * Requests that this Component get the input focus, if this
7506      * Component's top-level ancestor is already the focused
7507      * Window. This component must be displayable, focusable, visible
7508      * and all of its ancestors (with the exception of the top-level
7509      * Window) must be visible for the request to be granted. Every
7510      * effort will be made to honor the request; however, in some
7511      * cases it may be impossible to do so. Developers must never
7512      * assume that this Component is the focus owner until this
7513      * Component receives a FOCUS_GAINED event.
7514      * &lt;p&gt;
7515      * This method returns a boolean value. If &lt;code&gt;false&lt;/code&gt; is returned,
7516      * the request is &lt;b&gt;guaranteed to fail&lt;/b&gt;. If &lt;code&gt;true&lt;/code&gt; is
7517      * returned, the request will succeed &lt;b&gt;unless&lt;/b&gt; it is vetoed, or an
7518      * extraordinary event, such as disposal of the Component's peer, occurs
7519      * before the request can be granted by the native windowing system. Again,
7520      * while a return value of &lt;code&gt;true&lt;/code&gt; indicates that the request is
7521      * likely to succeed, developers must never assume that this Component is
7522      * the focus owner until this Component receives a FOCUS_GAINED event.
7523      * &lt;p&gt;
7524      * This method cannot be used to set the focus owner to no Component at
7525      * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner()&lt;/code&gt;
7526      * instead.
7527      * &lt;p&gt;
7528      * The focus behavior of this method can be implemented uniformly across
7529      * platforms, and thus developers are strongly encouraged to use this
7530      * method over &lt;code&gt;requestFocus&lt;/code&gt; when possible. Code which relies
7531      * on &lt;code&gt;requestFocus&lt;/code&gt; may exhibit different focus behavior on
7532      * different platforms.
7533      *
7534      * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
7535      * such, a component may receive focus without this or any of the other
7536      * {@code requestFocus} methods of {@code Component} being invoked.
7537      *
7538      * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
7539      *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
7540      * @see #requestFocus
7541      * @see java.awt.event.FocusEvent
7542      * @see #addFocusListener
7543      * @see #isFocusable
7544      * @see #isDisplayable
7545      * @see KeyboardFocusManager#clearGlobalFocusOwner
7546      * @since 1.4
7547      */
7548     public boolean requestFocusInWindow() {
7549         return requestFocusHelper(false, false);
7550     }
7551 
7552     boolean requestFocusInWindow(CausedFocusEvent.Cause cause) {
7553         return requestFocusHelper(false, false, cause);
7554     }
7555 
7556     /**
7557      * Requests that this &lt;code&gt;Component&lt;/code&gt; get the input focus,
7558      * if this &lt;code&gt;Component&lt;/code&gt;'s top-level ancestor is already
7559      * the focused &lt;code&gt;Window&lt;/code&gt;.  This component must be
7560      * displayable, focusable, visible and all of its ancestors (with
7561      * the exception of the top-level Window) must be visible for the
7562      * request to be granted. Every effort will be made to honor the
7563      * request; however, in some cases it may be impossible to do
7564      * so. Developers must never assume that this component is the
7565      * focus owner until this component receives a FOCUS_GAINED event.
7566      * &lt;p&gt;
7567      * This method returns a boolean value. If &lt;code&gt;false&lt;/code&gt; is returned,
7568      * the request is &lt;b&gt;guaranteed to fail&lt;/b&gt;. If &lt;code&gt;true&lt;/code&gt; is
7569      * returned, the request will succeed &lt;b&gt;unless&lt;/b&gt; it is vetoed, or an
7570      * extraordinary event, such as disposal of the component's peer, occurs
7571      * before the request can be granted by the native windowing system. Again,
7572      * while a return value of &lt;code&gt;true&lt;/code&gt; indicates that the request is
7573      * likely to succeed, developers must never assume that this component is
7574      * the focus owner until this component receives a FOCUS_GAINED event.
7575      * &lt;p&gt;
7576      * This method cannot be used to set the focus owner to no component at
7577      * all. Use &lt;code&gt;KeyboardFocusManager.clearGlobalFocusOwner&lt;/code&gt;
7578      * instead.
7579      * &lt;p&gt;
7580      * The focus behavior of this method can be implemented uniformly across
7581      * platforms, and thus developers are strongly encouraged to use this
7582      * method over &lt;code&gt;requestFocus&lt;/code&gt; when possible. Code which relies
7583      * on &lt;code&gt;requestFocus&lt;/code&gt; may exhibit different focus behavior on
7584      * different platforms.
7585      * &lt;p&gt;
7586      * Every effort will be made to ensure that &lt;code&gt;FocusEvent&lt;/code&gt;s
7587      * generated as a
7588      * result of this request will have the specified temporary value. However,
7589      * because specifying an arbitrary temporary state may not be implementable
7590      * on all native windowing systems, correct behavior for this method can be
7591      * guaranteed only for lightweight components. This method is not intended
7592      * for general use, but exists instead as a hook for lightweight component
7593      * libraries, such as Swing.
7594      *
7595      * &lt;p&gt;Note: Not all focus transfers result from invoking this method. As
7596      * such, a component may receive focus without this or any of the other
7597      * {@code requestFocus} methods of {@code Component} being invoked.
7598      *
7599      * @param temporary true if the focus change is temporary,
7600      *        such as when the window loses the focus; for
7601      *        more information on temporary focus changes see the
7602      *&lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
7603      * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
7604      *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
7605      * @see #requestFocus
7606      * @see java.awt.event.FocusEvent
7607      * @see #addFocusListener
7608      * @see #isFocusable
7609      * @see #isDisplayable
7610      * @see KeyboardFocusManager#clearGlobalFocusOwner
7611      * @since 1.4
7612      */
7613     protected boolean requestFocusInWindow(boolean temporary) {
7614         return requestFocusHelper(temporary, false);
7615     }
7616 
7617     boolean requestFocusInWindow(boolean temporary, CausedFocusEvent.Cause cause) {
7618         return requestFocusHelper(temporary, false, cause);
7619     }
7620 
7621     final boolean requestFocusHelper(boolean temporary,
7622                                      boolean focusedWindowChangeAllowed) {
7623         return requestFocusHelper(temporary, focusedWindowChangeAllowed, CausedFocusEvent.Cause.UNKNOWN);
7624     }
7625 
7626     final boolean requestFocusHelper(boolean temporary,
7627                                      boolean focusedWindowChangeAllowed,
7628                                      CausedFocusEvent.Cause cause)
7629     {
7630         // 1) Check if the event being dispatched is a system-generated mouse event.
7631         AWTEvent currentEvent = EventQueue.getCurrentEvent();
7632         if (currentEvent instanceof MouseEvent &amp;&amp;
7633             SunToolkit.isSystemGenerated(currentEvent))
7634         {
7635             // 2) Sanity check: if the mouse event component source belongs to the same containing window.
7636             Component source = ((MouseEvent)currentEvent).getComponent();
7637             if (source == null || source.getContainingWindow() == getContainingWindow()) {
7638                 focusLog.finest("requesting focus by mouse event \"in window\"");
7639 
7640                 // If both the conditions are fulfilled the focus request should be strictly
7641                 // bounded by the toplevel window. It's assumed that the mouse event activates
7642                 // the window (if it wasn't active) and this makes it possible for a focus
7643                 // request with a strong in-window requirement to change focus in the bounds
7644                 // of the toplevel. If, by any means, due to asynchronous nature of the event
7645                 // dispatching mechanism, the window happens to be natively inactive by the time
7646                 // this focus request is eventually handled, it should not re-activate the
7647                 // toplevel. Otherwise the result may not meet user expectations. See 6981400.
7648                 focusedWindowChangeAllowed = false;
7649             }
7650         }
7651         if (!isRequestFocusAccepted(temporary, focusedWindowChangeAllowed, cause)) {
7652             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7653                 focusLog.finest("requestFocus is not accepted");
7654             }
7655             return false;
7656         }
7657         // Update most-recent map
7658         KeyboardFocusManager.setMostRecentFocusOwner(this);
7659 
7660         Component window = this;
7661         while ( (window != null) &amp;&amp; !(window instanceof Window)) {
7662             if (!window.isVisible()) {
7663                 if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7664                     focusLog.finest("component is recurively invisible");
7665                 }
7666                 return false;
7667             }
7668             window = window.parent;
7669         }
7670 
7671         ComponentPeer peer = this.peer;
7672         Component heavyweight = (peer instanceof LightweightPeer)
7673             ? getNativeContainer() : this;
7674         if (heavyweight == null || !heavyweight.isVisible()) {
7675             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7676                 focusLog.finest("Component is not a part of visible hierarchy");
7677             }
7678             return false;
7679         }
7680         peer = heavyweight.peer;
7681         if (peer == null) {
7682             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7683                 focusLog.finest("Peer is null");
7684             }
7685             return false;
7686         }
7687 
7688         // Focus this Component
7689         long time = 0;
7690         if (EventQueue.isDispatchThread()) {
7691             time = Toolkit.getEventQueue().getMostRecentKeyEventTime();
7692         } else {
7693             // A focus request made from outside EDT should not be associated with any event
7694             // and so its time stamp is simply set to the current time.
7695             time = System.currentTimeMillis();
7696         }
7697 
7698         boolean success = peer.requestFocus
7699             (this, temporary, focusedWindowChangeAllowed, time, cause);
7700         if (!success) {
7701             KeyboardFocusManager.getCurrentKeyboardFocusManager
7702                 (appContext).dequeueKeyEvents(time, this);
7703             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7704                 focusLog.finest("Peer request failed");
7705             }
7706         } else {
7707             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7708                 focusLog.finest("Pass for " + this);
7709             }
7710         }
7711         return success;
7712     }
7713 
7714     private boolean isRequestFocusAccepted(boolean temporary,
7715                                            boolean focusedWindowChangeAllowed,
7716                                            CausedFocusEvent.Cause cause)
7717     {
7718         if (!isFocusable() || !isVisible()) {
7719             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7720                 focusLog.finest("Not focusable or not visible");
7721             }
7722             return false;
7723         }
7724 
7725         ComponentPeer peer = this.peer;
7726         if (peer == null) {
7727             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7728                 focusLog.finest("peer is null");
7729             }
7730             return false;
7731         }
7732 
7733         Window window = getContainingWindow();
7734         if (window == null || !window.isFocusableWindow()) {
7735             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7736                 focusLog.finest("Component doesn't have toplevel");
7737             }
7738             return false;
7739         }
7740 
7741         // We have passed all regular checks for focus request,
7742         // now let's call RequestFocusController and see what it says.
7743         Component focusOwner = KeyboardFocusManager.getMostRecentFocusOwner(window);
7744         if (focusOwner == null) {
7745             // sometimes most recent focus owner may be null, but focus owner is not
7746             // e.g. we reset most recent focus owner if user removes focus owner
7747             focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
7748             if (focusOwner != null &amp;&amp; focusOwner.getContainingWindow() != window) {
7749                 focusOwner = null;
7750             }
7751         }
7752 
7753         if (focusOwner == this || focusOwner == null) {
7754             // Controller is supposed to verify focus transfers and for this it
7755             // should know both from and to components.  And it shouldn't verify
7756             // transfers from when these components are equal.
7757             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7758                 focusLog.finest("focus owner is null or this");
7759             }
7760             return true;
7761         }
7762 
7763         if (CausedFocusEvent.Cause.ACTIVATION == cause) {
7764             // we shouldn't call RequestFocusController in case we are
7765             // in activation.  We do request focus on component which
7766             // has got temporary focus lost and then on component which is
7767             // most recent focus owner.  But most recent focus owner can be
7768             // changed by requestFocsuXXX() call only, so this transfer has
7769             // been already approved.
7770             if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7771                 focusLog.finest("cause is activation");
7772             }
7773             return true;
7774         }
7775 
7776         boolean ret = Component.requestFocusController.acceptRequestFocus(focusOwner,
7777                                                                           this,
7778                                                                           temporary,
7779                                                                           focusedWindowChangeAllowed,
7780                                                                           cause);
7781         if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) {
7782             focusLog.finest("RequestFocusController returns {0}", ret);
7783         }
7784 
7785         return ret;
7786     }
7787 
7788     private static RequestFocusController requestFocusController = new DummyRequestFocusController();
7789 
7790     // Swing access this method through reflection to implement InputVerifier's functionality.
7791     // Perhaps, we should make this method public (later ;)
7792     private static class DummyRequestFocusController implements RequestFocusController {
7793         public boolean acceptRequestFocus(Component from, Component to,
7794                                           boolean temporary, boolean focusedWindowChangeAllowed,
7795                                           CausedFocusEvent.Cause cause)
7796         {
7797             return true;
7798         }
7799     };
7800 
7801     synchronized static void setRequestFocusController(RequestFocusController requestController)
7802     {
7803         if (requestController == null) {
7804             requestFocusController = new DummyRequestFocusController();
7805         } else {
7806             requestFocusController = requestController;
7807         }
7808     }
7809 
7810     /**
7811      * Returns the Container which is the focus cycle root of this Component's
7812      * focus traversal cycle. Each focus traversal cycle has only a single
7813      * focus cycle root and each Component which is not a Container belongs to
7814      * only a single focus traversal cycle. Containers which are focus cycle
7815      * roots belong to two cycles: one rooted at the Container itself, and one
7816      * rooted at the Container's nearest focus-cycle-root ancestor. For such
7817      * Containers, this method will return the Container's nearest focus-cycle-
7818      * root ancestor.
7819      *
7820      * @return this Component's nearest focus-cycle-root ancestor
7821      * @see Container#isFocusCycleRoot()
7822      * @since 1.4
7823      */
7824     public Container getFocusCycleRootAncestor() {
7825         Container rootAncestor = this.parent;
7826         while (rootAncestor != null &amp;&amp; !rootAncestor.isFocusCycleRoot()) {
7827             rootAncestor = rootAncestor.parent;
7828         }
7829         return rootAncestor;
7830     }
7831 
7832     /**
7833      * Returns whether the specified Container is the focus cycle root of this
7834      * Component's focus traversal cycle. Each focus traversal cycle has only
7835      * a single focus cycle root and each Component which is not a Container
7836      * belongs to only a single focus traversal cycle.
7837      *
7838      * @param container the Container to be tested
7839      * @return &lt;code&gt;true&lt;/code&gt; if the specified Container is a focus-cycle-
7840      *         root of this Component; &lt;code&gt;false&lt;/code&gt; otherwise
7841      * @see Container#isFocusCycleRoot()
7842      * @since 1.4
7843      */
7844     public boolean isFocusCycleRoot(Container container) {
7845         Container rootAncestor = getFocusCycleRootAncestor();
7846         return (rootAncestor == container);
7847     }
7848 
7849     Container getTraversalRoot() {
7850         return getFocusCycleRootAncestor();
7851     }
7852 
7853     /**
7854      * Transfers the focus to the next component, as though this Component were
7855      * the focus owner.
7856      * @see       #requestFocus()
7857      * @since     JDK1.1
7858      */
7859     public void transferFocus() {
7860         nextFocus();
7861     }
7862 
7863     /**
7864      * @deprecated As of JDK version 1.1,
7865      * replaced by transferFocus().
7866      */
7867     @Deprecated
7868     public void nextFocus() {
7869         transferFocus(false);
7870     }
7871 
7872     boolean transferFocus(boolean clearOnFailure) {
7873         if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7874             focusLog.finer("clearOnFailure = " + clearOnFailure);
7875         }
7876         Component toFocus = getNextFocusCandidate();
7877         boolean res = false;
7878         if (toFocus != null &amp;&amp; !toFocus.isFocusOwner() &amp;&amp; toFocus != this) {
7879             res = toFocus.requestFocusInWindow(CausedFocusEvent.Cause.TRAVERSAL_FORWARD);
7880         }
7881         if (clearOnFailure &amp;&amp; !res) {
7882             if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7883                 focusLog.finer("clear global focus owner");
7884             }
7885             KeyboardFocusManager.getCurrentKeyboardFocusManager().clearGlobalFocusOwnerPriv();
7886         }
7887         if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7888             focusLog.finer("returning result: " + res);
7889         }
7890         return res;
7891     }
7892 
7893     final Component getNextFocusCandidate() {
7894         Container rootAncestor = getTraversalRoot();
7895         Component comp = this;
7896         while (rootAncestor != null &amp;&amp;
7897                !(rootAncestor.isShowing() &amp;&amp; rootAncestor.canBeFocusOwner()))
7898         {
7899             comp = rootAncestor;
7900             rootAncestor = comp.getFocusCycleRootAncestor();
7901         }
7902         if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7903             focusLog.finer("comp = " + comp + ", root = " + rootAncestor);
7904         }
7905         Component candidate = null;
7906         if (rootAncestor != null) {
7907             FocusTraversalPolicy policy = rootAncestor.getFocusTraversalPolicy();
7908             Component toFocus = policy.getComponentAfter(rootAncestor, comp);
7909             if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7910                 focusLog.finer("component after is " + toFocus);
7911             }
7912             if (toFocus == null) {
7913                 toFocus = policy.getDefaultComponent(rootAncestor);
7914                 if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7915                     focusLog.finer("default component is " + toFocus);
7916                 }
7917             }
7918             if (toFocus == null) {
7919                 Applet applet = EmbeddedFrame.getAppletIfAncestorOf(this);
7920                 if (applet != null) {
7921                     toFocus = applet;
7922                 }
7923             }
7924             candidate = toFocus;
7925         }
7926         if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7927             focusLog.finer("Focus transfer candidate: " + candidate);
7928         }
7929         return candidate;
7930     }
7931 
7932     /**
7933      * Transfers the focus to the previous component, as though this Component
7934      * were the focus owner.
7935      * @see       #requestFocus()
7936      * @since     1.4
7937      */
7938     public void transferFocusBackward() {
7939         transferFocusBackward(false);
7940     }
7941 
7942     boolean transferFocusBackward(boolean clearOnFailure) {
7943         Container rootAncestor = getTraversalRoot();
7944         Component comp = this;
7945         while (rootAncestor != null &amp;&amp;
7946                !(rootAncestor.isShowing() &amp;&amp; rootAncestor.canBeFocusOwner()))
7947         {
7948             comp = rootAncestor;
7949             rootAncestor = comp.getFocusCycleRootAncestor();
7950         }
7951         boolean res = false;
7952         if (rootAncestor != null) {
7953             FocusTraversalPolicy policy = rootAncestor.getFocusTraversalPolicy();
7954             Component toFocus = policy.getComponentBefore(rootAncestor, comp);
7955             if (toFocus == null) {
7956                 toFocus = policy.getDefaultComponent(rootAncestor);
7957             }
7958             if (toFocus != null) {
7959                 res = toFocus.requestFocusInWindow(CausedFocusEvent.Cause.TRAVERSAL_BACKWARD);
7960             }
7961         }
7962         if (clearOnFailure &amp;&amp; !res) {
7963             if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7964                 focusLog.finer("clear global focus owner");
7965             }
7966             KeyboardFocusManager.getCurrentKeyboardFocusManager().clearGlobalFocusOwnerPriv();
7967         }
7968         if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {
7969             focusLog.finer("returning result: " + res);
7970         }
7971         return res;
7972     }
7973 
7974     /**
7975      * Transfers the focus up one focus traversal cycle. Typically, the focus
7976      * owner is set to this Component's focus cycle root, and the current focus
7977      * cycle root is set to the new focus owner's focus cycle root. If,
7978      * however, this Component's focus cycle root is a Window, then the focus
7979      * owner is set to the focus cycle root's default Component to focus, and
7980      * the current focus cycle root is unchanged.
7981      *
7982      * @see       #requestFocus()
7983      * @see       Container#isFocusCycleRoot()
7984      * @see       Container#setFocusCycleRoot(boolean)
7985      * @since     1.4
7986      */
7987     public void transferFocusUpCycle() {
7988         Container rootAncestor;
7989         for (rootAncestor = getFocusCycleRootAncestor();
7990              rootAncestor != null &amp;&amp; !(rootAncestor.isShowing() &amp;&amp;
7991                                        rootAncestor.isFocusable() &amp;&amp;
7992                                        rootAncestor.isEnabled());
7993              rootAncestor = rootAncestor.getFocusCycleRootAncestor()) {
7994         }
7995 
7996         if (rootAncestor != null) {
7997             Container rootAncestorRootAncestor =
7998                 rootAncestor.getFocusCycleRootAncestor();
7999             Container fcr = (rootAncestorRootAncestor != null) ?
8000                 rootAncestorRootAncestor : rootAncestor;
8001 
8002             KeyboardFocusManager.getCurrentKeyboardFocusManager().
8003                 setGlobalCurrentFocusCycleRootPriv(fcr);
8004             rootAncestor.requestFocus(CausedFocusEvent.Cause.TRAVERSAL_UP);
8005         } else {
8006             Window window = getContainingWindow();
8007 
8008             if (window != null) {
8009                 Component toFocus = window.getFocusTraversalPolicy().
8010                     getDefaultComponent(window);
8011                 if (toFocus != null) {
8012                     KeyboardFocusManager.getCurrentKeyboardFocusManager().
8013                         setGlobalCurrentFocusCycleRootPriv(window);
8014                     toFocus.requestFocus(CausedFocusEvent.Cause.TRAVERSAL_UP);
8015                 }
8016             }
8017         }
8018     }
8019 
8020     /**
8021      * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
8022      * focus owner.  This method is obsolete, and has been replaced by
8023      * &lt;code&gt;isFocusOwner()&lt;/code&gt;.
8024      *
8025      * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
8026      *         focus owner; &lt;code&gt;false&lt;/code&gt; otherwise
8027      * @since 1.2
8028      */
8029     public boolean hasFocus() {
8030         return (KeyboardFocusManager.getCurrentKeyboardFocusManager().
8031                 getFocusOwner() == this);
8032     }
8033 
8034     /**
8035      * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
8036      *    focus owner.
8037      *
8038      * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Component&lt;/code&gt; is the
8039      *     focus owner; &lt;code&gt;false&lt;/code&gt; otherwise
8040      * @since 1.4
8041      */
8042     public boolean isFocusOwner() {
8043         return hasFocus();
8044     }
8045 
8046     /*
8047      * Used to disallow auto-focus-transfer on disposal of the focus owner
8048      * in the process of disposing its parent container.
8049      */
8050     private boolean autoFocusTransferOnDisposal = true;
8051 
8052     void setAutoFocusTransferOnDisposal(boolean value) {
8053         autoFocusTransferOnDisposal = value;
8054     }
8055 
8056     boolean isAutoFocusTransferOnDisposal() {
8057         return autoFocusTransferOnDisposal;
8058     }
8059 
8060     /**
8061      * Adds the specified popup menu to the component.
8062      * @param     popup the popup menu to be added to the component.
8063      * @see       #remove(MenuComponent)
8064      * @exception NullPointerException if {@code popup} is {@code null}
8065      * @since     JDK1.1
8066      */
8067     public void add(PopupMenu popup) {
8068         synchronized (getTreeLock()) {
8069             if (popup.parent != null) {
8070                 popup.parent.remove(popup);
8071             }
8072             if (popups == null) {
8073                 popups = new Vector&lt;PopupMenu&gt;();
8074             }
8075             popups.addElement(popup);
8076             popup.parent = this;
8077 
8078             if (peer != null) {
8079                 if (popup.peer == null) {
8080                     popup.addNotify();
8081                 }
8082             }
8083         }
8084     }
8085 
8086     /**
8087      * Removes the specified popup menu from the component.
8088      * @param     popup the popup menu to be removed
8089      * @see       #add(PopupMenu)
8090      * @since     JDK1.1
8091      */
8092     @SuppressWarnings("unchecked")
8093     public void remove(MenuComponent popup) {
8094         synchronized (getTreeLock()) {
8095             if (popups == null) {
8096                 return;
8097             }
8098             int index = popups.indexOf(popup);
8099             if (index &gt;= 0) {
8100                 PopupMenu pmenu = (PopupMenu)popup;
8101                 if (pmenu.peer != null) {
8102                     pmenu.removeNotify();
8103                 }
8104                 pmenu.parent = null;
8105                 popups.removeElementAt(index);
8106                 if (popups.size() == 0) {
8107                     popups = null;
8108                 }
8109             }
8110         }
8111     }
8112 
8113     /**
8114      * Returns a string representing the state of this component. This
8115      * method is intended to be used only for debugging purposes, and the
8116      * content and format of the returned string may vary between
8117      * implementations. The returned string may be empty but may not be
8118      * &lt;code&gt;null&lt;/code&gt;.
8119      *
8120      * @return  a string representation of this component's state
8121      * @since     JDK1.0
8122      */
8123     protected String paramString() {
8124         String thisName = getName();
8125         String str = (thisName != null? thisName : "") + "," + x + "," + y + "," + width + "x" + height;
8126         if (!isValid()) {
8127             str += ",invalid";
8128         }
8129         if (!visible) {
8130             str += ",hidden";
8131         }
8132         if (!enabled) {
8133             str += ",disabled";
8134         }
8135         return str;
8136     }
8137 
8138     /**
8139      * Returns a string representation of this component and its values.
8140      * @return    a string representation of this component
8141      * @since     JDK1.0
8142      */
8143     public String toString() {
8144         return getClass().getName() + "[" + paramString() + "]";
8145     }
8146 
8147     /**
8148      * Prints a listing of this component to the standard system output
8149      * stream &lt;code&gt;System.out&lt;/code&gt;.
8150      * @see       java.lang.System#out
8151      * @since     JDK1.0
8152      */
8153     public void list() {
8154         list(System.out, 0);
8155     }
8156 
8157     /**
8158      * Prints a listing of this component to the specified output
8159      * stream.
8160      * @param    out   a print stream
8161      * @throws   NullPointerException if {@code out} is {@code null}
8162      * @since    JDK1.0
8163      */
8164     public void list(PrintStream out) {
8165         list(out, 0);
8166     }
8167 
8168     /**
8169      * Prints out a list, starting at the specified indentation, to the
8170      * specified print stream.
8171      * @param     out      a print stream
8172      * @param     indent   number of spaces to indent
8173      * @see       java.io.PrintStream#println(java.lang.Object)
8174      * @throws    NullPointerException if {@code out} is {@code null}
8175      * @since     JDK1.0
8176      */
8177     public void list(PrintStream out, int indent) {
8178         for (int i = 0 ; i &lt; indent ; i++) {
8179             out.print(" ");
8180         }
8181         out.println(this);
8182     }
8183 
8184     /**
8185      * Prints a listing to the specified print writer.
8186      * @param  out  the print writer to print to
8187      * @throws NullPointerException if {@code out} is {@code null}
8188      * @since JDK1.1
8189      */
8190     public void list(PrintWriter out) {
8191         list(out, 0);
8192     }
8193 
8194     /**
8195      * Prints out a list, starting at the specified indentation, to
8196      * the specified print writer.
8197      * @param out the print writer to print to
8198      * @param indent the number of spaces to indent
8199      * @throws NullPointerException if {@code out} is {@code null}
8200      * @see       java.io.PrintStream#println(java.lang.Object)
8201      * @since JDK1.1
8202      */
8203     public void list(PrintWriter out, int indent) {
8204         for (int i = 0 ; i &lt; indent ; i++) {
8205             out.print(" ");
8206         }
8207         out.println(this);
8208     }
8209 
8210     /*
8211      * Fetches the native container somewhere higher up in the component
8212      * tree that contains this component.
8213      */
8214     final Container getNativeContainer() {
8215         Container p = getContainer();
8216         while (p != null &amp;&amp; p.peer instanceof LightweightPeer) {
8217             p = p.getContainer();
8218         }
8219         return p;
8220     }
8221 
8222     /**
8223      * Adds a PropertyChangeListener to the listener list. The listener is
8224      * registered for all bound properties of this class, including the
8225      * following:
8226      * &lt;ul&gt;
8227      *    &lt;li&gt;this Component's font ("font")&lt;/li&gt;
8228      *    &lt;li&gt;this Component's background color ("background")&lt;/li&gt;
8229      *    &lt;li&gt;this Component's foreground color ("foreground")&lt;/li&gt;
8230      *    &lt;li&gt;this Component's focusability ("focusable")&lt;/li&gt;
8231      *    &lt;li&gt;this Component's focus traversal keys enabled state
8232      *        ("focusTraversalKeysEnabled")&lt;/li&gt;
8233      *    &lt;li&gt;this Component's Set of FORWARD_TRAVERSAL_KEYS
8234      *        ("forwardFocusTraversalKeys")&lt;/li&gt;
8235      *    &lt;li&gt;this Component's Set of BACKWARD_TRAVERSAL_KEYS
8236      *        ("backwardFocusTraversalKeys")&lt;/li&gt;
8237      *    &lt;li&gt;this Component's Set of UP_CYCLE_TRAVERSAL_KEYS
8238      *        ("upCycleFocusTraversalKeys")&lt;/li&gt;
8239      *    &lt;li&gt;this Component's preferred size ("preferredSize")&lt;/li&gt;
8240      *    &lt;li&gt;this Component's minimum size ("minimumSize")&lt;/li&gt;
8241      *    &lt;li&gt;this Component's maximum size ("maximumSize")&lt;/li&gt;
8242      *    &lt;li&gt;this Component's name ("name")&lt;/li&gt;
8243      * &lt;/ul&gt;
8244      * Note that if this &lt;code&gt;Component&lt;/code&gt; is inheriting a bound property, then no
8245      * event will be fired in response to a change in the inherited property.
8246      * &lt;p&gt;
8247      * If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
8248      * no exception is thrown and no action is performed.
8249      *
8250      * @param    listener  the property change listener to be added
8251      *
8252      * @see #removePropertyChangeListener
8253      * @see #getPropertyChangeListeners
8254      * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
8255      */
8256     public void addPropertyChangeListener(
8257                                                        PropertyChangeListener listener) {
8258         synchronized (getObjectLock()) {
8259             if (listener == null) {
8260                 return;
8261             }
8262             if (changeSupport == null) {
8263                 changeSupport = new PropertyChangeSupport(this);
8264             }
8265             changeSupport.addPropertyChangeListener(listener);
8266         }
8267     }
8268 
8269     /**
8270      * Removes a PropertyChangeListener from the listener list. This method
8271      * should be used to remove PropertyChangeListeners that were registered
8272      * for all bound properties of this class.
8273      * &lt;p&gt;
8274      * If listener is null, no exception is thrown and no action is performed.
8275      *
8276      * @param listener the PropertyChangeListener to be removed
8277      *
8278      * @see #addPropertyChangeListener
8279      * @see #getPropertyChangeListeners
8280      * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
8281      */
8282     public void removePropertyChangeListener(
8283                                                           PropertyChangeListener listener) {
8284         synchronized (getObjectLock()) {
8285             if (listener == null || changeSupport == null) {
8286                 return;
8287             }
8288             changeSupport.removePropertyChangeListener(listener);
8289         }
8290     }
8291 
8292     /**
8293      * Returns an array of all the property change listeners
8294      * registered on this component.
8295      *
8296      * @return all of this component's &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
8297      *         or an empty array if no property change
8298      *         listeners are currently registered
8299      *
8300      * @see      #addPropertyChangeListener
8301      * @see      #removePropertyChangeListener
8302      * @see      #getPropertyChangeListeners(java.lang.String)
8303      * @see      java.beans.PropertyChangeSupport#getPropertyChangeListeners
8304      * @since    1.4
8305      */
8306     public PropertyChangeListener[] getPropertyChangeListeners() {
8307         synchronized (getObjectLock()) {
8308             if (changeSupport == null) {
8309                 return new PropertyChangeListener[0];
8310             }
8311             return changeSupport.getPropertyChangeListeners();
8312         }
8313     }
8314 
8315     /**
8316      * Adds a PropertyChangeListener to the listener list for a specific
8317      * property. The specified property may be user-defined, or one of the
8318      * following:
8319      * &lt;ul&gt;
8320      *    &lt;li&gt;this Component's font ("font")&lt;/li&gt;
8321      *    &lt;li&gt;this Component's background color ("background")&lt;/li&gt;
8322      *    &lt;li&gt;this Component's foreground color ("foreground")&lt;/li&gt;
8323      *    &lt;li&gt;this Component's focusability ("focusable")&lt;/li&gt;
8324      *    &lt;li&gt;this Component's focus traversal keys enabled state
8325      *        ("focusTraversalKeysEnabled")&lt;/li&gt;
8326      *    &lt;li&gt;this Component's Set of FORWARD_TRAVERSAL_KEYS
8327      *        ("forwardFocusTraversalKeys")&lt;/li&gt;
8328      *    &lt;li&gt;this Component's Set of BACKWARD_TRAVERSAL_KEYS
8329      *        ("backwardFocusTraversalKeys")&lt;/li&gt;
8330      *    &lt;li&gt;this Component's Set of UP_CYCLE_TRAVERSAL_KEYS
8331      *        ("upCycleFocusTraversalKeys")&lt;/li&gt;
8332      * &lt;/ul&gt;
8333      * Note that if this &lt;code&gt;Component&lt;/code&gt; is inheriting a bound property, then no
8334      * event will be fired in response to a change in the inherited property.
8335      * &lt;p&gt;
8336      * If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
8337      * no exception is thrown and no action is taken.
8338      *
8339      * @param propertyName one of the property names listed above
8340      * @param listener the property change listener to be added
8341      *
8342      * @see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
8343      * @see #getPropertyChangeListeners(java.lang.String)
8344      * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
8345      */
8346     public void addPropertyChangeListener(
8347                                                        String propertyName,
8348                                                        PropertyChangeListener listener) {
8349         synchronized (getObjectLock()) {
8350             if (listener == null) {
8351                 return;
8352             }
8353             if (changeSupport == null) {
8354                 changeSupport = new PropertyChangeSupport(this);
8355             }
8356             changeSupport.addPropertyChangeListener(propertyName, listener);
8357         }
8358     }
8359 
8360     /**
8361      * Removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; from the listener
8362      * list for a specific property. This method should be used to remove
8363      * &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
8364      * that were registered for a specific bound property.
8365      * &lt;p&gt;
8366      * If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
8367      * no exception is thrown and no action is taken.
8368      *
8369      * @param propertyName a valid property name
8370      * @param listener the PropertyChangeListener to be removed
8371      *
8372      * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
8373      * @see #getPropertyChangeListeners(java.lang.String)
8374      * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)
8375      */
8376     public void removePropertyChangeListener(
8377                                                           String propertyName,
8378                                                           PropertyChangeListener listener) {
8379         synchronized (getObjectLock()) {
8380             if (listener == null || changeSupport == null) {
8381                 return;
8382             }
8383             changeSupport.removePropertyChangeListener(propertyName, listener);
8384         }
8385     }
8386 
8387     /**
8388      * Returns an array of all the listeners which have been associated
8389      * with the named property.
8390      *
8391      * @return all of the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s associated with
8392      *         the named property; if no such listeners have been added or
8393      *         if &lt;code&gt;propertyName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, an empty
8394      *         array is returned
8395      *
8396      * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
8397      * @see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
8398      * @see #getPropertyChangeListeners
8399      * @since 1.4
8400      */
8401     public PropertyChangeListener[] getPropertyChangeListeners(
8402                                                                             String propertyName) {
8403         synchronized (getObjectLock()) {
8404             if (changeSupport == null) {
8405                 return new PropertyChangeListener[0];
8406             }
8407             return changeSupport.getPropertyChangeListeners(propertyName);
8408         }
8409     }
8410 
8411     /**
8412      * Support for reporting bound property changes for Object properties.
8413      * This method can be called when a bound property has changed and it will
8414      * send the appropriate PropertyChangeEvent to any registered
8415      * PropertyChangeListeners.
8416      *
8417      * @param propertyName the property whose value has changed
8418      * @param oldValue the property's previous value
8419      * @param newValue the property's new value
8420      */
8421     protected void firePropertyChange(String propertyName,
8422                                       Object oldValue, Object newValue) {
8423         PropertyChangeSupport changeSupport;
8424         synchronized (getObjectLock()) {
8425             changeSupport = this.changeSupport;
8426         }
8427         if (changeSupport == null ||
8428             (oldValue != null &amp;&amp; newValue != null &amp;&amp; oldValue.equals(newValue))) {
8429             return;
8430         }
8431         changeSupport.firePropertyChange(propertyName, oldValue, newValue);
8432     }
8433 
8434     /**
8435      * Support for reporting bound property changes for boolean properties.
8436      * This method can be called when a bound property has changed and it will
8437      * send the appropriate PropertyChangeEvent to any registered
8438      * PropertyChangeListeners.
8439      *
8440      * @param propertyName the property whose value has changed
8441      * @param oldValue the property's previous value
8442      * @param newValue the property's new value
8443      * @since 1.4
8444      */
8445     protected void firePropertyChange(String propertyName,
8446                                       boolean oldValue, boolean newValue) {
8447         PropertyChangeSupport changeSupport = this.changeSupport;
8448         if (changeSupport == null || oldValue == newValue) {
8449             return;
8450         }
8451         changeSupport.firePropertyChange(propertyName, oldValue, newValue);
8452     }
8453 
8454     /**
8455      * Support for reporting bound property changes for integer properties.
8456      * This method can be called when a bound property has changed and it will
8457      * send the appropriate PropertyChangeEvent to any registered
8458      * PropertyChangeListeners.
8459      *
8460      * @param propertyName the property whose value has changed
8461      * @param oldValue the property's previous value
8462      * @param newValue the property's new value
8463      * @since 1.4
8464      */
8465     protected void firePropertyChange(String propertyName,
8466                                       int oldValue, int newValue) {
8467         PropertyChangeSupport changeSupport = this.changeSupport;
8468         if (changeSupport == null || oldValue == newValue) {
8469             return;
8470         }
8471         changeSupport.firePropertyChange(propertyName, oldValue, newValue);
8472     }
8473 
8474     /**
8475      * Reports a bound property change.
8476      *
8477      * @param propertyName the programmatic name of the property
8478      *          that was changed
8479      * @param oldValue the old value of the property (as a byte)
8480      * @param newValue the new value of the property (as a byte)
8481      * @see #firePropertyChange(java.lang.String, java.lang.Object,
8482      *          java.lang.Object)
8483      * @since 1.5
8484      */
8485     public void firePropertyChange(String propertyName, byte oldValue, byte newValue) {
8486         if (changeSupport == null || oldValue == newValue) {
8487             return;
8488         }
8489         firePropertyChange(propertyName, Byte.valueOf(oldValue), Byte.valueOf(newValue));
8490     }
8491 
8492     /**
8493      * Reports a bound property change.
8494      *
8495      * @param propertyName the programmatic name of the property
8496      *          that was changed
8497      * @param oldValue the old value of the property (as a char)
8498      * @param newValue the new value of the property (as a char)
8499      * @see #firePropertyChange(java.lang.String, java.lang.Object,
8500      *          java.lang.Object)
8501      * @since 1.5
8502      */
8503     public void firePropertyChange(String propertyName, char oldValue, char newValue) {
8504         if (changeSupport == null || oldValue == newValue) {
8505             return;
8506         }
8507         firePropertyChange(propertyName, new Character(oldValue), new Character(newValue));
8508     }
8509 
8510     /**
8511      * Reports a bound property change.
8512      *
8513      * @param propertyName the programmatic name of the property
8514      *          that was changed
8515      * @param oldValue the old value of the property (as a short)
8516      * @param newValue the old value of the property (as a short)
8517      * @see #firePropertyChange(java.lang.String, java.lang.Object,
8518      *          java.lang.Object)
8519      * @since 1.5
8520      */
8521     public void firePropertyChange(String propertyName, short oldValue, short newValue) {
8522         if (changeSupport == null || oldValue == newValue) {
8523             return;
8524         }
8525         firePropertyChange(propertyName, Short.valueOf(oldValue), Short.valueOf(newValue));
8526     }
8527 
8528 
8529     /**
8530      * Reports a bound property change.
8531      *
8532      * @param propertyName the programmatic name of the property
8533      *          that was changed
8534      * @param oldValue the old value of the property (as a long)
8535      * @param newValue the new value of the property (as a long)
8536      * @see #firePropertyChange(java.lang.String, java.lang.Object,
8537      *          java.lang.Object)
8538      * @since 1.5
8539      */
8540     public void firePropertyChange(String propertyName, long oldValue, long newValue) {
8541         if (changeSupport == null || oldValue == newValue) {
8542             return;
8543         }
8544         firePropertyChange(propertyName, Long.valueOf(oldValue), Long.valueOf(newValue));
8545     }
8546 
8547     /**
8548      * Reports a bound property change.
8549      *
8550      * @param propertyName the programmatic name of the property
8551      *          that was changed
8552      * @param oldValue the old value of the property (as a float)
8553      * @param newValue the new value of the property (as a float)
8554      * @see #firePropertyChange(java.lang.String, java.lang.Object,
8555      *          java.lang.Object)
8556      * @since 1.5
8557      */
8558     public void firePropertyChange(String propertyName, float oldValue, float newValue) {
8559         if (changeSupport == null || oldValue == newValue) {
8560             return;
8561         }
8562         firePropertyChange(propertyName, Float.valueOf(oldValue), Float.valueOf(newValue));
8563     }
8564 
8565     /**
8566      * Reports a bound property change.
8567      *
8568      * @param propertyName the programmatic name of the property
8569      *          that was changed
8570      * @param oldValue the old value of the property (as a double)
8571      * @param newValue the new value of the property (as a double)
8572      * @see #firePropertyChange(java.lang.String, java.lang.Object,
8573      *          java.lang.Object)
8574      * @since 1.5
8575      */
8576     public void firePropertyChange(String propertyName, double oldValue, double newValue) {
8577         if (changeSupport == null || oldValue == newValue) {
8578             return;
8579         }
8580         firePropertyChange(propertyName, Double.valueOf(oldValue), Double.valueOf(newValue));
8581     }
8582 
8583 
8584     // Serialization support.
8585 
8586     /**
8587      * Component Serialized Data Version.
8588      *
8589      * @serial
8590      */
8591     private int componentSerializedDataVersion = 4;
8592 
8593     /**
8594      * This hack is for Swing serialization. It will invoke
8595      * the Swing package private method &lt;code&gt;compWriteObjectNotify&lt;/code&gt;.
8596      */
8597     private void doSwingSerialization() {
8598         Package swingPackage = Package.getPackage("javax.swing");
8599         // For Swing serialization to correctly work Swing needs to
8600         // be notified before Component does it's serialization.  This
8601         // hack accomodates this.
8602         //
8603         // Swing classes MUST be loaded by the bootstrap class loader,
8604         // otherwise we don't consider them.
8605         for (Class&lt;?&gt; klass = Component.this.getClass(); klass != null;
8606                    klass = klass.getSuperclass()) {
8607             if (klass.getPackage() == swingPackage &amp;&amp;
8608                       klass.getClassLoader() == null) {
8609                 final Class&lt;?&gt; swingClass = klass;
8610                 // Find the first override of the compWriteObjectNotify method
8611                 Method[] methods = AccessController.doPrivileged(
8612                                                                  new PrivilegedAction&lt;Method[]&gt;() {
8613                                                                      public Method[] run() {
8614                                                                          return swingClass.getDeclaredMethods();
8615                                                                      }
8616                                                                  });
8617                 for (int counter = methods.length - 1; counter &gt;= 0;
8618                      counter--) {
8619                     final Method method = methods[counter];
8620                     if (method.getName().equals("compWriteObjectNotify")){
8621                         // We found it, use doPrivileged to make it accessible
8622                         // to use.
8623                         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
8624                                 public Void run() {
8625                                     method.setAccessible(true);
8626                                     return null;
8627                                 }
8628                             });
8629                         // Invoke the method
8630                         try {
8631                             method.invoke(this, (Object[]) null);
8632                         } catch (IllegalAccessException iae) {
8633                         } catch (InvocationTargetException ite) {
8634                         }
8635                         // We're done, bail.
8636                         return;
8637                     }
8638                 }
8639             }
8640         }
8641     }
8642 
8643     /**
8644      * Writes default serializable fields to stream.  Writes
8645      * a variety of serializable listeners as optional data.
8646      * The non-serializable listeners are detected and
8647      * no attempt is made to serialize them.
8648      *
8649      * @param s the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write
8650      * @serialData &lt;code&gt;null&lt;/code&gt; terminated sequence of
8651      *   0 or more pairs; the pair consists of a &lt;code&gt;String&lt;/code&gt;
8652      *   and an &lt;code&gt;Object&lt;/code&gt;; the &lt;code&gt;String&lt;/code&gt; indicates
8653      *   the type of object and is one of the following (as of 1.4):
8654      *   &lt;code&gt;componentListenerK&lt;/code&gt; indicating an
8655      *     &lt;code&gt;ComponentListener&lt;/code&gt; object;
8656      *   &lt;code&gt;focusListenerK&lt;/code&gt; indicating an
8657      *     &lt;code&gt;FocusListener&lt;/code&gt; object;
8658      *   &lt;code&gt;keyListenerK&lt;/code&gt; indicating an
8659      *     &lt;code&gt;KeyListener&lt;/code&gt; object;
8660      *   &lt;code&gt;mouseListenerK&lt;/code&gt; indicating an
8661      *     &lt;code&gt;MouseListener&lt;/code&gt; object;
8662      *   &lt;code&gt;mouseMotionListenerK&lt;/code&gt; indicating an
8663      *     &lt;code&gt;MouseMotionListener&lt;/code&gt; object;
8664      *   &lt;code&gt;inputMethodListenerK&lt;/code&gt; indicating an
8665      *     &lt;code&gt;InputMethodListener&lt;/code&gt; object;
8666      *   &lt;code&gt;hierarchyListenerK&lt;/code&gt; indicating an
8667      *     &lt;code&gt;HierarchyListener&lt;/code&gt; object;
8668      *   &lt;code&gt;hierarchyBoundsListenerK&lt;/code&gt; indicating an
8669      *     &lt;code&gt;HierarchyBoundsListener&lt;/code&gt; object;
8670      *   &lt;code&gt;mouseWheelListenerK&lt;/code&gt; indicating an
8671      *     &lt;code&gt;MouseWheelListener&lt;/code&gt; object
8672      * @serialData an optional &lt;code&gt;ComponentOrientation&lt;/code&gt;
8673      *    (after &lt;code&gt;inputMethodListener&lt;/code&gt;, as of 1.2)
8674      *
8675      * @see AWTEventMulticaster#save(java.io.ObjectOutputStream, java.lang.String, java.util.EventListener)
8676      * @see #componentListenerK
8677      * @see #focusListenerK
8678      * @see #keyListenerK
8679      * @see #mouseListenerK
8680      * @see #mouseMotionListenerK
8681      * @see #inputMethodListenerK
8682      * @see #hierarchyListenerK
8683      * @see #hierarchyBoundsListenerK
8684      * @see #mouseWheelListenerK
8685      * @see #readObject(ObjectInputStream)
8686      */
8687     private void writeObject(ObjectOutputStream s)
8688       throws IOException
8689     {
8690         doSwingSerialization();
8691 
8692         s.defaultWriteObject();
8693 
8694         AWTEventMulticaster.save(s, componentListenerK, componentListener);
8695         AWTEventMulticaster.save(s, focusListenerK, focusListener);
8696         AWTEventMulticaster.save(s, keyListenerK, keyListener);
8697         AWTEventMulticaster.save(s, mouseListenerK, mouseListener);
8698         AWTEventMulticaster.save(s, mouseMotionListenerK, mouseMotionListener);
8699         AWTEventMulticaster.save(s, inputMethodListenerK, inputMethodListener);
8700 
8701         s.writeObject(null);
8702         s.writeObject(componentOrientation);
8703 
8704         AWTEventMulticaster.save(s, hierarchyListenerK, hierarchyListener);
8705         AWTEventMulticaster.save(s, hierarchyBoundsListenerK,
8706                                  hierarchyBoundsListener);
8707         s.writeObject(null);
8708 
8709         AWTEventMulticaster.save(s, mouseWheelListenerK, mouseWheelListener);
8710         s.writeObject(null);
8711 
8712     }
8713 
8714     /**
8715      * Reads the &lt;code&gt;ObjectInputStream&lt;/code&gt; and if it isn't
8716      * &lt;code&gt;null&lt;/code&gt; adds a listener to receive a variety
8717      * of events fired by the component.
8718      * Unrecognized keys or values will be ignored.
8719      *
8720      * @param s the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read
8721      * @see #writeObject(ObjectOutputStream)
8722      */
8723     private void readObject(ObjectInputStream s)
8724       throws ClassNotFoundException, IOException
8725     {
8726         objectLock = new Object();
8727 
8728         acc = AccessController.getContext();
8729 
8730         s.defaultReadObject();
8731 
8732         appContext = AppContext.getAppContext();
8733         coalescingEnabled = checkCoalescing();
8734         if (componentSerializedDataVersion &lt; 4) {
8735             // These fields are non-transient and rely on default
8736             // serialization. However, the default values are insufficient,
8737             // so we need to set them explicitly for object data streams prior
8738             // to 1.4.
8739             focusable = true;
8740             isFocusTraversableOverridden = FOCUS_TRAVERSABLE_UNKNOWN;
8741             initializeFocusTraversalKeys();
8742             focusTraversalKeysEnabled = true;
8743         }
8744 
8745         Object keyOrNull;
8746         while(null != (keyOrNull = s.readObject())) {
8747             String key = ((String)keyOrNull).intern();
8748 
8749             if (componentListenerK == key)
8750                 addComponentListener((ComponentListener)(s.readObject()));
8751 
8752             else if (focusListenerK == key)
8753                 addFocusListener((FocusListener)(s.readObject()));
8754 
8755             else if (keyListenerK == key)
8756                 addKeyListener((KeyListener)(s.readObject()));
8757 
8758             else if (mouseListenerK == key)
8759                 addMouseListener((MouseListener)(s.readObject()));
8760 
8761             else if (mouseMotionListenerK == key)
8762                 addMouseMotionListener((MouseMotionListener)(s.readObject()));
8763 
8764             else if (inputMethodListenerK == key)
8765                 addInputMethodListener((InputMethodListener)(s.readObject()));
8766 
8767             else // skip value for unrecognized key
8768                 s.readObject();
8769 
8770         }
8771 
8772         // Read the component's orientation if it's present
8773         Object orient = null;
8774 
8775         try {
8776             orient = s.readObject();
8777         } catch (java.io.OptionalDataException e) {
8778             // JDK 1.1 instances will not have this optional data.
8779             // e.eof will be true to indicate that there is no more
8780             // data available for this object.
8781             // If e.eof is not true, throw the exception as it
8782             // might have been caused by reasons unrelated to
8783             // componentOrientation.
8784 
8785             if (!e.eof)  {
8786                 throw (e);
8787             }
8788         }
8789 
8790         if (orient != null) {
8791             componentOrientation = (ComponentOrientation)orient;
8792         } else {
8793             componentOrientation = ComponentOrientation.UNKNOWN;
8794         }
8795 
8796         try {
8797             while(null != (keyOrNull = s.readObject())) {
8798                 String key = ((String)keyOrNull).intern();
8799 
8800                 if (hierarchyListenerK == key) {
8801                     addHierarchyListener((HierarchyListener)(s.readObject()));
8802                 }
8803                 else if (hierarchyBoundsListenerK == key) {
8804                     addHierarchyBoundsListener((HierarchyBoundsListener)
8805                                                (s.readObject()));
8806                 }
8807                 else {
8808                     // skip value for unrecognized key
8809                     s.readObject();
8810                 }
8811             }
8812         } catch (java.io.OptionalDataException e) {
8813             // JDK 1.1/1.2 instances will not have this optional data.
8814             // e.eof will be true to indicate that there is no more
8815             // data available for this object.
8816             // If e.eof is not true, throw the exception as it
8817             // might have been caused by reasons unrelated to
8818             // hierarchy and hierarchyBounds listeners.
8819 
8820             if (!e.eof)  {
8821                 throw (e);
8822             }
8823         }
8824 
8825         try {
8826             while (null != (keyOrNull = s.readObject())) {
8827                 String key = ((String)keyOrNull).intern();
8828 
8829                 if (mouseWheelListenerK == key) {
8830                     addMouseWheelListener((MouseWheelListener)(s.readObject()));
8831                 }
8832                 else {
8833                     // skip value for unrecognized key
8834                     s.readObject();
8835                 }
8836             }
8837         } catch (java.io.OptionalDataException e) {
8838             // pre-1.3 instances will not have this optional data.
8839             // e.eof will be true to indicate that there is no more
8840             // data available for this object.
8841             // If e.eof is not true, throw the exception as it
8842             // might have been caused by reasons unrelated to
8843             // mouse wheel listeners
8844 
8845             if (!e.eof)  {
8846                 throw (e);
8847             }
8848         }
8849 
8850         if (popups != null) {
8851             int npopups = popups.size();
8852             for (int i = 0 ; i &lt; npopups ; i++) {
8853                 PopupMenu popup = popups.elementAt(i);
8854                 popup.parent = this;
8855             }
8856         }
8857     }
8858 
8859     /**
8860      * Sets the language-sensitive orientation that is to be used to order
8861      * the elements or text within this component.  Language-sensitive
8862      * &lt;code&gt;LayoutManager&lt;/code&gt; and &lt;code&gt;Component&lt;/code&gt;
8863      * subclasses will use this property to
8864      * determine how to lay out and draw components.
8865      * &lt;p&gt;
8866      * At construction time, a component's orientation is set to
8867      * &lt;code&gt;ComponentOrientation.UNKNOWN&lt;/code&gt;,
8868      * indicating that it has not been specified
8869      * explicitly.  The UNKNOWN orientation behaves the same as
8870      * &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt;.
8871      * &lt;p&gt;
8872      * To set the orientation of a single component, use this method.
8873      * To set the orientation of an entire component
8874      * hierarchy, use
8875      * {@link #applyComponentOrientation applyComponentOrientation}.
8876      * &lt;p&gt;
8877      * This method changes layout-related information, and therefore,
8878      * invalidates the component hierarchy.
8879      *
8880      *
8881      * @see ComponentOrientation
8882      * @see #invalidate
8883      *
8884      * @author Laura Werner, IBM
8885      * @beaninfo
8886      *       bound: true
8887      */
8888     public void setComponentOrientation(ComponentOrientation o) {
8889         ComponentOrientation oldValue = componentOrientation;
8890         componentOrientation = o;
8891 
8892         // This is a bound property, so report the change to
8893         // any registered listeners.  (Cheap if there are none.)
8894         firePropertyChange("componentOrientation", oldValue, o);
8895 
8896         // This could change the preferred size of the Component.
8897         invalidateIfValid();
8898     }
8899 
8900     /**
8901      * Retrieves the language-sensitive orientation that is to be used to order
8902      * the elements or text within this component.  &lt;code&gt;LayoutManager&lt;/code&gt;
8903      * and &lt;code&gt;Component&lt;/code&gt;
8904      * subclasses that wish to respect orientation should call this method to
8905      * get the component's orientation before performing layout or drawing.
8906      *
8907      * @see ComponentOrientation
8908      *
8909      * @author Laura Werner, IBM
8910      */
8911     public ComponentOrientation getComponentOrientation() {
8912         return componentOrientation;
8913     }
8914 
8915     /**
8916      * Sets the &lt;code&gt;ComponentOrientation&lt;/code&gt; property of this component
8917      * and all components contained within it.
8918      * &lt;p&gt;
8919      * This method changes layout-related information, and therefore,
8920      * invalidates the component hierarchy.
8921      *
8922      *
8923      * @param orientation the new component orientation of this component and
8924      *        the components contained within it.
8925      * @exception NullPointerException if &lt;code&gt;orientation&lt;/code&gt; is null.
8926      * @see #setComponentOrientation
8927      * @see #getComponentOrientation
8928      * @see #invalidate
8929      * @since 1.4
8930      */
8931     public void applyComponentOrientation(ComponentOrientation orientation) {
8932         if (orientation == null) {
8933             throw new NullPointerException();
8934         }
8935         setComponentOrientation(orientation);
8936     }
8937 
8938     final boolean canBeFocusOwner() {
8939         // It is enabled, visible, focusable.
8940         if (isEnabled() &amp;&amp; isDisplayable() &amp;&amp; isVisible() &amp;&amp; isFocusable()) {
8941             return true;
8942         }
8943         return false;
8944     }
8945 
8946     /**
8947      * Checks that this component meets the prerequesites to be focus owner:
8948      * - it is enabled, visible, focusable
8949      * - it's parents are all enabled and showing
8950      * - top-level window is focusable
8951      * - if focus cycle root has DefaultFocusTraversalPolicy then it also checks that this policy accepts
8952      * this component as focus owner
8953      * @since 1.5
8954      */
8955     final boolean canBeFocusOwnerRecursively() {
8956         // - it is enabled, visible, focusable
8957         if (!canBeFocusOwner()) {
8958             return false;
8959         }
8960 
8961         // - it's parents are all enabled and showing
8962         synchronized(getTreeLock()) {
8963             if (parent != null) {
8964                 return parent.canContainFocusOwner(this);
8965             }
8966         }
8967         return true;
8968     }
8969 
8970     /**
8971      * Fix the location of the HW component in a LW container hierarchy.
8972      */
8973     final void relocateComponent() {
8974         synchronized (getTreeLock()) {
8975             if (peer == null) {
8976                 return;
8977             }
8978             int nativeX = x;
8979             int nativeY = y;
8980             for (Component cont = getContainer();
8981                     cont != null &amp;&amp; cont.isLightweight();
8982                     cont = cont.getContainer())
8983             {
8984                 nativeX += cont.x;
8985                 nativeY += cont.y;
8986             }
8987             peer.setBounds(nativeX, nativeY, width, height,
8988                     ComponentPeer.SET_LOCATION);
8989         }
8990     }
8991 
8992     /**
8993      * Returns the &lt;code&gt;Window&lt;/code&gt; ancestor of the component.
8994      * @return Window ancestor of the component or component by itself if it is Window;
8995      *         null, if component is not a part of window hierarchy
8996      */
8997     Window getContainingWindow() {
8998         return SunToolkit.getContainingWindow(this);
8999     }
9000 
9001     /**
9002      * Initialize JNI field and method IDs
9003      */
9004     private static native void initIDs();
9005 
9006     /*
9007      * --- Accessibility Support ---
9008      *
9009      *  Component will contain all of the methods in interface Accessible,
9010      *  though it won't actually implement the interface - that will be up
9011      *  to the individual objects which extend Component.
9012      */
9013 
9014     /**
9015      * The {@code AccessibleContext} associated with this {@code Component}.
9016      */
9017     protected AccessibleContext accessibleContext = null;
9018 
9019     /**
9020      * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated
9021      * with this &lt;code&gt;Component&lt;/code&gt;.
9022      * The method implemented by this base
9023      * class returns null.  Classes that extend &lt;code&gt;Component&lt;/code&gt;
9024      * should implement this method to return the
9025      * &lt;code&gt;AccessibleContext&lt;/code&gt; associated with the subclass.
9026      *
9027      *
9028      * @return the &lt;code&gt;AccessibleContext&lt;/code&gt; of this
9029      *    &lt;code&gt;Component&lt;/code&gt;
9030      * @since 1.3
9031      */
9032     public AccessibleContext getAccessibleContext() {
9033         return accessibleContext;
9034     }
9035 
9036     /**
9037      * Inner class of Component used to provide default support for
9038      * accessibility.  This class is not meant to be used directly by
9039      * application developers, but is instead meant only to be
9040      * subclassed by component developers.
9041      * &lt;p&gt;
9042      * The class used to obtain the accessible role for this object.
9043      * @since 1.3
9044      */
9045     protected abstract class AccessibleAWTComponent extends AccessibleContext
9046         implements Serializable, AccessibleComponent {
9047 
9048         private static final long serialVersionUID = 642321655757800191L;
9049 
9050         /**
9051          * Though the class is abstract, this should be called by
9052          * all sub-classes.
9053          */
9054         protected AccessibleAWTComponent() {
9055         }
9056 
9057         /**
9058          * Number of PropertyChangeListener objects registered. It's used
9059          * to add/remove ComponentListener and FocusListener to track
9060          * target Component's state.
9061          */
9062         private volatile transient int propertyListenersCount = 0;
9063 
9064         protected ComponentListener accessibleAWTComponentHandler = null;
9065         protected FocusListener accessibleAWTFocusHandler = null;
9066 
9067         /**
9068          * Fire PropertyChange listener, if one is registered,
9069          * when shown/hidden..
9070          * @since 1.3
9071          */
9072         protected class AccessibleAWTComponentHandler implements ComponentListener {
9073             public void componentHidden(ComponentEvent e)  {
9074                 if (accessibleContext != null) {
9075                     accessibleContext.firePropertyChange(
9076                                                          AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9077                                                          AccessibleState.VISIBLE, null);
9078                 }
9079             }
9080 
9081             public void componentShown(ComponentEvent e)  {
9082                 if (accessibleContext != null) {
9083                     accessibleContext.firePropertyChange(
9084                                                          AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9085                                                          null, AccessibleState.VISIBLE);
9086                 }
9087             }
9088 
9089             public void componentMoved(ComponentEvent e)  {
9090             }
9091 
9092             public void componentResized(ComponentEvent e)  {
9093             }
9094         } // inner class AccessibleAWTComponentHandler
9095 
9096 
9097         /**
9098          * Fire PropertyChange listener, if one is registered,
9099          * when focus events happen
9100          * @since 1.3
9101          */
9102         protected class AccessibleAWTFocusHandler implements FocusListener {
9103             public void focusGained(FocusEvent event) {
9104                 if (accessibleContext != null) {
9105                     accessibleContext.firePropertyChange(
9106                                                          AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9107                                                          null, AccessibleState.FOCUSED);
9108                 }
9109             }
9110             public void focusLost(FocusEvent event) {
9111                 if (accessibleContext != null) {
9112                     accessibleContext.firePropertyChange(
9113                                                          AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9114                                                          AccessibleState.FOCUSED, null);
9115                 }
9116             }
9117         }  // inner class AccessibleAWTFocusHandler
9118 
9119 
9120         /**
9121          * Adds a &lt;code&gt;PropertyChangeListener&lt;/code&gt; to the listener list.
9122          *
9123          * @param listener  the property change listener to be added
9124          */
9125         public void addPropertyChangeListener(PropertyChangeListener listener) {
9126             if (accessibleAWTComponentHandler == null) {
9127                 accessibleAWTComponentHandler = new AccessibleAWTComponentHandler();
9128             }
9129             if (accessibleAWTFocusHandler == null) {
9130                 accessibleAWTFocusHandler = new AccessibleAWTFocusHandler();
9131             }
9132             if (propertyListenersCount++ == 0) {
9133                 Component.this.addComponentListener(accessibleAWTComponentHandler);
9134                 Component.this.addFocusListener(accessibleAWTFocusHandler);
9135             }
9136             super.addPropertyChangeListener(listener);
9137         }
9138 
9139         /**
9140          * Remove a PropertyChangeListener from the listener list.
9141          * This removes a PropertyChangeListener that was registered
9142          * for all properties.
9143          *
9144          * @param listener  The PropertyChangeListener to be removed
9145          */
9146         public void removePropertyChangeListener(PropertyChangeListener listener) {
9147             if (--propertyListenersCount == 0) {
9148                 Component.this.removeComponentListener(accessibleAWTComponentHandler);
9149                 Component.this.removeFocusListener(accessibleAWTFocusHandler);
9150             }
9151             super.removePropertyChangeListener(listener);
9152         }
9153 
9154         // AccessibleContext methods
9155         //
9156         /**
9157          * Gets the accessible name of this object.  This should almost never
9158          * return &lt;code&gt;java.awt.Component.getName()&lt;/code&gt;,
9159          * as that generally isn't a localized name,
9160          * and doesn't have meaning for the user.  If the
9161          * object is fundamentally a text object (e.g. a menu item), the
9162          * accessible name should be the text of the object (e.g. "save").
9163          * If the object has a tooltip, the tooltip text may also be an
9164          * appropriate String to return.
9165          *
9166          * @return the localized name of the object -- can be
9167          *         &lt;code&gt;null&lt;/code&gt; if this
9168          *         object does not have a name
9169          * @see javax.accessibility.AccessibleContext#setAccessibleName
9170          */
9171         public String getAccessibleName() {
9172             return accessibleName;
9173         }
9174 
9175         /**
9176          * Gets the accessible description of this object.  This should be
9177          * a concise, localized description of what this object is - what
9178          * is its meaning to the user.  If the object has a tooltip, the
9179          * tooltip text may be an appropriate string to return, assuming
9180          * it contains a concise description of the object (instead of just
9181          * the name of the object - e.g. a "Save" icon on a toolbar that
9182          * had "save" as the tooltip text shouldn't return the tooltip
9183          * text as the description, but something like "Saves the current
9184          * text document" instead).
9185          *
9186          * @return the localized description of the object -- can be
9187          *        &lt;code&gt;null&lt;/code&gt; if this object does not have a description
9188          * @see javax.accessibility.AccessibleContext#setAccessibleDescription
9189          */
9190         public String getAccessibleDescription() {
9191             return accessibleDescription;
9192         }
9193 
9194         /**
9195          * Gets the role of this object.
9196          *
9197          * @return an instance of &lt;code&gt;AccessibleRole&lt;/code&gt;
9198          *      describing the role of the object
9199          * @see javax.accessibility.AccessibleRole
9200          */
9201         public AccessibleRole getAccessibleRole() {
9202             return AccessibleRole.AWT_COMPONENT;
9203         }
9204 
9205         /**
9206          * Gets the state of this object.
9207          *
9208          * @return an instance of &lt;code&gt;AccessibleStateSet&lt;/code&gt;
9209          *       containing the current state set of the object
9210          * @see javax.accessibility.AccessibleState
9211          */
9212         public AccessibleStateSet getAccessibleStateSet() {
9213             return Component.this.getAccessibleStateSet();
9214         }
9215 
9216         /**
9217          * Gets the &lt;code&gt;Accessible&lt;/code&gt; parent of this object.
9218          * If the parent of this object implements &lt;code&gt;Accessible&lt;/code&gt;,
9219          * this method should simply return &lt;code&gt;getParent&lt;/code&gt;.
9220          *
9221          * @return the &lt;code&gt;Accessible&lt;/code&gt; parent of this
9222          *      object -- can be &lt;code&gt;null&lt;/code&gt; if this
9223          *      object does not have an &lt;code&gt;Accessible&lt;/code&gt; parent
9224          */
9225         public Accessible getAccessibleParent() {
9226             if (accessibleParent != null) {
9227                 return accessibleParent;
9228             } else {
9229                 Container parent = getParent();
9230                 if (parent instanceof Accessible) {
9231                     return (Accessible) parent;
9232                 }
9233             }
9234             return null;
9235         }
9236 
9237         /**
9238          * Gets the index of this object in its accessible parent.
9239          *
9240          * @return the index of this object in its parent; or -1 if this
9241          *    object does not have an accessible parent
9242          * @see #getAccessibleParent
9243          */
9244         public int getAccessibleIndexInParent() {
9245             return Component.this.getAccessibleIndexInParent();
9246         }
9247 
9248         /**
9249          * Returns the number of accessible children in the object.  If all
9250          * of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
9251          * then this method should return the number of children of this object.
9252          *
9253          * @return the number of accessible children in the object
9254          */
9255         public int getAccessibleChildrenCount() {
9256             return 0; // Components don't have children
9257         }
9258 
9259         /**
9260          * Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.
9261          *
9262          * @param i zero-based index of child
9263          * @return the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object
9264          */
9265         public Accessible getAccessibleChild(int i) {
9266             return null; // Components don't have children
9267         }
9268 
9269         /**
9270          * Returns the locale of this object.
9271          *
9272          * @return the locale of this object
9273          */
9274         public Locale getLocale() {
9275             return Component.this.getLocale();
9276         }
9277 
9278         /**
9279          * Gets the &lt;code&gt;AccessibleComponent&lt;/code&gt; associated
9280          * with this object if one exists.
9281          * Otherwise return &lt;code&gt;null&lt;/code&gt;.
9282          *
9283          * @return the component
9284          */
9285         public AccessibleComponent getAccessibleComponent() {
9286             return this;
9287         }
9288 
9289 
9290         // AccessibleComponent methods
9291         //
9292         /**
9293          * Gets the background color of this object.
9294          *
9295          * @return the background color, if supported, of the object;
9296          *      otherwise, &lt;code&gt;null&lt;/code&gt;
9297          */
9298         public Color getBackground() {
9299             return Component.this.getBackground();
9300         }
9301 
9302         /**
9303          * Sets the background color of this object.
9304          * (For transparency, see &lt;code&gt;isOpaque&lt;/code&gt;.)
9305          *
9306          * @param c the new &lt;code&gt;Color&lt;/code&gt; for the background
9307          * @see Component#isOpaque
9308          */
9309         public void setBackground(Color c) {
9310             Component.this.setBackground(c);
9311         }
9312 
9313         /**
9314          * Gets the foreground color of this object.
9315          *
9316          * @return the foreground color, if supported, of the object;
9317          *     otherwise, &lt;code&gt;null&lt;/code&gt;
9318          */
9319         public Color getForeground() {
9320             return Component.this.getForeground();
9321         }
9322 
9323         /**
9324          * Sets the foreground color of this object.
9325          *
9326          * @param c the new &lt;code&gt;Color&lt;/code&gt; for the foreground
9327          */
9328         public void setForeground(Color c) {
9329             Component.this.setForeground(c);
9330         }
9331 
9332         /**
9333          * Gets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
9334          *
9335          * @return the &lt;code&gt;Cursor&lt;/code&gt;, if supported,
9336          *     of the object; otherwise, &lt;code&gt;null&lt;/code&gt;
9337          */
9338         public Cursor getCursor() {
9339             return Component.this.getCursor();
9340         }
9341 
9342         /**
9343          * Sets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
9344          * &lt;p&gt;
9345          * The method may have no visual effect if the Java platform
9346          * implementation and/or the native system do not support
9347          * changing the mouse cursor shape.
9348          * @param cursor the new &lt;code&gt;Cursor&lt;/code&gt; for the object
9349          */
9350         public void setCursor(Cursor cursor) {
9351             Component.this.setCursor(cursor);
9352         }
9353 
9354         /**
9355          * Gets the &lt;code&gt;Font&lt;/code&gt; of this object.
9356          *
9357          * @return the &lt;code&gt;Font&lt;/code&gt;, if supported,
9358          *    for the object; otherwise, &lt;code&gt;null&lt;/code&gt;
9359          */
9360         public Font getFont() {
9361             return Component.this.getFont();
9362         }
9363 
9364         /**
9365          * Sets the &lt;code&gt;Font&lt;/code&gt; of this object.
9366          *
9367          * @param f the new &lt;code&gt;Font&lt;/code&gt; for the object
9368          */
9369         public void setFont(Font f) {
9370             Component.this.setFont(f);
9371         }
9372 
9373         /**
9374          * Gets the &lt;code&gt;FontMetrics&lt;/code&gt; of this object.
9375          *
9376          * @param f the &lt;code&gt;Font&lt;/code&gt;
9377          * @return the &lt;code&gt;FontMetrics&lt;/code&gt;, if supported,
9378          *     the object; otherwise, &lt;code&gt;null&lt;/code&gt;
9379          * @see #getFont
9380          */
9381         public FontMetrics getFontMetrics(Font f) {
9382             if (f == null) {
9383                 return null;
9384             } else {
9385                 return Component.this.getFontMetrics(f);
9386             }
9387         }
9388 
9389         /**
9390          * Determines if the object is enabled.
9391          *
9392          * @return true if object is enabled; otherwise, false
9393          */
9394         public boolean isEnabled() {
9395             return Component.this.isEnabled();
9396         }
9397 
9398         /**
9399          * Sets the enabled state of the object.
9400          *
9401          * @param b if true, enables this object; otherwise, disables it
9402          */
9403         public void setEnabled(boolean b) {
9404             boolean old = Component.this.isEnabled();
9405             Component.this.setEnabled(b);
9406             if (b != old) {
9407                 if (accessibleContext != null) {
9408                     if (b) {
9409                         accessibleContext.firePropertyChange(
9410                                                              AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9411                                                              null, AccessibleState.ENABLED);
9412                     } else {
9413                         accessibleContext.firePropertyChange(
9414                                                              AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9415                                                              AccessibleState.ENABLED, null);
9416                     }
9417                 }
9418             }
9419         }
9420 
9421         /**
9422          * Determines if the object is visible.  Note: this means that the
9423          * object intends to be visible; however, it may not in fact be
9424          * showing on the screen because one of the objects that this object
9425          * is contained by is not visible.  To determine if an object is
9426          * showing on the screen, use &lt;code&gt;isShowing&lt;/code&gt;.
9427          *
9428          * @return true if object is visible; otherwise, false
9429          */
9430         public boolean isVisible() {
9431             return Component.this.isVisible();
9432         }
9433 
9434         /**
9435          * Sets the visible state of the object.
9436          *
9437          * @param b if true, shows this object; otherwise, hides it
9438          */
9439         public void setVisible(boolean b) {
9440             boolean old = Component.this.isVisible();
9441             Component.this.setVisible(b);
9442             if (b != old) {
9443                 if (accessibleContext != null) {
9444                     if (b) {
9445                         accessibleContext.firePropertyChange(
9446                                                              AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9447                                                              null, AccessibleState.VISIBLE);
9448                     } else {
9449                         accessibleContext.firePropertyChange(
9450                                                              AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
9451                                                              AccessibleState.VISIBLE, null);
9452                     }
9453                 }
9454             }
9455         }
9456 
9457         /**
9458          * Determines if the object is showing.  This is determined by checking
9459          * the visibility of the object and ancestors of the object.  Note:
9460          * this will return true even if the object is obscured by another
9461          * (for example, it happens to be underneath a menu that was pulled
9462          * down).
9463          *
9464          * @return true if object is showing; otherwise, false
9465          */
9466         public boolean isShowing() {
9467             return Component.this.isShowing();
9468         }
9469 
9470         /**
9471          * Checks whether the specified point is within this object's bounds,
9472          * where the point's x and y coordinates are defined to be relative to
9473          * the coordinate system of the object.
9474          *
9475          * @param p the &lt;code&gt;Point&lt;/code&gt; relative to the
9476          *     coordinate system of the object
9477          * @return true if object contains &lt;code&gt;Point&lt;/code&gt;; otherwise false
9478          */
9479         public boolean contains(Point p) {
9480             return Component.this.contains(p);
9481         }
9482 
9483         /**
9484          * Returns the location of the object on the screen.
9485          *
9486          * @return location of object on screen -- can be
9487          *    &lt;code&gt;null&lt;/code&gt; if this object is not on the screen
9488          */
9489         public Point getLocationOnScreen() {
9490             synchronized (Component.this.getTreeLock()) {
9491                 if (Component.this.isShowing()) {
9492                     return Component.this.getLocationOnScreen();
9493                 } else {
9494                     return null;
9495                 }
9496             }
9497         }
9498 
9499         /**
9500          * Gets the location of the object relative to the parent in the form
9501          * of a point specifying the object's top-left corner in the screen's
9502          * coordinate space.
9503          *
9504          * @return an instance of Point representing the top-left corner of
9505          * the object's bounds in the coordinate space of the screen;
9506          * &lt;code&gt;null&lt;/code&gt; if this object or its parent are not on the screen
9507          */
9508         public Point getLocation() {
9509             return Component.this.getLocation();
9510         }
9511 
9512         /**
9513          * Sets the location of the object relative to the parent.
9514          * @param p  the coordinates of the object
9515          */
9516         public void setLocation(Point p) {
9517             Component.this.setLocation(p);
9518         }
9519 
9520         /**
9521          * Gets the bounds of this object in the form of a Rectangle object.
9522          * The bounds specify this object's width, height, and location
9523          * relative to its parent.
9524          *
9525          * @return a rectangle indicating this component's bounds;
9526          *   &lt;code&gt;null&lt;/code&gt; if this object is not on the screen
9527          */
9528         public Rectangle getBounds() {
9529             return Component.this.getBounds();
9530         }
9531 
9532         /**
9533          * Sets the bounds of this object in the form of a
9534          * &lt;code&gt;Rectangle&lt;/code&gt; object.
9535          * The bounds specify this object's width, height, and location
9536          * relative to its parent.
9537          *
9538          * @param r a rectangle indicating this component's bounds
9539          */
9540         public void setBounds(Rectangle r) {
9541             Component.this.setBounds(r);
9542         }
9543 
9544         /**
9545          * Returns the size of this object in the form of a
9546          * &lt;code&gt;Dimension&lt;/code&gt; object. The height field of the
9547          * &lt;code&gt;Dimension&lt;/code&gt; object contains this objects's
9548          * height, and the width field of the &lt;code&gt;Dimension&lt;/code&gt;
9549          * object contains this object's width.
9550          *
9551          * @return a &lt;code&gt;Dimension&lt;/code&gt; object that indicates
9552          *     the size of this component; &lt;code&gt;null&lt;/code&gt; if
9553          *     this object is not on the screen
9554          */
9555         public Dimension getSize() {
9556             return Component.this.getSize();
9557         }
9558 
9559         /**
9560          * Resizes this object so that it has width and height.
9561          *
9562          * @param d - the dimension specifying the new size of the object
9563          */
9564         public void setSize(Dimension d) {
9565             Component.this.setSize(d);
9566         }
9567 
9568         /**
9569          * Returns the &lt;code&gt;Accessible&lt;/code&gt; child,
9570          * if one exists, contained at the local
9571          * coordinate &lt;code&gt;Point&lt;/code&gt;.  Otherwise returns
9572          * &lt;code&gt;null&lt;/code&gt;.
9573          *
9574          * @param p the point defining the top-left corner of
9575          *      the &lt;code&gt;Accessible&lt;/code&gt;, given in the
9576          *      coordinate space of the object's parent
9577          * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
9578          *      at the specified location; else &lt;code&gt;null&lt;/code&gt;
9579          */
9580         public Accessible getAccessibleAt(Point p) {
9581             return null; // Components don't have children
9582         }
9583 
9584         /**
9585          * Returns whether this object can accept focus or not.
9586          *
9587          * @return true if object can accept focus; otherwise false
9588          */
9589         public boolean isFocusTraversable() {
9590             return Component.this.isFocusTraversable();
9591         }
9592 
9593         /**
9594          * Requests focus for this object.
9595          */
9596         public void requestFocus() {
9597             Component.this.requestFocus();
9598         }
9599 
9600         /**
9601          * Adds the specified focus listener to receive focus events from this
9602          * component.
9603          *
9604          * @param l the focus listener
9605          */
9606         public void addFocusListener(FocusListener l) {
9607             Component.this.addFocusListener(l);
9608         }
9609 
9610         /**
9611          * Removes the specified focus listener so it no longer receives focus
9612          * events from this component.
9613          *
9614          * @param l the focus listener
9615          */
9616         public void removeFocusListener(FocusListener l) {
9617             Component.this.removeFocusListener(l);
9618         }
9619 
9620     } // inner class AccessibleAWTComponent
9621 
9622 
9623     /**
9624      * Gets the index of this object in its accessible parent.
9625      * If this object does not have an accessible parent, returns
9626      * -1.
9627      *
9628      * @return the index of this object in its accessible parent
9629      */
9630     int getAccessibleIndexInParent() {
9631         synchronized (getTreeLock()) {
9632             int index = -1;
9633             Container parent = this.getParent();
9634             if (parent != null &amp;&amp; parent instanceof Accessible) {
9635                 Component ca[] = parent.getComponents();
9636                 for (int i = 0; i &lt; ca.length; i++) {
9637                     if (ca[i] instanceof Accessible) {
9638                         index++;
9639                     }
9640                     if (this.equals(ca[i])) {
9641                         return index;
9642                     }
9643                 }
9644             }
9645             return -1;
9646         }
9647     }
9648 
9649     /**
9650      * Gets the current state set of this object.
9651      *
9652      * @return an instance of &lt;code&gt;AccessibleStateSet&lt;/code&gt;
9653      *    containing the current state set of the object
9654      * @see AccessibleState
9655      */
9656     AccessibleStateSet getAccessibleStateSet() {
9657         synchronized (getTreeLock()) {
9658             AccessibleStateSet states = new AccessibleStateSet();
9659             if (this.isEnabled()) {
9660                 states.add(AccessibleState.ENABLED);
9661             }
9662             if (this.isFocusTraversable()) {
9663                 states.add(AccessibleState.FOCUSABLE);
9664             }
9665             if (this.isVisible()) {
9666                 states.add(AccessibleState.VISIBLE);
9667             }
9668             if (this.isShowing()) {
9669                 states.add(AccessibleState.SHOWING);
9670             }
9671             if (this.isFocusOwner()) {
9672                 states.add(AccessibleState.FOCUSED);
9673             }
9674             if (this instanceof Accessible) {
9675                 AccessibleContext ac = ((Accessible) this).getAccessibleContext();
9676                 if (ac != null) {
9677                     Accessible ap = ac.getAccessibleParent();
9678                     if (ap != null) {
9679                         AccessibleContext pac = ap.getAccessibleContext();
9680                         if (pac != null) {
9681                             AccessibleSelection as = pac.getAccessibleSelection();
9682                             if (as != null) {
9683                                 states.add(AccessibleState.SELECTABLE);
9684                                 int i = ac.getAccessibleIndexInParent();
9685                                 if (i &gt;= 0) {
9686                                     if (as.isAccessibleChildSelected(i)) {
9687                                         states.add(AccessibleState.SELECTED);
9688                                     }
9689                                 }
9690                             }
9691                         }
9692                     }
9693                 }
9694             }
9695             if (Component.isInstanceOf(this, "javax.swing.JComponent")) {
9696                 if (((javax.swing.JComponent) this).isOpaque()) {
9697                     states.add(AccessibleState.OPAQUE);
9698                 }
9699             }
9700             return states;
9701         }
9702     }
9703 
9704     /**
9705      * Checks that the given object is instance of the given class.
9706      * @param obj Object to be checked
9707      * @param className The name of the class. Must be fully-qualified class name.
9708      * @return true, if this object is instanceof given class,
9709      *         false, otherwise, or if obj or className is null
9710      */
9711     static boolean isInstanceOf(Object obj, String className) {
9712         if (obj == null) return false;
9713         if (className == null) return false;
9714 
9715         Class&lt;?&gt; cls = obj.getClass();
9716         while (cls != null) {
9717             if (cls.getName().equals(className)) {
9718                 return true;
9719             }
9720             cls = cls.getSuperclass();
9721         }
9722         return false;
9723     }
9724 
9725 
9726     // ************************** MIXING CODE *******************************
9727 
9728     /**
9729      * Check whether we can trust the current bounds of the component.
9730      * The return value of false indicates that the container of the
9731      * component is invalid, and therefore needs to be layed out, which would
9732      * probably mean changing the bounds of its children.
9733      * Null-layout of the container or absence of the container mean
9734      * the bounds of the component are final and can be trusted.
9735      */
9736     final boolean areBoundsValid() {
9737         Container cont = getContainer();
9738         return cont == null || cont.isValid() || cont.getLayout() == null;
9739     }
9740 
9741     /**
9742      * Applies the shape to the component
9743      * @param shape Shape to be applied to the component
9744      */
9745     void applyCompoundShape(Region shape) {
9746         checkTreeLock();
9747 
9748         if (!areBoundsValid()) {
9749             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
9750                 mixingLog.fine("this = " + this + "; areBoundsValid = " + areBoundsValid());
9751             }
9752             return;
9753         }
9754 
9755         if (!isLightweight()) {
9756             ComponentPeer peer = getPeer();
9757             if (peer != null) {
9758                 // The Region class has some optimizations. That's why
9759                 // we should manually check whether it's empty and
9760                 // substitute the object ourselves. Otherwise we end up
9761                 // with some incorrect Region object with loX being
9762                 // greater than the hiX for instance.
9763                 if (shape.isEmpty()) {
9764                     shape = Region.EMPTY_REGION;
9765                 }
9766 
9767 
9768                 // Note: the shape is not really copied/cloned. We create
9769                 // the Region object ourselves, so there's no any possibility
9770                 // to modify the object outside of the mixing code.
9771                 // Nullifying compoundShape means that the component has normal shape
9772                 // (or has no shape at all).
9773                 if (shape.equals(getNormalShape())) {
9774                     if (this.compoundShape == null) {
9775                         return;
9776                     }
9777                     this.compoundShape = null;
9778                     peer.applyShape(null);
9779                 } else {
9780                     if (shape.equals(getAppliedShape())) {
9781                         return;
9782                     }
9783                     this.compoundShape = shape;
9784                     Point compAbsolute = getLocationOnWindow();
9785                     if (mixingLog.isLoggable(PlatformLogger.Level.FINER)) {
9786                         mixingLog.fine("this = " + this +
9787                                 "; compAbsolute=" + compAbsolute + "; shape=" + shape);
9788                     }
9789                     peer.applyShape(shape.getTranslatedRegion(-compAbsolute.x, -compAbsolute.y));
9790                 }
9791             }
9792         }
9793     }
9794 
9795     /**
9796      * Returns the shape previously set with applyCompoundShape().
9797      * If the component is LW or no shape was applied yet,
9798      * the method returns the normal shape.
9799      */
9800     private Region getAppliedShape() {
9801         checkTreeLock();
9802         //XXX: if we allow LW components to have a shape, this must be changed
9803         return (this.compoundShape == null || isLightweight()) ? getNormalShape() : this.compoundShape;
9804     }
9805 
9806     Point getLocationOnWindow() {
9807         checkTreeLock();
9808         Point curLocation = getLocation();
9809 
9810         for (Container parent = getContainer();
9811                 parent != null &amp;&amp; !(parent instanceof Window);
9812                 parent = parent.getContainer())
9813         {
9814             curLocation.x += parent.getX();
9815             curLocation.y += parent.getY();
9816         }
9817 
9818         return curLocation;
9819     }
9820 
9821     /**
9822      * Returns the full shape of the component located in window coordinates
9823      */
9824     final Region getNormalShape() {
9825         checkTreeLock();
9826         //XXX: we may take into account a user-specified shape for this component
9827         Point compAbsolute = getLocationOnWindow();
9828         return
9829             Region.getInstanceXYWH(
9830                     compAbsolute.x,
9831                     compAbsolute.y,
9832                     getWidth(),
9833                     getHeight()
9834             );
9835     }
9836 
9837     /**
9838      * Returns the "opaque shape" of the component.
9839      *
9840      * The opaque shape of a lightweight components is the actual shape that
9841      * needs to be cut off of the heavyweight components in order to mix this
9842      * lightweight component correctly with them.
9843      *
9844      * The method is overriden in the java.awt.Container to handle non-opaque
9845      * containers containing opaque children.
9846      *
9847      * See 6637655 for details.
9848      */
9849     Region getOpaqueShape() {
9850         checkTreeLock();
9851         if (mixingCutoutRegion != null) {
9852             return mixingCutoutRegion;
9853         } else {
9854             return getNormalShape();
9855         }
9856     }
9857 
9858     final int getSiblingIndexAbove() {
9859         checkTreeLock();
9860         Container parent = getContainer();
9861         if (parent == null) {
9862             return -1;
9863         }
9864 
9865         int nextAbove = parent.getComponentZOrder(this) - 1;
9866 
9867         return nextAbove &lt; 0 ? -1 : nextAbove;
9868     }
9869 
9870     final ComponentPeer getHWPeerAboveMe() {
9871         checkTreeLock();
9872 
9873         Container cont = getContainer();
9874         int indexAbove = getSiblingIndexAbove();
9875 
9876         while (cont != null) {
9877             for (int i = indexAbove; i &gt; -1; i--) {
9878                 Component comp = cont.getComponent(i);
9879                 if (comp != null &amp;&amp; comp.isDisplayable() &amp;&amp; !comp.isLightweight()) {
9880                     return comp.getPeer();
9881                 }
9882             }
9883             // traversing the hierarchy up to the closest HW container;
9884             // further traversing may return a component that is not actually
9885             // a native sibling of this component and this kind of z-order
9886             // request may not be allowed by the underlying system (6852051).
9887             if (!cont.isLightweight()) {
9888                 break;
9889             }
9890 
9891             indexAbove = cont.getSiblingIndexAbove();
9892             cont = cont.getContainer();
9893         }
9894 
9895         return null;
9896     }
9897 
9898     final int getSiblingIndexBelow() {
9899         checkTreeLock();
9900         Container parent = getContainer();
9901         if (parent == null) {
9902             return -1;
9903         }
9904 
9905         int nextBelow = parent.getComponentZOrder(this) + 1;
9906 
9907         return nextBelow &gt;= parent.getComponentCount() ? -1 : nextBelow;
9908     }
9909 
9910     final boolean isNonOpaqueForMixing() {
9911         return mixingCutoutRegion != null &amp;&amp;
9912             mixingCutoutRegion.isEmpty();
9913     }
9914 
9915     private Region calculateCurrentShape() {
9916         checkTreeLock();
9917         Region s = getNormalShape();
9918 
9919         if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
9920             mixingLog.fine("this = " + this + "; normalShape=" + s);
9921         }
9922 
9923         if (getContainer() != null) {
9924             Component comp = this;
9925             Container cont = comp.getContainer();
9926 
9927             while (cont != null) {
9928                 for (int index = comp.getSiblingIndexAbove(); index != -1; --index) {
9929                     /* It is assumed that:
9930                      *
9931                      *    getComponent(getContainer().getComponentZOrder(comp)) == comp
9932                      *
9933                      * The assumption has been made according to the current
9934                      * implementation of the Container class.
9935                      */
9936                     Component c = cont.getComponent(index);
9937                     if (c.isLightweight() &amp;&amp; c.isShowing()) {
9938                         s = s.getDifference(c.getOpaqueShape());
9939                     }
9940                 }
9941 
9942                 if (cont.isLightweight()) {
9943                     s = s.getIntersection(cont.getNormalShape());
9944                 } else {
9945                     break;
9946                 }
9947 
9948                 comp = cont;
9949                 cont = cont.getContainer();
9950             }
9951         }
9952 
9953         if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
9954             mixingLog.fine("currentShape=" + s);
9955         }
9956 
9957         return s;
9958     }
9959 
9960     void applyCurrentShape() {
9961         checkTreeLock();
9962         if (!areBoundsValid()) {
9963             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
9964                 mixingLog.fine("this = " + this + "; areBoundsValid = " + areBoundsValid());
9965             }
9966             return; // Because applyCompoundShape() ignores such components anyway
9967         }
9968         if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
9969             mixingLog.fine("this = " + this);
9970         }
9971         applyCompoundShape(calculateCurrentShape());
9972     }
9973 
9974     final void subtractAndApplyShape(Region s) {
9975         checkTreeLock();
9976 
9977         if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
9978             mixingLog.fine("this = " + this + "; s=" + s);
9979         }
9980 
9981         applyCompoundShape(getAppliedShape().getDifference(s));
9982     }
9983 
9984     private final void applyCurrentShapeBelowMe() {
9985         checkTreeLock();
9986         Container parent = getContainer();
9987         if (parent != null &amp;&amp; parent.isShowing()) {
9988             // First, reapply shapes of my siblings
9989             parent.recursiveApplyCurrentShape(getSiblingIndexBelow());
9990 
9991             // Second, if my container is non-opaque, reapply shapes of siblings of my container
9992             Container parent2 = parent.getContainer();
9993             while (!parent.isOpaque() &amp;&amp; parent2 != null) {
9994                 parent2.recursiveApplyCurrentShape(parent.getSiblingIndexBelow());
9995 
9996                 parent = parent2;
9997                 parent2 = parent.getContainer();
9998             }
9999         }
10000     }
10001 
10002     final void subtractAndApplyShapeBelowMe() {
10003         checkTreeLock();
10004         Container parent = getContainer();
10005         if (parent != null &amp;&amp; isShowing()) {
10006             Region opaqueShape = getOpaqueShape();
10007 
10008             // First, cut my siblings
10009             parent.recursiveSubtractAndApplyShape(opaqueShape, getSiblingIndexBelow());
10010 
10011             // Second, if my container is non-opaque, cut siblings of my container
10012             Container parent2 = parent.getContainer();
10013             while (!parent.isOpaque() &amp;&amp; parent2 != null) {
10014                 parent2.recursiveSubtractAndApplyShape(opaqueShape, parent.getSiblingIndexBelow());
10015 
10016                 parent = parent2;
10017                 parent2 = parent.getContainer();
10018             }
10019         }
10020     }
10021 
10022     void mixOnShowing() {
10023         synchronized (getTreeLock()) {
10024             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
10025                 mixingLog.fine("this = " + this);
10026             }
10027             if (!isMixingNeeded()) {
10028                 return;
10029             }
10030             if (isLightweight()) {
10031                 subtractAndApplyShapeBelowMe();
10032             } else {
10033                 applyCurrentShape();
10034             }
10035         }
10036     }
10037 
10038     void mixOnHiding(boolean isLightweight) {
10039         // We cannot be sure that the peer exists at this point, so we need the argument
10040         //    to find out whether the hiding component is (well, actually was) a LW or a HW.
10041         synchronized (getTreeLock()) {
10042             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
10043                 mixingLog.fine("this = " + this + "; isLightweight = " + isLightweight);
10044             }
10045             if (!isMixingNeeded()) {
10046                 return;
10047             }
10048             if (isLightweight) {
10049                 applyCurrentShapeBelowMe();
10050             }
10051         }
10052     }
10053 
10054     void mixOnReshaping() {
10055         synchronized (getTreeLock()) {
10056             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
10057                 mixingLog.fine("this = " + this);
10058             }
10059             if (!isMixingNeeded()) {
10060                 return;
10061             }
10062             if (isLightweight()) {
10063                 applyCurrentShapeBelowMe();
10064             } else {
10065                 applyCurrentShape();
10066             }
10067         }
10068     }
10069 
10070     void mixOnZOrderChanging(int oldZorder, int newZorder) {
10071         synchronized (getTreeLock()) {
10072             boolean becameHigher = newZorder &lt; oldZorder;
10073             Container parent = getContainer();
10074 
10075             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
10076                 mixingLog.fine("this = " + this +
10077                     "; oldZorder=" + oldZorder + "; newZorder=" + newZorder + "; parent=" + parent);
10078             }
10079             if (!isMixingNeeded()) {
10080                 return;
10081             }
10082             if (isLightweight()) {
10083                 if (becameHigher) {
10084                     if (parent != null &amp;&amp; isShowing()) {
10085                         parent.recursiveSubtractAndApplyShape(getOpaqueShape(), getSiblingIndexBelow(), oldZorder);
10086                     }
10087                 } else {
10088                     if (parent != null) {
10089                         parent.recursiveApplyCurrentShape(oldZorder, newZorder);
10090                     }
10091                 }
10092             } else {
10093                 if (becameHigher) {
10094                     applyCurrentShape();
10095                 } else {
10096                     if (parent != null) {
10097                         Region shape = getAppliedShape();
10098 
10099                         for (int index = oldZorder; index &lt; newZorder; index++) {
10100                             Component c = parent.getComponent(index);
10101                             if (c.isLightweight() &amp;&amp; c.isShowing()) {
10102                                 shape = shape.getDifference(c.getOpaqueShape());
10103                             }
10104                         }
10105                         applyCompoundShape(shape);
10106                     }
10107                 }
10108             }
10109         }
10110     }
10111 
10112     void mixOnValidating() {
10113         // This method gets overriden in the Container. Obviously, a plain
10114         // non-container components don't need to handle validation.
10115     }
10116 
10117     final boolean isMixingNeeded() {
10118         if (SunToolkit.getSunAwtDisableMixing()) {
10119             if (mixingLog.isLoggable(PlatformLogger.Level.FINEST)) {
10120                 mixingLog.finest("this = " + this + "; Mixing disabled via sun.awt.disableMixing");
10121             }
10122             return false;
10123         }
10124         if (!areBoundsValid()) {
10125             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
10126                 mixingLog.fine("this = " + this + "; areBoundsValid = " + areBoundsValid());
10127             }
10128             return false;
10129         }
10130         Window window = getContainingWindow();
10131         if (window != null) {
10132             if (!window.hasHeavyweightDescendants() || !window.hasLightweightDescendants() || window.isDisposing()) {
10133                 if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
10134                     mixingLog.fine("containing window = " + window +
10135                             "; has h/w descendants = " + window.hasHeavyweightDescendants() +
10136                             "; has l/w descendants = " + window.hasLightweightDescendants() +
10137                             "; disposing = " + window.isDisposing());
10138                 }
10139                 return false;
10140             }
10141         } else {
10142             if (mixingLog.isLoggable(PlatformLogger.Level.FINE)) {
10143                 mixingLog.fine("this = " + this + "; containing window is null");
10144             }
10145             return false;
10146         }
10147         return true;
10148     }
10149 
10150     // ****************** END OF MIXING CODE ********************************
10151 
10152     // Note that the method is overriden in the Window class,
10153     // a window doesn't need to be updated in the Z-order.
10154     void updateZOrder() {
10155         peer.setZOrder(getHWPeerAboveMe());
10156     }
10157 
10158 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
